/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("chessalyzer", [], factory);
	else if(typeof exports === 'object')
		exports["chessalyzer"] = factory();
	else
		root["chessalyzer"] = factory();
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/ChessBoard.js":
/*!********************************!*\
  !*** ./src/core/ChessBoard.js ***!
  \********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, module, __webpack_exports__ */
/*! CommonJS bailout: this is used directly at 13:89-93 */
/*! CommonJS bailout: module.exports is used directly at 209:2-16 */
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  const pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\n  const pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n  class PiecePositionTable {\n    constructor() {\n      this.posMap = {\n        w: {\n          R: {\n            Ra: [7, 0],\n            Rh: [7, 7]\n          },\n          N: {\n            Nb: [7, 1],\n            Ng: [7, 6]\n          },\n          B: {\n            Bc: [7, 2],\n            Bf: [7, 5]\n          },\n          Q: {\n            Qd: [7, 3]\n          },\n          K: {\n            Ke: [7, 4]\n          }\n        },\n        b: {\n          R: {\n            Ra: [0, 0],\n            Rh: [0, 7]\n          },\n          N: {\n            Nb: [0, 1],\n            Ng: [0, 6]\n          },\n          B: {\n            Bc: [0, 2],\n            Bf: [0, 5]\n          },\n          Q: {\n            Qd: [0, 3]\n          },\n          K: {\n            Ke: [0, 4]\n          }\n        }\n      };\n    }\n\n    takes(player, piece) {\n      if (!piece.includes('P')) {\n        delete this.posMap[player][piece.substring(0, 1)][piece];\n      }\n    }\n\n    moves(player, piece, to) {\n      if (!piece.includes('P')) {\n        this.posMap[player][piece.substring(0, 1)][piece] = to;\n      }\n    }\n\n    promotes(player, piece, on) {\n      if (!piece.includes('P')) {\n        this.posMap[player][piece.substring(0, 1)][piece] = on;\n      }\n    }\n\n  }\n\n  class ChessPiece {\n    constructor(name, color) {\n      this.name = name;\n      this.color = color;\n    }\n\n  }\n\n  class ChessBoard {\n    constructor() {\n      this.tiles = new Array(8);\n\n      for (let row = 0; row < 8; row += 1) {\n        const currRow = new Array(8);\n\n        for (let col = 0; col < 8; col += 1) {\n          currRow[col] = null;\n          const color = row === 0 || row === 1 ? 'b' : 'w'; // init pieces\n\n          if (row === 0 || row === 7) {\n            currRow[col] = new ChessPiece(pieceTemplate[col], color);\n          } else if (row === 1 || row === 6) {\n            currRow[col] = new ChessPiece(pawnTemplate[col], color);\n          }\n        }\n\n        this.tiles[row] = currRow;\n      }\n\n      this.defaultTiles = this.tiles.map(arr => arr.slice());\n      this.pieces = new PiecePositionTable();\n      this.promoteCounter = 0;\n    }\n\n    move(moveData) {\n      const {\n        from\n      } = moveData;\n      const {\n        to\n      } = moveData; // === castles ===\n\n      if (moveData.castles) {\n        this.castle(moveData.castles, moveData.player); // moves/takes\n      } else if (from[0] !== -1) {\n        // === takes ===\n        if (moveData.takes.pos) {\n          // update piece map\n          this.pieces.takes(moveData.player === 'w' ? 'b' : 'w', moveData.takes.piece); // update board\n\n          this.tiles[moveData.takes.pos[0]][moveData.takes.pos[1]] = null;\n        } // === moves ===\n        // update piece map\n\n\n        this.pieces.moves(moveData.player, moveData.piece, to); // update board\n\n        this.tiles[to[0]][to[1]] = this.tiles[from[0]][from[1]];\n        this.tiles[from[0]][from[1]] = null;\n\n        if (moveData.promotesTo) {\n          const pieceName = `${moveData.promotesTo}${this.promoteCounter}`;\n          this.tiles[to[0]][to[1]] = new ChessPiece(pieceName, moveData.player);\n          this.pieces.promotes(moveData.player, pieceName, to);\n          this.promoteCounter += 1;\n        }\n      }\n    }\n\n    castle(move, player) {\n      const row = player === 'w' ? 7 : 0;\n      const scrKingCol = 4;\n      let tarKingCol = 6;\n      let srcRookCol = 7;\n      let tarRookCol = 5;\n\n      if (move === 'O-O-O') {\n        tarKingCol = 2;\n        tarRookCol = 3;\n        srcRookCol = 0;\n      } // move king\n\n\n      this.pieces.moves(player, 'Ke', [row, tarKingCol]);\n      this.tiles[row][tarKingCol] = this.tiles[row][scrKingCol];\n      this.tiles[row][scrKingCol] = null; // move rook\n\n      this.pieces.moves(player, this.tiles[row][srcRookCol].name, [row, tarRookCol]);\n      this.tiles[row][tarRookCol] = this.tiles[row][srcRookCol];\n      this.tiles[row][srcRookCol] = null;\n    }\n\n    reset() {\n      this.tiles = this.defaultTiles.map(arr => arr.slice());\n      this.pieces = new PiecePositionTable();\n      this.promoteCounter = 0;\n    }\n    /** Prints the current board position to the console. */\n\n\n    printPosition() {\n      for (let row = 0; row < 8; row += 1) {\n        for (let col = 0; col < 8; col += 1) {\n          const piece = this.tiles[row][col];\n\n          if (piece !== null) {\n            process.stdout.write(`|${piece.color}${piece.name}|`);\n          } else {\n            process.stdout.write('|...|');\n          }\n        }\n\n        process.stdout.write('\\n');\n      }\n    }\n\n  }\n\n  var _default = ChessBoard;\n  _exports.default = _default;\n  module.exports = exports.default;\n});\n\n//# sourceURL=webpack://chessalyzer/./src/core/ChessBoard.js?");

/***/ }),

/***/ "./src/core/Chessalyzer.js":
/*!*********************************!*\
  !*** ./src/core/Chessalyzer.js ***!
  \*********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, module, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 13:89-93 */
/*! CommonJS bailout: module.exports is used directly at 316:2-16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./GameProcessor */ \"./src/core/GameProcessor.js\"), __webpack_require__(/*! ../tracker/PieceTrackerBase */ \"./src/tracker/PieceTrackerBase.js\"), __webpack_require__(/*! ../tracker/TileTrackerBase */ \"./src/tracker/TileTrackerBase.js\"), __webpack_require__(/*! ../tracker/GameTrackerBase */ \"./src/tracker/GameTrackerBase.js\"), __webpack_require__(/*! ../tracker/BaseTracker */ \"./src/tracker/BaseTracker.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports, _GameProcessor, _PieceTrackerBase, _TileTrackerBase, _GameTrackerBase, _BaseTracker) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _GameProcessor = _interopRequireDefault(_GameProcessor);\n  _PieceTrackerBase = _interopRequireDefault(_PieceTrackerBase);\n  _TileTrackerBase = _interopRequireDefault(_TileTrackerBase);\n  _GameTrackerBase = _interopRequireDefault(_GameTrackerBase);\n  _BaseTracker = _interopRequireDefault(_BaseTracker);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  const {\n    performance\n  } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\n\n  const chalk = __webpack_require__(/*! chalk */ \"chalk\");\n\n  const fs = __webpack_require__(/*! fs */ \"fs\");\n\n  const pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\n  const pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n  /** Main class for batch processing and generating heat maps */\n\n  class Chessalyzer {\n    /**\n     * Starts the singlethreaded batch processing for the selected file\n     * @param {String} path - Path to the PGN file that should be analyzed\n     * @param {(Object|Object[])} analyzer - The analysis functions that shall be run\n     *  during batch processing. Can be one single analyzer or an array of analyzers.\n     * @param {Object} [cfg = {}]\n     * @param {Function} [cfg.filter = ()=>true] - Filter function for selecting games\n     * @param {Number} [cfg.cntGames = Infinite ] - Max amount of games to process\n     * @param {Object} callback - Callback object\n     * @param {Function} [callback.fun] - Callback function that is called every callback.rate games\n     * @param {Number} [callback.rate] - Every 'rate' games the callback function is called.\n     * @returns {Promise}\n     */\n    static async startBatch(path, analyzer, cfg = {}, callback = {\n      fun: () => {},\n      rate: 250\n    }) {\n      // check if single analyzer or array is passed\n      let analyzerArray = analyzer;\n\n      if (!Array.isArray(analyzerArray)) {\n        analyzerArray = [analyzer];\n      }\n\n      const gameProcessor = new _GameProcessor.default(); // callback handler\n\n      gameProcessor.on('status', gameCnt => {\n        callback.fun(gameCnt);\n      });\n      const t0 = performance.now();\n      const header = await gameProcessor.processPGN(path, cfg, analyzerArray, callback.rate);\n      const t1 = performance.now();\n      const tdiff = Math.round(t1 - t0) / 1000;\n      const mps = Math.round(header.cntMoves / tdiff);\n      console.log(`${header.cntGames} games (${header.cntMoves} moves) processed in ${tdiff}s (${mps} moves/s)`);\n      return header;\n    }\n    /**\n     * Starts the multithreaded batch processing for the selected file\n     * @param {String} path - Path to the PGN file that should be analyzed\n     * @param {(Object|Object[])} analyzer - The analysis functions that shall be run\n     *  during batch processing. Can be one single analyzer or an array of analyzers.\n     * @param {Numer} [nCores = -1] Numbers of threads to use. Is limited to the max. amount\n     *  of threads of the running machine.\n     * @param {Function} [cfg.filter = ()=>true] - Filter function for selecting games\n     * @param {Number} [cfg.cntGames = Infinite ] - Max amount of games to process\n     * @returns {Promise}\n     */\n\n\n    static async startBatchMultiCore(path, analyzer, cfg = {}, batchSize = 8000, nThreads = 1) {\n      // check if single analyzer or array is passed\n      let analyzerArray = analyzer;\n\n      if (!Array.isArray(analyzerArray)) {\n        analyzerArray = [analyzer];\n      }\n\n      const t0 = performance.now();\n      const header = await _GameProcessor.default.processPGNMultiCore(path, cfg, analyzerArray, batchSize, nThreads);\n      const t1 = performance.now();\n      const tdiff = Math.round(t1 - t0) / 1000;\n      const mps = Math.round(header.cntMoves / tdiff);\n      console.log(`${header.cntGames} games (${header.cntMoves} moves) processed in ${tdiff}s (${mps} moves/s)`);\n      header.mps = mps;\n      return header;\n    }\n    /**\n     * Saves a completed batch run to a JSON file\n     * @param {String} path - Path the data file shall be saved to\n     * @param {Object} data - The data that shall be saved\n     */\n\n\n    static saveData(path, data) {\n      fs.writeFile(path, JSON.stringify(data), err => {\n        if (err) {\n          console.error(err);\n          return;\n        }\n\n        console.log('File has been created.');\n      });\n    }\n    /**\n     * Loads the stats of a previous batch run (JSON) to a data bank\n     * @param {String} path - Path the data file shall be loaded from\n     * @returns {Object} Returns the loaded data\n     */\n\n\n    static loadData(path) {\n      const data = JSON.parse(fs.readFileSync(path, 'utf8'));\n      console.log(`File '${path}' has been loaded.`);\n      return data;\n    }\n    /**\n     * Generates a heatmap out of the tracked data.\n     * @param {Object} data - Where the data shall be taken from\n     * @param {(String|Array)} square - The square the data shall be generated for.\n     * For example, if you wanted to know how often a specific piece was on a specific tile,\n     * you would pass the identifier of the tile to the function, e.g. \"a2\" or [7,1].\n     * @param {Function} fun - The evaluation function that generates the heatmap out of the\n     * data.\n     * See ./src/exampleHeatmapConfig for examples of such a function.\n     * @param {} optData - Optional data you may need in your eval function\n     * @returns {Object} Array with 3 entries:\n     * <ol>\n     * <li>map: 8x8 Array containing the heat map values for each tile</li>\n     * <li>min: The minimum value in the heatmap.</li>\n     * <li>max: The maximum value in the heatmap.</li>\n     * </ol>\n     */\n\n\n    static generateHeatmap(data, square, fun, optData) {\n      let sqrCoords;\n      let sqrAlg; // square input type 'a2'\n\n      if (typeof square === 'string') {\n        sqrCoords = _GameProcessor.default.algebraicToCoords(square);\n        sqrAlg = square; // input type [6,0]\n      } else {\n        sqrCoords = square;\n        sqrAlg = _GameProcessor.default.coordsToAlgebraic(square);\n      }\n\n      const startingPiece = Chessalyzer.getStartingPiece(sqrCoords);\n      const sqrData = {\n        alg: sqrAlg,\n        coords: sqrCoords,\n        piece: startingPiece\n      };\n      const map = [];\n      let max = 0;\n      let min = 1000000;\n\n      for (let i = 0; i < 8; i += 1) {\n        const dataRow = new Array(8);\n\n        for (let j = 0; j < 8; j += 1) {\n          const loopSqrCoords = [i, j];\n\n          const loopSqrAlg = _GameProcessor.default.coordsToAlgebraic(loopSqrCoords);\n\n          const loopPiece = Chessalyzer.getStartingPiece(loopSqrCoords);\n          const loopSqrData = {\n            alg: loopSqrAlg,\n            coords: loopSqrCoords,\n            piece: loopPiece\n          };\n          dataRow[j] = fun(data, sqrData, loopSqrData, optData);\n          if (dataRow[j] > max) max = dataRow[j];\n          if (dataRow[j] < min) min = dataRow[j];\n        }\n\n        map.push(dataRow);\n      }\n\n      return {\n        map,\n        min,\n        max\n      };\n    }\n    /**\n     * Generates a comparison heatmap out of the tracked data. There needs to data in both\n     * banks you pass as bank1 and bank2 params. The heatmap for both banks is calculated\n     * and then the relative differences between both banks are calculated. For example,\n     * if the heatmap value for \"a1\" of bank1 is 10 and the value of bank2 is 5, the returned\n     * value for \"a1\" would be 100% ([[10/5] -1] *100).\n     * @param {Object} data1 - Dataset 1\n     * @param {Object} data2 - Dataset 2\n     * @param {(String|Array)} square - The square the data shall be generated for. Notation\n     * can be 'a1' or [7,0].\n     * @param {Function} fun - The evaluation function that generates the heatmap out of the\n     * saved data. See {@link generateHeatmap} for a more detailed description.\n     * @param {} optData - Optional data you may need in your eval function\n     * @returns {Object} Object with 3 entries:\n     * <ol>\n     * <li>map: 8x8 Array containing the heat map values for each tile</li>\n     * <li>min: The minimum value in the heatmap.</li>\n     * <li>max: The maximum value in the heatmap.</li>\n     * </ol>\n     */\n\n\n    static generateComparisonHeatmap(data1, data2, square, fun, optData) {\n      const map = [];\n      let max = 0;\n      let min = 100000; // comparison heatmap\n\n      const map0 = Chessalyzer.generateHeatmap(data1, square, fun, optData);\n      const map1 = Chessalyzer.generateHeatmap(data2, square, fun, optData);\n\n      for (let i = 0; i < 8; i += 1) {\n        const dataRow = new Array(8);\n\n        for (let j = 0; j < 8; j += 1) {\n          const a = map0[0][i][j];\n          const b = map1[0][i][j];\n          if (a === 0 || b === 0) dataRow[j] = 0;else dataRow[j] = (a >= b ? a / b - 1 : -b / a + 1) * 100;\n          if (dataRow[j] > max) max = dataRow[j];\n          if (dataRow[j] < min) min = dataRow[j];\n        }\n\n        map.push(dataRow);\n      }\n\n      return {\n        map,\n        min,\n        max\n      };\n    }\n    /**\n     * Prints a heatmap to the terminal\n     * @param {Array} map - The heatmap data. An (8x8) Array containing values.\n     * @param {Number} min - The minimum value in map.\n     * @param {Number} max - The maximum value in map.\n     */\n\n\n    static printHeatmap(map, min, max) {\n      const color = [255, 128, 0];\n      const bgColor = [255, 255, 255];\n\n      for (let i = 0; i < map.length; i += 1) {\n        for (let cnt = 0; cnt < 2; cnt += 1) {\n          for (let j = 0; j < map[i].length; j += 1) {\n            const alpha = Math.sqrt(map[i][j] / max).toFixed(2); // const value = map[i][j].toFixed(2);\n\n            const colorOut = [Math.round(color[0] * alpha + (1 - alpha) * bgColor[0]), Math.round(color[1] * alpha + (1 - alpha) * bgColor[1]), Math.round(color[2] * alpha + (1 - alpha) * bgColor[2])];\n            process.stdout.write(chalk.bgRgb(colorOut[0], colorOut[1], colorOut[2])('    '));\n          }\n\n          process.stdout.write('\\n');\n        }\n      }\n    }\n\n    static getStartingPiece(sqr) {\n      let color = '';\n      let name = '';\n\n      if (sqr[0] === 0) {\n        color = 'b';\n        name = pieceTemplate[sqr[1]];\n      } else if (sqr[0] === 1) {\n        color = 'b';\n        name = pawnTemplate[sqr[1]];\n      } else if (sqr[0] === 6) {\n        color = 'w';\n        name = pawnTemplate[sqr[1]];\n      } else if (sqr[0] === 7) {\n        color = 'w';\n        name = pieceTemplate[sqr[1]];\n      }\n\n      return {\n        color,\n        name\n      };\n    }\n\n  }\n\n  Chessalyzer.Tracker = {\n    Game: _GameTrackerBase.default,\n    Piece: _PieceTrackerBase.default,\n    Tile: _TileTrackerBase.default,\n    Base: _BaseTracker.default\n  };\n  var _default = Chessalyzer;\n  _exports.default = _default;\n  module.exports = exports.default;\n});\n\n//# sourceURL=webpack://chessalyzer/./src/core/Chessalyzer.js?");

/***/ }),

/***/ "./src/core/GameProcessor.js":
/*!***********************************!*\
  !*** ./src/core/GameProcessor.js ***!
  \***********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, module, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 13:89-93 */
/*! CommonJS bailout: module.exports is used directly at 642:2-16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./ChessBoard */ \"./src/core/ChessBoard.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports, _ChessBoard) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _ChessBoard = _interopRequireDefault(_ChessBoard);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  /* eslint-disable no-inner-declarations */\n  const {\n    createReadStream\n  } = __webpack_require__(/*! fs */ \"fs\");\n\n  const {\n    createInterface\n  } = __webpack_require__(/*! readline */ \"readline\");\n\n  const EventEmitter = __webpack_require__(/*! events */ \"events\");\n\n  const files = 'abcdefgh';\n\n  const cluster = __webpack_require__(/*! cluster */ \"cluster\");\n\n  class MoveData {\n    constructor() {\n      this.san = '';\n      this.player = '';\n      this.piece = '';\n      this.castles = '';\n      this.takes = {};\n      this.promotesTo = '';\n      this.from = [-1, -1];\n      this.to = [-1, -1];\n    }\n\n  }\n  /**\n   * Class that processes games.\n   */\n\n\n  class GameProcessor extends EventEmitter {\n    constructor() {\n      super();\n      this.board = new _ChessBoard.default();\n      this.currentMove = new MoveData();\n      this.activePlayer = 0;\n      this.cntMoves = 0;\n      this.cntGames = 0;\n      this.gameAnalyzers = [];\n      this.moveAnalyzers = [];\n    }\n\n    static checkConfig(config) {\n      const cfg = {};\n      cfg.hasFilter = Object.prototype.hasOwnProperty.call(config, 'filter');\n      cfg.filter = cfg.hasFilter ? config.filter : () => true;\n      cfg.cntGames = Object.prototype.hasOwnProperty.call(config, 'cntGames') ? config.cntGames : Infinity;\n      return cfg;\n    }\n\n    attachAnalyzers(analyzers) {\n      analyzers.forEach(a => {\n        if (a.type === 'move') {\n          this.moveAnalyzers.push(a);\n        } else if (a.type === 'game') {\n          this.gameAnalyzers.push(a);\n        }\n      });\n    }\n    /**\n     * Main analysis function for multithreading. Replays every game in the file and tracks statistics\n     * @param {string} path Path to the PGN file.\n     * @param {Function} config.filter - Filter function for selecting games\n     * @param {Number} config.cntGames - Max amount of games to process\n     * @param {Array<object>} analyzer An array of tracker objects. The data in the\n     *  analyzers is processed by reference.\n     * @param {number} batchSize Amount of games every worker shall process.\n     * @param {number} nThreads Amount of parallel threads that are started, when\n     * batchSize * nThreads games have been read in.\n     * @returns {Promise}\n     */\n\n\n    static async processPGNMultiCore(path, config, analyzer, batchSize, nThreads) {\n      try {\n        let cntGameAnalyzer = 0;\n        const gameAnalyzerStore = [];\n        const moveAnalyzerStore = [];\n        const analyzerNames = [];\n        const analyzerConfigs = [];\n        let cntGames = 0;\n        let cntMoves = 0;\n        let readerFinished = false;\n        let customPath = '';\n        const status = new EventEmitter(); // eslint-disable-next-line no-undef\n\n        cluster.setupMaster({\n          exec: `${__dirname}/worker.min.js`\n        }); // split game type trackers and move type trackers\n\n        analyzer.forEach(a => {\n          if (a.type === 'game') {\n            cntGameAnalyzer += 1;\n            gameAnalyzerStore.push(a);\n          } else if (a.type === 'move') {\n            moveAnalyzerStore.push(a);\n          }\n\n          analyzerNames.push(a.constructor.name);\n          analyzerConfigs.push(a.cfg);\n\n          if (Object.prototype.hasOwnProperty.call(a, 'path')) {\n            customPath = a.path;\n          }\n        }); // creates a new worker, that will process an array of games\n\n        function forkWorker(games) {\n          const w = cluster.fork(); // send data to worker\n\n          w.send({\n            games,\n            customPath,\n            analyzerNames,\n            analyzerConfigs\n          }); // on worker finish\n\n          w.on('message', msg => {\n            // add tracker data from this worker\n            for (let i = 0; i < gameAnalyzerStore.length; i += 1) {\n              gameAnalyzerStore[i].add(msg.gameAnalyzers[i]);\n            }\n\n            for (let i = 0; i < moveAnalyzerStore.length; i += 1) {\n              moveAnalyzerStore[i].add(msg.moveAnalyzers[i]);\n            }\n\n            cntMoves += msg.cntMoves;\n            w.kill(); // if this worker was the last one, emit 'finished' event\n\n            if (Object.keys(cluster.workers).length === 0 && readerFinished) {\n              status.emit('finished');\n            }\n          });\n        }\n\n        const cfg = GameProcessor.checkConfig(config);\n        let games = [];\n        let game = {}; // init line-by-line reader\n\n        const lr = createInterface({\n          input: createReadStream(path),\n          crlfDelay: Infinity\n        }); // on new line\n\n        lr.on('line', line => {\n          // data tag\n          if (line.startsWith('[') && (cfg.hasFilter || cntGameAnalyzer > 0)) {\n            const key = line.match(/\\[(.*?)\\s/)[1];\n            const value = line.match(/\"(.*?)\"/)[1];\n            game[key] = value; // moves\n          } else if (line.startsWith('1')) {\n            game.moves = line.replace(/\\{(.*?)\\}\\s/g, '').replace(/\\d+\\.+\\s/g, '').replace(' *', '').split(' ');\n\n            if (cfg.filter(game) || !cfg.hasFilter) {\n              cntGames += 1;\n              games.push(game); // if enough games have been read in, start worker threads and let them analyze\n\n              if (cntGames % (batchSize * nThreads) === 0) {\n                for (let i = 0; i < nThreads; i += 1) {\n                  forkWorker(games.slice(i * batchSize, i * batchSize + batchSize));\n                }\n\n                games = [];\n              }\n            }\n\n            game = {};\n          }\n\n          if (cntGames >= cfg.cntGames) {\n            lr.close();\n            lr.removeAllListeners();\n          }\n        });\n        await EventEmitter.once(lr, 'close'); // if on end there are still unprocessed games, start a last worker batch\n\n        if (games.length > 0) {\n          if (games.length > batchSize) {\n            const nEndForks = Math.ceil(games.length / batchSize);\n\n            for (let i = 0; i < nEndForks; i += 1) {\n              forkWorker(games.slice(i * batchSize, i * batchSize + batchSize));\n            }\n          } else {\n            forkWorker(games);\n          }\n        }\n\n        readerFinished = true;\n        await EventEmitter.once(status, 'finished');\n        analyzer.forEach(a => {\n          if (a.finish) {\n            a.finish();\n          }\n        });\n        return {\n          cntGames,\n          cntMoves\n        };\n      } catch (err) {\n        console.log(err);\n        return {\n          cntGames: -1,\n          cntMoves: -1\n        };\n      }\n    }\n\n    async processPGN(path, config, analyzers, refreshRate) {\n      try {\n        const cfg = GameProcessor.checkConfig(config);\n        this.attachAnalyzers(analyzers);\n        const cntGameAnalyers = this.gameAnalyzers.length;\n        const lr = createInterface({\n          input: createReadStream(path),\n          crlfDelay: Infinity\n        });\n        let game = {};\n        lr.on('line', line => {\n          // data tag\n          if (line.startsWith('[') && (cfg.hasFilter || cntGameAnalyers > 0)) {\n            const key = line.match(/\\[(.*?)\\s/)[1];\n            const value = line.match(/\"(.*?)\"/)[1];\n            game[key] = value; // moves\n          } else if (line.startsWith('1')) {\n            game.moves = line.replace(/\\{(.*?)\\}\\s/g, '').replace(/\\d+\\.+\\s/g, '').replace(' *', '').split(' ');\n\n            if (cfg.filter(game) || !cfg.hasFilter) {\n              this.processGame(game);\n            } // emit event\n\n\n            if (this.cntGames % refreshRate === 0) {\n              this.emit('status', this.cntGames);\n            }\n\n            game = {};\n          }\n\n          if (this.cntGames >= cfg.cntGames) {\n            lr.close();\n            lr.removeAllListeners();\n          }\n        });\n        await EventEmitter.once(lr, 'close');\n        console.log('Read entire file.'); // call finish routine for each analyzer\n\n        this.gameAnalyzers.forEach(a => {\n          if (a.finish) {\n            a.finish();\n          }\n        });\n        this.moveAnalyzers.forEach(a => {\n          if (a.finish) {\n            a.finish();\n          }\n        });\n        return {\n          cntGames: this.cntGames,\n          cntMoves: this.cntMoves\n        };\n      } catch (err) {\n        console.error(err);\n        return {\n          cntGames: -1,\n          cntMoves: -1\n        };\n      }\n    }\n\n    processGame(game) {\n      const {\n        moves\n      } = game;\n\n      for (let i = 0; i < moves.length; i += 1) {\n        this.activePlayer = i % 2; // fetch move data into this.currentMove\n\n        this.parseMove(moves[i]); // move based analyzers\n\n        this.moveAnalyzers.forEach(a => {\n          a.analyze(this.currentMove);\n        });\n        this.board.move(this.currentMove);\n      }\n\n      this.cntMoves += moves.length - 1; // don't count result (e.g. 1-0)\n\n      this.cntGames += 1;\n      this.board.reset(); // game based analyzers\n\n      this.gameAnalyzers.forEach(a => {\n        a.analyze(game);\n      });\n    }\n\n    reset() {\n      this.board.reset();\n      this.activePlayer = 0;\n    }\n    /**\n     * Parses a move in string format to board coordinates. Wrapper function for\n     * the different move algorithms.\n     * @param {string} rawMove The move to be parsed, e.g. 'Ne5+'.\n     */\n\n\n    parseMove(rawMove) {\n      const token = rawMove.substring(0, 1);\n      const move = GameProcessor.preProcess(rawMove);\n      this.currentMove = new MoveData();\n      this.currentMove.san = rawMove;\n      this.currentMove.player = this.activePlayer === 0 ? 'w' : 'b'; // game end on '1-0', '0-1' or '1/2-1/2' (check for digit as first char)\n\n      if (token.match(/\\d/) === null) {\n        if (token.toLowerCase() === token) {\n          this.pawnMove(move);\n        } else if (token !== 'O') {\n          this.pieceMove(move);\n        } else {\n          this.currentMove.castles = move;\n        }\n      }\n    }\n    /**\n     * Returns the board coordinates for the move if it is a pawn move.\n     * @param {string} moveSan The move to be parsed, e.g. 'e5'.\n     */\n\n\n    pawnMove(moveSan) {\n      const direction = -2 * (this.activePlayer % 2) + 1;\n      const from = [];\n      const to = [];\n      let move = moveSan;\n      let offset = 0; // takes\n\n      if (move.includes('x')) {\n        move = move.replace('x', '');\n        to[0] = 8 - parseInt(move.substring(2, 3), 10);\n        to[1] = files.indexOf(move.substring(1, 2));\n        from[0] = to[0] + direction;\n        from[1] = files.indexOf(move.substring(0, 1)); // en passant\n\n        if (this.board.tiles[to[0]][to[1]] === null) {\n          offset = this.currentMove.player === 'w' ? 1 : -1;\n        }\n\n        this.currentMove.takes.piece = this.board.tiles[to[0] + offset][to[1]].name;\n        this.currentMove.takes.pos = [to[0] + offset, to[1]]; // moves\n      } else {\n        const tarRow = 8 - parseInt(move.substring(1, 2), 10);\n        const tarCol = files.indexOf(move.substring(0, 1));\n        from[1] = tarCol;\n        to[0] = tarRow;\n        to[1] = tarCol;\n\n        for (let i = tarRow + direction; i < 8 && i >= 0; i += direction) {\n          if (this.board.tiles[i][tarCol] !== null) {\n            if (this.board.tiles[i][tarCol].name.includes('P')) {\n              from[0] = i;\n              break;\n            }\n          }\n        }\n      }\n\n      this.currentMove.to = to;\n      this.currentMove.from = from;\n      this.currentMove.piece = this.board.tiles[from[0]][from[1]].name; // promotes\n\n      if (move.includes('=')) {\n        this.currentMove.promotesTo = move.substring(move.length - 1, move.length);\n      }\n    }\n    /**\n     * Returns the board coordinates for a piece (!= pawn) move.\n     * @param {string} moveSan The move to be parsed, e.g. 'Be3'.\n     */\n\n\n    pieceMove(moveSan) {\n      let move = moveSan;\n      let takes = false;\n      let coords = {\n        from: [],\n        to: []\n      };\n      const token = move.substring(0, 1); // remove token\n\n      move = move.substring(1, move.length); // takes\n\n      if (move.includes('x')) {\n        takes = true;\n        move = move.replace('x', '');\n      } // e.g. Re3f5\n\n\n      if (move.length === 4) {\n        coords.from[0] = 8 - parseInt(move.substring(1, 2), 10);\n        coords.from[1] = files.indexOf(move.substring(0, 1));\n        coords.to[0] = 8 - parseInt(move.substring(3, 4), 10);\n        coords.to[1] = files.indexOf(move.substring(2, 3)); // e.g. Ref3\n      } else if (move.length === 3) {\n        const tarRow = 8 - parseInt(move.substring(2, 3), 10);\n        const tarCol = files.indexOf(move.substring(1, 2));\n        let mustBeInRow = -1;\n        let mustBeInCol = -1; // file is specified\n\n        if (files.indexOf(move.substring(0, 1)) >= 0) {\n          mustBeInCol = files.indexOf(move.substring(0, 1)); // rank is specified\n        } else {\n          mustBeInRow = 8 - parseInt(move.substring(0, 1), 10);\n        }\n\n        coords = this.findPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token); // e.g. Rf3\n      } else {\n        const tarRow = 8 - parseInt(move.substring(1, 2), 10);\n        const tarCol = files.indexOf(move.substring(0, 1));\n        coords = this.findPiece(tarRow, tarCol, -1, -1, token);\n      } // set move data\n\n\n      this.currentMove.from = coords.from;\n      this.currentMove.to = coords.to;\n      this.currentMove.piece = this.board.tiles[coords.from[0]][coords.from[1]].name;\n\n      if (takes) {\n        this.currentMove.takes.piece = this.board.tiles[this.currentMove.to[0]][this.currentMove.to[1]].name;\n        this.currentMove.takes.pos = this.currentMove.to;\n      }\n    }\n    /**\n     * Search algorithm to find a piece.\n     * @param {number} tarRow Target row for piece move.\n     * @param {number} tarCol Target column for piece move.\n     * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n     * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n     * @param {string} token Moving piece must be of this type, e.g 'R'.\n     * @returns {Object}\n     */\n\n\n    findPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n      const color = this.currentMove.player;\n      const from = [];\n      const to = [];\n      const moveCfg = {\n        Q: {\n          line: true,\n          diag: true\n        },\n        R: {\n          line: true,\n          diag: false\n        },\n        B: {\n          line: false,\n          diag: true\n        },\n        N: {\n          line: false,\n          diag: false\n        }\n      };\n      from[0] = -1;\n      from[1] = -1;\n      to[0] = tarRow;\n      to[1] = tarCol; // get array of positions of pieces of type <token>\n\n      let validPieces = Object.values(this.board.pieces.posMap[color][token]); // filter pieces that can reach target square\n\n      if (validPieces.length > 1) {\n        validPieces = validPieces.filter(val => {\n          const mustBeInFulfilled = (mustBeInRow === -1 || val[0] === mustBeInRow) && (mustBeInCol === -1 || val[1] === mustBeInCol);\n          return (moveCfg[token].line && (val[0] === tarRow || val[1] === tarCol) || moveCfg[token].diag && Math.abs(val[0] - tarRow) === Math.abs(val[1] - tarCol) || token === 'N' && (Math.abs(val[0] - tarRow) === 2 && Math.abs(val[1] - tarCol) === 1 || Math.abs(val[0] - tarRow) === 1 && Math.abs(val[1] - tarCol) === 2)) && mustBeInFulfilled;\n        });\n      }\n\n      if (validPieces.length === 1) {\n        return {\n          from: validPieces[0],\n          to\n        };\n      }\n\n      if (validPieces.length > 1) {\n        for (let idx = 0; idx < validPieces.length - 1; idx += 1) {\n          const piece = validPieces[idx];\n          let obstructed = false;\n\n          if (token !== 'N') {\n            const diff = [tarRow - piece[0], tarCol - piece[1]];\n            const steps = Math.max.apply(null, diff.map(Math.abs));\n            const dir = [Math.sign(diff[0]), Math.sign(diff[1])];\n\n            for (let i = 1; i < steps && !obstructed; i += 1) {\n              if (this.board.tiles[piece[0] + i * dir[0]][piece[1] + i * dir[1]]) {\n                obstructed = true;\n              }\n            }\n          }\n\n          if (!obstructed && !this.checkCheck(piece, to)) {\n            return {\n              from: piece,\n              to\n            };\n          }\n        }\n\n        return {\n          from: validPieces[validPieces.length - 1],\n          to\n        };\n      }\n\n      console.log(`Error: no piece for move ${token} to (${tarRow},${tarCol}) found!`);\n      console.log(this.cntGames);\n      console.log(this.currentMove);\n      this.board.printPosition();\n      return {\n        from,\n        to\n      };\n    }\n    /**\n     * Checks if the input move would be resulting with the king being in check.\n     * @param {Number[]} from Coordinates of the source tile of the move that shall be checked.\n     *  @param {Number[]} to Coordinates of the target tile of the move that shall be checked.\n     * @returns {boolean} After the move, the king will be in check true/false.\n     */\n\n\n    checkCheck(from, to) {\n      const color = this.currentMove.player;\n      const opColor = this.currentMove.player === 'w' ? 'b' : 'w';\n      const king = this.board.pieces.posMap[color].K.Ke;\n      let isInCheck = false; // if king move, no check is possible, exit function\n\n      if (king[0] === from[0] && king[1] === from[1]) return false; // check if moving piece is on same line/diag as king, else exit\n\n      const diff = [];\n      diff[0] = from[0] - king[0];\n      diff[1] = from[1] - king[1];\n      const checkFor = [];\n\n      if (diff[0] === 0 || diff[1] === 0) {\n        checkFor[0] = 'Q';\n        checkFor[1] = 'R';\n      } else if (Math.abs(diff[0]) === Math.abs(diff[1])) {\n        checkFor[0] = 'Q';\n        checkFor[1] = 'B';\n      } else {\n        return false;\n      }\n\n      if (diff[0] !== 0) diff[0] = Math.sign(diff[0]);\n      if (diff[1] !== 0) diff[1] = Math.sign(diff[1]);\n      const srcTilePiece = this.board.tiles[from[0]][from[1]];\n      const tarTilePiece = this.board.tiles[to[0]][to[1]]; // premove and check if check\n\n      this.board.tiles[from[0]][from[1]] = null;\n      this.board.tiles[to[0]][to[1]] = srcTilePiece; // check for check\n\n      let obstructed = false;\n\n      for (let j = 1; j < 8 && !isInCheck && !obstructed; j += 1) {\n        const row = king[0] + j * diff[0];\n        const col = king[1] + j * diff[1];\n\n        if (row >= 0 && row < 8 && col >= 0 && col < 8 && this.board.tiles[row][col] !== null) {\n          const piece = this.board.tiles[row][col];\n\n          if ((piece.name.includes(checkFor[0]) || piece.name.includes(checkFor[1])) && piece.color === opColor) {\n            isInCheck = true;\n          } else {\n            obstructed = true;\n          }\n        }\n      }\n\n      this.board.tiles[from[0]][from[1]] = srcTilePiece;\n      this.board.tiles[to[0]][to[1]] = tarTilePiece;\n      return isInCheck;\n    }\n\n    static algebraicToCoords(square) {\n      const coords = [];\n      const temp = square.split('');\n      coords.push(8 - temp[1]);\n      coords.push(files.indexOf(temp[0]));\n      return coords;\n    }\n\n    static coordsToAlgebraic(coords) {\n      let name = files[coords[1]];\n      name += 8 - coords[0];\n      return name;\n    }\n    /**\n     * Removes special characters like '#', '+', '?' and '!'\n     * @param {string} move The move to be cleaned up\n     * @returns {string} The input string with removed special characters\n     */\n\n\n    static preProcess(move) {\n      return move.replace(/#|\\+|\\?|!/g, '');\n    }\n\n  }\n\n  var _default = GameProcessor;\n  _exports.default = _default;\n  module.exports = exports.default;\n});\n\n//# sourceURL=webpack://chessalyzer/./src/core/GameProcessor.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, module, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 13:89-93 */
/*! CommonJS bailout: module.exports is used directly at 27:2-16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./core/Chessalyzer */ \"./src/core/Chessalyzer.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports, _Chessalyzer) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _Chessalyzer = _interopRequireDefault(_Chessalyzer);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  /* eslint-disable */\n  var _default = _Chessalyzer.default;\n  _exports.default = _default;\n  module.exports = exports.default;\n});\n\n//# sourceURL=webpack://chessalyzer/./src/index.js?");

/***/ }),

/***/ "./src/tracker/BaseTracker.js":
/*!************************************!*\
  !*** ./src/tracker/BaseTracker.js ***!
  \************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, module, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 13:89-93 */
/*! CommonJS bailout: module.exports is used directly at 53:2-16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n\n  const {\n    performance\n  } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\n\n  class BaseTracker {\n    constructor(type) {\n      this.type = type;\n      this.cfg = {\n        profilingActive: false\n      };\n      this.time = 0;\n      this.t0 = 0;\n\n      if (this.track === undefined) {\n        throw new Error('Your analyzer must implement a track() method!');\n      }\n\n      if (this.type === undefined) {\n        throw new Error('Your analyzer must specify a type!');\n      }\n    }\n\n    analyze(data) {\n      if (this.cfg.profilingActive) this.t0 = performance.now();\n      this.track(data);\n      if (this.cfg.profilingActive) this.time += performance.now() - this.t0;\n    }\n\n  }\n\n  var _default = BaseTracker;\n  _exports.default = _default;\n  module.exports = exports.default;\n});\n\n//# sourceURL=webpack://chessalyzer/./src/tracker/BaseTracker.js?");

/***/ }),

/***/ "./src/tracker/GameTrackerBase.js":
/*!****************************************!*\
  !*** ./src/tracker/GameTrackerBase.js ***!
  \****************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, module, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 13:89-93 */
/*! CommonJS bailout: module.exports is used directly at 86:2-16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./BaseTracker */ \"./src/tracker/BaseTracker.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports, _BaseTracker) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _BaseTracker = _interopRequireDefault(_BaseTracker);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  class GameTrackerBase extends _BaseTracker.default {\n    constructor() {\n      super('game');\n      this.wins = [0, 0, 0];\n      this.cntGames = 0;\n      this.ECO = {};\n    }\n\n    add(tracker) {\n      this.wins[0] += tracker.wins[0];\n      this.wins[1] += tracker.wins[1];\n      this.wins[2] += tracker.wins[2];\n      this.cntGames += tracker.cntGames;\n      this.time += tracker.time;\n      Object.keys(tracker.ECO).forEach(key => {\n        if (Object.prototype.hasOwnProperty.call(this.ECO, key)) {\n          this.ECO[key] += tracker.ECO[key];\n        } else {\n          this.ECO[key] = tracker.ECO[key];\n        }\n      });\n    }\n\n    track(game) {\n      this.cntGames += 1;\n\n      switch (game.Result) {\n        case '1-0':\n          this.wins[0] += 1;\n          break;\n\n        case '1/2-1/2':\n          this.wins[1] += 1;\n          break;\n\n        case '0-1':\n          this.wins[2] += 1;\n          break;\n\n        default:\n          break;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(this.ECO, game.ECO)) {\n        this.ECO[game.ECO] += 1;\n      } else {\n        this.ECO[game.ECO] = 1;\n      }\n    }\n\n    finish() {\n      // sort keys\n      this.ECO = Object.keys(this.ECO).sort().reduce((accumulator, currentValue) => {\n        accumulator[currentValue] = this.ECO[currentValue];\n        return accumulator;\n      }, {});\n    }\n\n  }\n\n  var _default = GameTrackerBase;\n  _exports.default = _default;\n  module.exports = exports.default;\n});\n\n//# sourceURL=webpack://chessalyzer/./src/tracker/GameTrackerBase.js?");

/***/ }),

/***/ "./src/tracker/PieceTrackerBase.js":
/*!*****************************************!*\
  !*** ./src/tracker/PieceTrackerBase.js ***!
  \*****************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, module, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 13:89-93 */
/*! CommonJS bailout: module.exports is used directly at 104:2-16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./BaseTracker */ \"./src/tracker/BaseTracker.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports, _BaseTracker) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _BaseTracker = _interopRequireDefault(_BaseTracker);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  const pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\n  const pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n  class PieceTrackerBase extends _BaseTracker.default {\n    constructor() {\n      super('move');\n      this.b = {};\n      this.w = {}; // first layer\n\n      pawnTemplate.forEach(val => {\n        this.w[val] = {};\n        this.b[val] = {};\n      });\n      pieceTemplate.forEach(val => {\n        this.w[val] = {};\n        this.b[val] = {};\n      }); // second layer\n\n      Object.keys(this.w).forEach(key => {\n        pawnTemplate.forEach(val => {\n          this.w[key][val] = 0;\n          this.b[key][val] = 0;\n        });\n        pieceTemplate.forEach(val => {\n          this.w[key][val] = 0;\n          this.b[key][val] = 0;\n        });\n      });\n    }\n\n    add(tracker) {\n      this.time += tracker.time;\n      pawnTemplate.forEach(pawn => {\n        pieceTemplate.forEach(piece => {\n          this.w[pawn][piece] += tracker.w[pawn][piece];\n          this.b[pawn][piece] += tracker.b[pawn][piece];\n        });\n        pawnTemplate.forEach(pawn2 => {\n          this.w[pawn][pawn2] += tracker.w[pawn][pawn2];\n          this.b[pawn][pawn2] += tracker.b[pawn][pawn2];\n        });\n      });\n      pieceTemplate.forEach(piece => {\n        pieceTemplate.forEach(piece2 => {\n          this.w[piece][piece2] += tracker.w[piece][piece2];\n          this.b[piece][piece2] += tracker.b[piece][piece2];\n        });\n        pawnTemplate.forEach(pawn => {\n          this.w[piece][pawn] += tracker.w[piece][pawn];\n          this.b[piece][pawn] += tracker.b[piece][pawn];\n        });\n      });\n    }\n\n    track(moveData) {\n      const {\n        player\n      } = moveData;\n      const {\n        piece\n      } = moveData;\n      const {\n        takes\n      } = moveData;\n\n      if (takes.piece !== undefined) {\n        if (piece.length > 1 && takes.piece.length > 1 && !piece.match(/\\d/g) && !takes.piece.match(/\\d/g)) {\n          this.processTakes(player, piece, takes.piece);\n        }\n      }\n    }\n\n    processTakes(player, takingPiece, takenPiece) {\n      this[player][takingPiece][takenPiece] += 1;\n    }\n\n  }\n\n  var _default = PieceTrackerBase;\n  _exports.default = _default;\n  module.exports = exports.default;\n});\n\n//# sourceURL=webpack://chessalyzer/./src/tracker/PieceTrackerBase.js?");

/***/ }),

/***/ "./src/tracker/TileTrackerBase.js":
/*!****************************************!*\
  !*** ./src/tracker/TileTrackerBase.js ***!
  \****************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, module, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 13:89-93 */
/*! CommonJS bailout: module.exports is used directly at 256:2-16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./BaseTracker */ \"./src/tracker/BaseTracker.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports, _BaseTracker) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _BaseTracker = _interopRequireDefault(_BaseTracker);\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  const pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\n  const pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n  class TileStats {\n    constructor() {\n      this.movedTo = 0;\n      this.wasOn = 0;\n      this.killedOn = 0;\n      this.wasKilledOn = 0;\n    }\n\n  }\n\n  class Piece {\n    constructor(piece, color) {\n      this.piece = piece;\n      this.color = color;\n      this.lastMovedOn = 0;\n    }\n\n  }\n\n  class TileTrackerBase extends _BaseTracker.default {\n    constructor() {\n      super('move');\n      this.cntMovesGame = 0;\n      this.cntMovesTotal = 0;\n      this.tiles = new Array(8);\n\n      for (let row = 0; row < 8; row += 1) {\n        const currRow = new Array(8);\n\n        for (let col = 0; col < 8; col += 1) {\n          currRow[col] = {\n            b: {},\n            w: {}\n          };\n          currRow[col].b = new TileStats();\n          currRow[col].w = new TileStats();\n          pawnTemplate.forEach(val => {\n            currRow[col].b[val] = new TileStats();\n            currRow[col].w[val] = new TileStats();\n          });\n          pieceTemplate.forEach(val => {\n            currRow[col].b[val] = new TileStats();\n            currRow[col].w[val] = new TileStats();\n          });\n        }\n\n        this.tiles[row] = currRow;\n      }\n\n      for (let row = 0; row < 8; row += 1) {\n        for (let col = 0; col < 8; col += 1) {\n          this.resetCurrentPiece(row, col);\n        }\n      }\n    }\n\n    add(tracker) {\n      this.time += tracker.time;\n      this.cntMovesGame += tracker.cntMovesGame;\n      this.cntMovesTotal += tracker.cntMovesTotal;\n\n      for (let row = 0; row < 8; row += 1) {\n        for (let col = 0; col < 8; col += 1) {\n          this.tiles[row][col].b.movedTo += tracker.tiles[row][col].b.movedTo;\n          this.tiles[row][col].w.movedTo += tracker.tiles[row][col].w.movedTo;\n          this.tiles[row][col].b.wasOn += tracker.tiles[row][col].b.wasOn;\n          this.tiles[row][col].w.wasOn += tracker.tiles[row][col].w.wasOn;\n          this.tiles[row][col].b.killedOn += tracker.tiles[row][col].b.killedOn;\n          this.tiles[row][col].w.killedOn += tracker.tiles[row][col].w.killedOn;\n          this.tiles[row][col].b.wasKilledOn += tracker.tiles[row][col].b.wasKilledOn;\n          this.tiles[row][col].w.wasKilledOn += tracker.tiles[row][col].w.wasKilledOn;\n          pawnTemplate.forEach(piece => {\n            this.tiles[row][col].b[piece].movedTo += tracker.tiles[row][col].b[piece].movedTo;\n            this.tiles[row][col].w[piece].movedTo += tracker.tiles[row][col].w[piece].movedTo;\n            this.tiles[row][col].b[piece].wasOn += tracker.tiles[row][col].b[piece].wasOn;\n            this.tiles[row][col].w[piece].wasOn += tracker.tiles[row][col].w[piece].wasOn;\n            this.tiles[row][col].b[piece].killedOn += tracker.tiles[row][col].b[piece].killedOn;\n            this.tiles[row][col].w[piece].killedOn += tracker.tiles[row][col].w[piece].killedOn;\n            this.tiles[row][col].b[piece].wasKilledOn += tracker.tiles[row][col].b[piece].wasKilledOn;\n            this.tiles[row][col].w[piece].wasKilledOn += tracker.tiles[row][col].w[piece].wasKilledOn;\n          });\n          pieceTemplate.forEach(piece => {\n            this.tiles[row][col].b[piece].movedTo += tracker.tiles[row][col].b[piece].movedTo;\n            this.tiles[row][col].w[piece].movedTo += tracker.tiles[row][col].w[piece].movedTo;\n            this.tiles[row][col].b[piece].wasOn += tracker.tiles[row][col].b[piece].wasOn;\n            this.tiles[row][col].w[piece].wasOn += tracker.tiles[row][col].w[piece].wasOn;\n            this.tiles[row][col].b[piece].killedOn += tracker.tiles[row][col].b[piece].killedOn;\n            this.tiles[row][col].w[piece].killedOn += tracker.tiles[row][col].w[piece].killedOn;\n            this.tiles[row][col].b[piece].wasKilledOn += tracker.tiles[row][col].b[piece].wasKilledOn;\n            this.tiles[row][col].w[piece].wasKilledOn += tracker.tiles[row][col].w[piece].wasKilledOn;\n          });\n        }\n      }\n    }\n\n    resetCurrentPiece(row, col) {\n      let color;\n      let piece;\n      let hasPiece = false;\n\n      if (row === 0) {\n        color = 'b';\n        piece = pieceTemplate[col];\n        hasPiece = true;\n      } else if (row === 1) {\n        color = 'b';\n        piece = pawnTemplate[col];\n        hasPiece = true;\n      } else if (row === 6) {\n        color = 'w';\n        piece = pawnTemplate[col];\n        hasPiece = true;\n      } else if (row === 7) {\n        color = 'w';\n        piece = pieceTemplate[col];\n        hasPiece = true;\n      }\n\n      if (hasPiece) {\n        this.tiles[row][col].currentPiece = new Piece(piece, color);\n      } else {\n        this.tiles[row][col].currentPiece = null;\n      }\n    }\n\n    track(moveData) {\n      const {\n        to\n      } = moveData;\n      const {\n        from\n      } = moveData;\n      const {\n        player\n      } = moveData;\n      const {\n        piece\n      } = moveData;\n      const {\n        takes\n      } = moveData;\n      const {\n        castles\n      } = moveData; // move\n\n      if (to[0] !== -1) {\n        this.cntMovesGame += 1;\n\n        if (takes.piece !== undefined) {\n          this.processTakes(takes.pos, player, piece, takes.piece);\n        }\n\n        this.processMove(from, to, player, piece); // castle\n      } else if (castles !== '') {\n        this.cntMovesGame += 1;\n        const row = player === 'w' ? 7 : 0;\n        let rook = 'Rh';\n        let tarKingCol = 6;\n        let tarRookCol = 5;\n        let srcRookCol = 7;\n\n        if (castles === 'O-O-O') {\n          tarKingCol = 2;\n          tarRookCol = 3;\n          srcRookCol = 0;\n          rook = 'Ra';\n        }\n\n        this.processMove([row, 4], [row, tarKingCol], player, 'Ke');\n        this.processMove([row, srcRookCol], [row, tarRookCol], player, rook); // game end\n      } else {\n        for (let row = 0; row < 8; row += 1) {\n          for (let col = 0; col < 8; col += 1) {\n            const {\n              currentPiece\n            } = this.tiles[row][col];\n\n            if (currentPiece !== null) {\n              this.addOccupation([row, col]);\n            }\n\n            this.resetCurrentPiece(row, col);\n          }\n        }\n\n        this.cntMovesTotal += this.cntMovesGame;\n        this.cntMovesGame = 0;\n      }\n    }\n\n    processMove(from, to, player, piece) {\n      if (piece.length > 1 && !piece.match(/\\d/g)) {\n        this.addOccupation(from);\n        this.tiles[to[0]][to[1]].currentPiece = this.tiles[from[0]][from[1]].currentPiece;\n        this.tiles[to[0]][to[1]].currentPiece.lastMovedOn = this.cntMovesGame;\n        this.tiles[from[0]][from[1]].currentPiece = null;\n        this.tiles[to[0]][to[1]][player].movedTo += 1;\n        this.tiles[to[0]][to[1]][player][piece].movedTo += 1;\n      }\n    }\n\n    processTakes(pos, player, takingPiece, takenPiece) {\n      if (takenPiece.length > 1 && !takenPiece.match(/\\d/g)) {\n        const opPlayer = player === 'w' ? 'b' : 'w';\n        this.tiles[pos[0]][pos[1]][opPlayer].wasKilledOn += 1;\n        this.tiles[pos[0]][pos[1]][opPlayer][takenPiece].wasKilledOn += 1;\n        this.addOccupation(pos);\n        this.tiles[pos[0]][pos[1]].currentPiece = null;\n      }\n\n      if (takingPiece.length > 1 && !takingPiece.match(/\\d/g)) {\n        this.tiles[pos[0]][pos[1]][player].killedOn += 1;\n        this.tiles[pos[0]][pos[1]][player][takingPiece].killedOn += 1;\n      }\n    }\n\n    addOccupation(pos) {\n      const {\n        currentPiece\n      } = this.tiles[pos[0]][pos[1]];\n      const toAdd = this.cntMovesGame - currentPiece.lastMovedOn;\n      this.tiles[pos[0]][pos[1]][currentPiece.color].wasOn += toAdd;\n      this.tiles[pos[0]][pos[1]][currentPiece.color][currentPiece.piece].wasOn += toAdd;\n    }\n\n  }\n\n  var _default = TileTrackerBase;\n  _exports.default = _default;\n  module.exports = exports.default;\n});\n\n//# sourceURL=webpack://chessalyzer/./src/tracker/TileTrackerBase.js?");

/***/ }),

/***/ "chalk":
/*!************************!*\
  !*** external "chalk" ***!
  \************************/
/*! dynamic exports */
/*! exports [maybe provided (runtime-defined)] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"chalk\");;\n\n//# sourceURL=webpack://chessalyzer/external_%22chalk%22?");

/***/ }),

/***/ "cluster":
/*!**************************!*\
  !*** external "cluster" ***!
  \**************************/
/*! dynamic exports */
/*! exports [maybe provided (runtime-defined)] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"cluster\");;\n\n//# sourceURL=webpack://chessalyzer/external_%22cluster%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! dynamic exports */
/*! exports [maybe provided (runtime-defined)] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"events\");;\n\n//# sourceURL=webpack://chessalyzer/external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! dynamic exports */
/*! exports [maybe provided (runtime-defined)] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"fs\");;\n\n//# sourceURL=webpack://chessalyzer/external_%22fs%22?");

/***/ }),

/***/ "perf_hooks":
/*!*****************************!*\
  !*** external "perf_hooks" ***!
  \*****************************/
/*! dynamic exports */
/*! exports [maybe provided (runtime-defined)] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"perf_hooks\");;\n\n//# sourceURL=webpack://chessalyzer/external_%22perf_hooks%22?");

/***/ }),

/***/ "readline":
/*!***************************!*\
  !*** external "readline" ***!
  \***************************/
/*! dynamic exports */
/*! exports [maybe provided (runtime-defined)] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"readline\");;\n\n//# sourceURL=webpack://chessalyzer/external_%22readline%22?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/index.js");
/******/ })()
;
});