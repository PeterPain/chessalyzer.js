{"version":3,"sources":["webpack://chessalyzer/webpack/bootstrap","webpack://chessalyzer/./src/ChessBoard.js","webpack://chessalyzer/external \"fs\"","webpack://chessalyzer/external \"perf_hooks\"","webpack://chessalyzer/external \"events\"","webpack://chessalyzer/external \"line-by-line\"","webpack://chessalyzer/./src/ChessPiece.js","webpack://chessalyzer/./src/ChessTile.js","webpack://chessalyzer/./src/GameProcessor.js","webpack://chessalyzer/./src/Chessalyzer.js","webpack://chessalyzer/./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_ChessTile","_interopRequireDefault","_ChessPiece","pawnTemplate","pieceTemplate","ChessBoard","_classCallCheck","this","cntMoves","cntGames","pieces","tiles","Array","row","currRow","col","default","push","initPiece","length","moveData","moves","move","takes","to","piece","from","color","alive","processMove","promotes","promotePiece","updateTileStats","killPiece","killedPiece","updatePosition","reset","slice","resetPiece","initStats","coords","pieceType","rowArray","console","log","pos","updateStats","require","ChessPiece","promoted","arguments","undefined","defaultPos","history","dataMap","cntMoved","cntWasKilled","cntHasKilled","logHistory","maxHistory","killedBy","ChessTile","defaultPiece","cntHasPiece","index","_ChessBoard","LineByLineReader","EventEmitter","files","GameProcessor","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","board","activePlayer","path","refreshRate","_this2","Promise","resolve","reject","lr","game","gameCnt","blankLineCnt","self","on","err","line","pause","currLine","startsWith","replace","split","white","black","processGame","emit","processLine","resume","parseMove","resetStats","rawMove","token","substring","preProcess","match","toLowerCase","pawnMove","castle","pieceMove","moveFen","direction","includes","parseInt","indexOf","tarRow","tarCol","mustBeInRow","mustBeInCol","findPiece","findLine","findDiag","findKnight","concat","printPosition","obstructed1","obstructed2","j","row1","col1","row2","col2","checkCheck","opColor","king","isInCheck","diff","checkFor","Math","abs","srcTilePiece","tarTilePiece","obstructed","from1","from2","to1","to2","square","temp","_GameProcessor","performance","fs","Chessalyzer","ds","gp","bank","t0","now","processPGN","then","JSON","parse","stringify","t1","tdiff","round","mps","writeFile","error","readFileSync","fun","algebraicToCoords","map","max","min","dataRow","bank1","bank2","data0","generateHeatmap","data1","a","b","list","val","toFixed","sort","_Chessalyzer"],"mappings":"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","file":"chessalyzer.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","import ChessTile from './ChessTile';\nimport ChessPiece from './ChessPiece';\n\nconst pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\nconst pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n/** Class that contains the board status and tracks statistics. */\n/** Class that contains the board status and tracks statistics. */\nclass ChessBoard {\n\t/** Creates a new 8x8 Chessboard out of 64 {@link ChessTile}s and 32 {@link ChessPiece}s */\n\tconstructor() {\n\t\tthis.cntMoves = 0;\n\t\tthis.cntGames = 0;\n\n\t\t// contains all pieces\n\t\tthis.pieces = [];\n\n\t\t// init tiles\n\t\tthis.tiles = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = new ChessTile();\n\n\t\t\t\t// init pieces\n\t\t\t\tif (row === 0 || row === 7) {\n\t\t\t\t\tthis.pieces.push(\n\t\t\t\t\t\tnew ChessPiece(pieceTemplate[col], [row, col])\n\t\t\t\t\t);\n\t\t\t\t\tcurrRow[col].initPiece(this.pieces[this.pieces.length - 1]);\n\t\t\t\t} else if (row === 1 || row === 6) {\n\t\t\t\t\tthis.pieces.push(\n\t\t\t\t\t\tnew ChessPiece(pawnTemplate[col], [row, col])\n\t\t\t\t\t);\n\t\t\t\t\tcurrRow[col].initPiece(this.pieces[this.pieces.length - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.tiles[row] = currRow;\n\t\t}\n\t}\n\n\t/**\n\t * Moves a piece from source to target. Automatically handles the events 'move',\n\t *  'take', 'en passant', 'castle' and 'promote'.\n\t * Use this function instead of {@link ChessBoard.processMove} to input a move to the board!\n\t * @param {Array} coords An array containing:\n\t *      [0-1]: start tile,\n\t *      [2-3]: target tile,\n\t *      [4]: takes true/false,\n\t *      [5]: new piece type in case of pawn promotion.\n\t *\n\t *      If the move is castling, the array is assigned differently:\n\t *      [0-3]: king move,\n\t *      [4-7]: rook move.\n\t *\n\t *      Uses coords.length to differentiate between the different inputs.\n\t */\n\tmove(moveData) {\n\t\tif (moveData !== null) {\n\t\t\tthis.cntMoves += 1;\n\t\t\t// move\n\t\t\tif (moveData.moves.length === 1) {\n\t\t\t\tconst move = moveData.moves[0];\n\t\t\t\t// en passant\n\t\t\t\tif (\n\t\t\t\t\tmoveData.takes &&\n\t\t\t\t\tthis.tiles[move.to[0]][move.to[1]].piece === null\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.tiles[move.from[0]][move.from[1]].piece.color === 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.tiles[move.to[0] + 1][\n\t\t\t\t\t\t\tmove.to[1]\n\t\t\t\t\t\t].piece.alive = false;\n\t\t\t\t\t\tthis.tiles[move.to[0] + 1][move.to[1]].piece = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.tiles[move.to[0] + 1][\n\t\t\t\t\t\t\tmove.to[1]\n\t\t\t\t\t\t].piece.alive = false;\n\t\t\t\t\t\tthis.tiles[move.to[0] + 1][move.to[1]].piece = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.processMove(move);\n\t\t\t\tif (moveData.promotes !== null) {\n\t\t\t\t\tthis.promotePiece(move.to, moveData.promotes);\n\t\t\t\t}\n\n\t\t\t\t// castle\n\t\t\t} else {\n\t\t\t\tthis.processMove(moveData.moves[0]);\n\t\t\t\tthis.processMove(moveData.moves[1]);\n\t\t\t}\n\n\t\t\tthis.updateTileStats();\n\t\t} else {\n\t\t\t// nothing yet\n\t\t}\n\t}\n\n\t/**\n\t * Handles the move commanded by {@link ChessBoard.move}. Don't call this function directly,\n\t *  use {@link ChessBoard.move} to input a move!\n\t * @private\n\t * @param {Array} coords An array containing:\n\t *      [0-1]: start tile,\n\t *      [2-3]: target tile,\n\t */\n\tprocessMove(move) {\n\t\t// takes?\n\t\tconst { from } = move;\n\t\tconst { to } = move;\n\t\tif (this.tiles[to[0]][to[1]].piece !== null) {\n\t\t\tthis.tiles[to[0]][to[1]].piece.killPiece(\n\t\t\t\tthis.tiles[from[0]][from[1]].piece\n\t\t\t);\n\t\t\tthis.tiles[from[0]][from[1]].piece.killedPiece(\n\t\t\t\tthis.tiles[to[0]][to[1]].piece\n\t\t\t);\n\t\t}\n\n\t\tthis.tiles[to[0]][to[1]].piece = this.tiles[from[0]][from[1]].piece;\n\t\tthis.tiles[to[0]][to[1]].piece.updatePosition(to);\n\t\tthis.tiles[from[0]][from[1]].piece = null;\n\t}\n\n\t/** Resets the board to the default state: removes promoted pieces and puts the standard\n\t *  pieces back to their starting positions.\n\t *\n\t *  Does not reset the stats recorded. If you wish to reset the stats,\n\t *  call {@link ChessBoard.resetStats}. */\n\treset() {\n\t\tthis.cntGames += 1;\n\t\t// reset the pieces to default\n\t\tfor (let i = 0; i < this.pieces.length; i += 1) {\n\t\t\tthis.pieces[i].reset();\n\t\t}\n\n\t\t// remove promoted pieces\n\t\tthis.pieces = this.pieces.slice(0, 32);\n\n\t\t// reset the tiles\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tthis.tiles[row][col].resetPiece();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Resets the stats recorded. */\n\tresetStats() {\n\t\t// reset the tiles\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tthis.tiles[row][col].initStats();\n\t\t\t}\n\t\t}\n\n\t\t// reset the pieces to default\n\t\tfor (let i = 0; i < this.pieces.length; i += 1) {\n\t\t\tthis.pieces[i].initStats();\n\t\t}\n\n\t\tthis.cntMoves = 0;\n\t\tthis.cntGames = 0;\n\t}\n\n\t/**\n\t * Promotes a pawn to a piece.\n\t * @param {Array} coords An array containing the row and column of the pawn to be promoted.\n\t * @param {String} pieceType Target piece type in SAN notation ('N', 'B', 'Q', 'R').\n\t */\n\tpromotePiece(coords, pieceType) {\n\t\t// change alive directly instead of killPiece to not update stats\n\t\tthis.tiles[coords[0]][coords[1]].piece.alive = false;\n\t\tthis.tiles[coords[0]][coords[1]].piece = null;\n\n\t\tthis.pieces.push(\n\t\t\tnew ChessPiece(pieceType, [coords[0], coords[1]], true)\n\t\t);\n\t\tthis.tiles[coords[0]][coords[1]].piece = this.pieces[\n\t\t\tthis.pieces.length - 1\n\t\t];\n\t}\n\n\t/** Prints the current board position to the console. */\n\tprintPosition() {\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst rowArray = [];\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tconst { piece } = this.tiles[row][col];\n\t\t\t\tif (piece !== null) {\n\t\t\t\t\trowArray.push(piece.name);\n\t\t\t\t} else {\n\t\t\t\t\trowArray.push('..');\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(rowArray);\n\t\t}\n\t}\n\n\t/** Is called after each {@link ChessBoard.move} to record the stats for the ChessTiles.\n\t * Only every tile, that has a piece on it, is updated.\n\t */\n\tupdateTileStats() {\n\t\tfor (let i = 0; i < 32; i += 1) {\n\t\t\tif (this.pieces[i].alive) {\n\t\t\t\tthis.tiles[this.pieces[i].pos[0]][\n\t\t\t\t\tthis.pieces[i].pos[1]\n\t\t\t\t].updateStats();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport default ChessBoard;\n","module.exports = require(\"fs\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"events\");","module.exports = require(\"line-by-line\");","/**\n * Class that represents a chess piece and tracks statistics.\n */\nclass ChessPiece {\n\t/**\n\t * Creates a new ChessPiece.\n\t * @param {String} piece The name of the piece, e.g. 'Pd' for a D pawn.\n\t * @param {Number[]} pos Row and column the piece is on at start.\n\t * @param {Boolean} [promoted=false] Denotes if this piece is created by pawn promotion.\n\t */\n\tconstructor(piece, pos, promoted = false) {\n\t\tthis.name = piece; // piece type\n\t\tthis.pos = pos; // current position in [row, col] notation\n\t\tthis.defaultPos = pos; // starting position of this piece\n\t\tif (promoted) {\n\t\t\tthis.color = this.defaultPos[0] <= 1 ? 'white' : 'black'; // color of piece: 0 white, 1 black\n\t\t} else {\n\t\t\tthis.color = this.defaultPos[0] <= 1 ? 'black' : 'white'; // color of piece: 0 white, 1 black\n\t\t}\n\n\t\tthis.history = []; // position history\n\t\tthis.history.push(pos);\n\n\t\t/* 8x8 matrix that contains 3 informations for every tile\n\t\t\t0: counts how often this piece moved to the tile at these coordinates\n\t\t\t1: counts how often this piece was killed by the piece, that starts at these coordinates\n\t\t\t2: counts how often this piece killed a piece, that starts at these coordinates */\n\t\tthis.dataMap = null;\n\t\tthis.cntMoved = 0;\n\t\tthis.cntWasKilled = 0;\n\t\tthis.cntHasKilled = 0;\n\t\tthis.initStats();\n\n\t\tthis.alive = true; // piece alive?\n\t\tthis.logHistory = false;\n\n\t\tthis.maxHistory = 2000; // max length of history array\n\t}\n\n\t/**\n\t * Resets this piece to its default position and denotes a new game in the move history tracker.\n\t */\n\treset() {\n\t\tif (this.logHistory && this.history.length < this.maxHistory) {\n\t\t\tthis.history.push(null);\n\t\t\tthis.history.push(this.defaultPos);\n\t\t}\n\n\t\tthis.pos = this.defaultPos;\n\t\tthis.alive = true;\n\t}\n\n\t/**\n\t * Moves this piece to a new position and updates move statistics.\n\t * @param {Number[]} pos Target row and column of the tile the piece shall move to.\n\t */\n\tupdatePosition(pos) {\n\t\tthis.cntMoved += 1;\n\t\tthis.pos = pos;\n\t\tif (this.logHistory && this.history.length < this.maxHistory) {\n\t\t\tthis.history.push(pos);\n\t\t}\n\t\tthis.dataMap[pos[0]][pos[1]][0] += 1;\n\t}\n\n\t/**\n\t * Marks this piece as taken and updates the statistics of the piece it was taken by.\n\t * @param {ChessPiece} killedBy Piece this piece was taken by.\n\t */\n\tkillPiece(killedBy) {\n\t\tthis.alive = false;\n\t\tthis.cntWasKilled += 1;\n\n\t\t// if killer is not promoted pawn...\n\t\tif (!(killedBy.name.length === 1 || this.name.length === 1)) {\n\t\t\t// update killedBy of this piece\n\t\t\tthis.dataMap[killedBy.defaultPos[0]][\n\t\t\t\tkilledBy.defaultPos[1]\n\t\t\t][1] += 1;\n\t\t}\n\t}\n\n\tkilledPiece(killedPiece) {\n\t\tthis.cntHasKilled += 1;\n\n\t\t// if killer is not promoted pawn...\n\t\tif (!(killedPiece.name.length === 1 || this.name.length === 1)) {\n\t\t\t// update killed stat of killer piece\n\t\t\tthis.dataMap[killedPiece.defaultPos[0]][\n\t\t\t\tkilledPiece.defaultPos[1]\n\t\t\t][2] += 1;\n\t\t}\n\t}\n\n\t/**\n\t * Inits the statistics array of this piece.\n\t */\n\tinitStats() {\n\t\tthis.cntMoved = 0;\n\t\tthis.cntWasKilled = 0;\n\t\tthis.cntHasKilled = 0;\n\t\tthis.dataMap = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\t// [movedToTile, killedBy, killed]\n\t\t\t\tcurrRow[col] = [0, 0, 0];\n\t\t\t}\n\t\t\tthis.dataMap[row] = currRow;\n\t\t}\n\t}\n}\n\nexport default ChessPiece;\n","/** Class that represents a single Tile. Tracks statistics for itself. */\nclass ChessTile {\n\t/** Creates a new Tile. */\n\tconstructor() {\n\t\t/**\n\t\t * Piece that is currently on this tile.\n\t\t * @member {ChessPiece}\n\t\t */\n\t\tthis.piece = null;\n\n\t\t/**\n\t\t * Piece that is on this tile at start of game.\n\t\t * @member {ChessPiece}\n\t\t */\n\t\tthis.defaultPiece = null;\n\n\t\t/* 8x8 matrix that contains 2 informations for every tile\n\t\t\t0: counts how often the piece, that starts at these coordinates, was on this tile\n\t\t\t1: ? */\n\t\tthis.dataMap = null;\n\t\tthis.initStats();\n\t\t// counts amount of half moves, this tile has a piece on it [white, black]\n\t\tthis.cntHasPiece = [0, 0];\n\t}\n\n\t/**\n\t * Places a piece on this tile. Should only be called at board init.\n\t * @param {ChessPiece} piece The piece that is on this square by default.\n\t */\n\tinitPiece(piece) {\n\t\tthis.piece = piece;\n\t\tthis.defaultPiece = piece;\n\t}\n\n\t/**\n\t * Sets the currently active piece of this square to the default piece.\n\t */\n\tresetPiece() {\n\t\tthis.piece = this.defaultPiece;\n\t}\n\n\t/**\n\t * Updates the statistics of this tile.\n\t */\n\tupdateStats() {\n\t\tconst index = this.piece.color === 'white' ? 0 : 1;\n\t\tthis.cntHasPiece[index] += 1;\n\t\t// only non-promoted pieces are counted\n\t\tif (this.piece.name.length !== 1) {\n\t\t\tthis.dataMap[this.piece.defaultPos[0]][\n\t\t\t\tthis.piece.defaultPos[1]\n\t\t\t][0] += 1;\n\t\t}\n\t}\n\n\t/**\n\t * Inits the statistics array. Is called by the constructor.\n\t */\n\tinitStats() {\n\t\tthis.cntHasPiece = [0, 0];\n\t\tthis.dataMap = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = [0, 0];\n\t\t\t}\n\t\t\tthis.dataMap[row] = currRow;\n\t\t}\n\t}\n}\n\nexport default ChessTile;\n","import ChessBoard from './ChessBoard';\n\nconst LineByLineReader = require('line-by-line');\nconst EventEmitter = require('events');\n\nconst files = 'abcdefgh';\n\n/**\n * Class that processes games.\n */\nclass GameProcessor extends EventEmitter {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.board = new ChessBoard();\n\t\tthis.activePlayer = 0;\n\t}\n\n\tprocessPGN(path, refreshRate) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst lr = new LineByLineReader(path);\n\t\t\tlet game = { moves: '' };\n\t\t\tlet gameCnt = 0;\n\t\t\tlet blankLineCnt = 0;\n\t\t\tconst self = this;\n\n\t\t\t// process current line\n\t\t\tfunction processLine(line) {\n\t\t\t\tlet currLine;\n\n\t\t\t\t// data tag\n\t\t\t\tif (line.startsWith('[')) {\n\t\t\t\t\tcurrLine = line.replace(/[[\\]']+/g, '');\n\t\t\t\t\tcurrLine = currLine.split(' \"');\n\t\t\t\t\tlet key = currLine[0];\n\t\t\t\t\tlet value = currLine[1].replace('\"', '');\n\t\t\t\t\t// compact some strings to save space\n\t\t\t\t\tif (key === 'Site') {\n\t\t\t\t\t\tvalue = value.replace('https://lichess.org/', '');\n\t\t\t\t\t\tkey = 'id';\n\t\t\t\t\t} else if (key === 'UTCDate') key = 'Date';\n\t\t\t\t\telse if (key === 'Event') {\n\t\t\t\t\t\tvalue = value\n\t\t\t\t\t\t\t.replace('Rated', 'R')\n\t\t\t\t\t\t\t.replace('Unrated', 'U')\n\t\t\t\t\t\t\t.replace(' game', '');\n\t\t\t\t\t\tvalue = value.replace(/\\s+tournament.*$/, '');\n\t\t\t\t\t}\n\t\t\t\t\t// convert to int if Elo\n\t\t\t\t\tif (key === 'WhiteElo' || key === 'BlackElo') {\n\t\t\t\t\t\tvalue = +value;\n\t\t\t\t\t}\n\t\t\t\t\t// omit some values\n\t\t\t\t\tif (\n\t\t\t\t\t\t!(\n\t\t\t\t\t\t\tkey === 'UTCTime' ||\n\t\t\t\t\t\t\tkey === 'WhiteRatingDiff' ||\n\t\t\t\t\t\t\tkey === 'BlackRatingDiff' ||\n\t\t\t\t\t\t\tkey === 'Opening'\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgame[key] = value;\n\t\t\t\t\t}\n\t\t\t\t\t// next game\n\t\t\t\t} else if (line === '' && blankLineCnt === 1) {\n\t\t\t\t\tblankLineCnt = 0;\n\t\t\t\t\t// separator between tags and moves\n\t\t\t\t} else if (line === '' && blankLineCnt === 0) {\n\t\t\t\t\tblankLineCnt += 1;\n\t\t\t\t\t// moves\n\t\t\t\t} else if (line.startsWith('1')) {\n\t\t\t\t\tgame.moves = line\n\t\t\t\t\t\t.replace(/\\{.*?\\}\\s/g, '')\n\t\t\t\t\t\t.replace(/\\d+\\.+\\s/g, '');\n\t\t\t\t\tif (!(game.white === '?' || game.black === '?')) {\n\t\t\t\t\t\tself.processGame(game);\n\t\t\t\t\t\tgameCnt += 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (gameCnt % refreshRate === 0) {\n\t\t\t\t\t\tself.emit('status', gameCnt);\n\t\t\t\t\t}\n\n\t\t\t\t\tgame = { moves: '' };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlr.on('error', (err) => {\n\t\t\t\tconsole.log(err);\n\t\t\t\treject();\n\t\t\t});\n\n\t\t\tlr.on('line', (line) => {\n\t\t\t\t// pause emitting of lines...\n\t\t\t\tlr.pause();\n\n\t\t\t\t// ...do your asynchronous line processing..\n\t\t\t\tprocessLine(line);\n\t\t\t\tlr.resume();\n\t\t\t});\n\n\t\t\tlr.on('end', () => {\n\t\t\t\tconsole.log('Read entire file.');\n\t\t\t\tresolve(gameCnt);\n\t\t\t});\n\t\t});\n\t}\n\n\tprocessGame(game) {\n\t\tconst moves = game.moves.split(' ');\n\n\t\tfor (let i = 0; i < moves.length; i += 1) {\n\t\t\tthis.activePlayer = i % 2;\n\t\t\tconst moveData = this.parseMove(moves[i]);\n\t\t\tthis.board.move(moveData);\n\t\t}\n\t\tthis.board.reset();\n\t}\n\n\treset() {\n\t\tthis.board.reset();\n\t\tthis.board.resetStats();\n\t\tthis.activePlayer = 0;\n\t}\n\n\t/**\n\t * Parses a move in string format to board coordinates. Wrapper function for\n\t *  the different move algorithms.\n\t * @param {string} rawMove The move to be parsed, e.g. 'Ne5+'.\n\t * @returns {Array} An array containing:\n\t *      [0-1]: start tile,\n\t *      [2-3]: target tile,\n\t *      [4]: takes true/false,\n\t *      [5]: new piece type in case of pawn promotion.\n\t *\n\t *      If the move is castling, the array is assigned differently:\n\t *      [0-3]: king move,\n\t *      [4-7]: rook move.\n\t *\n\t *      Returns 'null' on game end (move is '1-0', '0-1' or '1/2-1/2').\n\t *\n\t *      Use coords.length to differentiate between the different outputs\n\t */\n\tparseMove(rawMove) {\n\t\tconst token = rawMove.substring(0, 1);\n\t\tlet moveData = {};\n\n\t\tconst move = GameProcessor.preProcess(rawMove);\n\n\t\t// game end on '1-0', '0-1' or '1/2-1/2' (check for digit as first char)\n\t\tif (token.match(/\\d/) !== null) {\n\t\t\tmoveData = null;\n\t\t} else if (token.toLowerCase() === token) {\n\t\t\t// pawn move\n\t\t\tmoveData = this.pawnMove(move);\n\t\t} else if (token === 'O') {\n\t\t\tmoveData = this.castle(move);\n\t\t} else {\n\t\t\tmoveData = this.pieceMove(move);\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Returns the board coordinates for the move if it is a pawn move.\n\t * @param {string} moveFen The move to be parsed, e.g. 'e5'.\n\t * @returns {Array} An array containing:\n\t *      [0-1]: start tile,\n\t *      [2-3]: target tile,\n\t *      [4]: takes true/false,\n\t *      [5]: new piece type in case of promotion.\n\t */\n\tpawnMove(moveFen) {\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\t\tconst direction = -2 * (this.activePlayer % 2) + 1;\n\t\tlet move = moveFen;\n\n\t\t// takes\n\t\tif (move.includes('x')) {\n\t\t\tmoveData.takes = true;\n\t\t\tmove = move.replace('x', '');\n\n\t\t\tto[0] = 8 - parseInt(move.substring(2, 3), 10);\n\t\t\tto[1] = files.indexOf(move.substring(1, 2));\n\t\t\tfrom[0] = to[0] + direction;\n\t\t\tfrom[1] = files.indexOf(move.substring(0, 1));\n\n\t\t\t// moves\n\t\t} else {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(0, 1));\n\n\t\t\tfrom[1] = tarCol;\n\t\t\tto[0] = tarRow;\n\t\t\tto[1] = tarCol;\n\t\t\tfor (let i = tarRow + direction; i < 8 && i >= 0; i += direction) {\n\t\t\t\tif (this.board.tiles[i][tarCol].piece !== null) {\n\t\t\t\t\tif (this.board.tiles[i][tarCol].piece.name.includes('P')) {\n\t\t\t\t\t\tfrom[0] = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmoveData.moves.push({ from, to });\n\n\t\t// promotes\n\t\tif (move.includes('=')) {\n\t\t\tmoveData.promotes = move.substring(move.length - 1, move.length);\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Returns the board coordinates for a piece (!= pawn) move.\n\t * @param {string} moveFen The move to be parsed, e.g. 'Be3'.\n\t * @returns {Array} An array containing:\n\t *      [0-1]: start tile,\n\t *      [2-3]: target tile,\n\t *      [4]: takes true/false.\n\t */\n\tpieceMove(moveFen) {\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\t\tlet move = moveFen;\n\t\tconst token = move.substring(0, 1);\n\n\t\t// remove token\n\t\tmove = move.substring(1, move.length);\n\n\t\t// takes\n\t\tif (move.includes('x')) {\n\t\t\tmoveData.takes = true;\n\t\t\tmove = move.replace('x', '');\n\t\t}\n\n\t\t// e.g. Re3f5\n\t\tif (move.length === 4) {\n\t\t\tfrom[0] = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tfrom[1] = files.indexOf(move.substring(0, 1));\n\t\t\tto[0] = 8 - parseInt(move.substring(3, 4), 10);\n\t\t\tto[1] = files.indexOf(move.substring(2, 3));\n\t\t\tmoveData.moves.push({ from, to });\n\n\t\t\t// e.g. Ref3\n\t\t} else if (move.length === 3) {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(2, 3), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(1, 2));\n\t\t\tlet mustBeInRow = -1;\n\t\t\tlet mustBeInCol = -1;\n\n\t\t\t// file is specified\n\t\t\tif (files.indexOf(move.substring(0, 1)) >= 0) {\n\t\t\t\tmustBeInCol = files.indexOf(move.substring(0, 1));\n\n\t\t\t\t// rank is specified\n\t\t\t} else {\n\t\t\t\tmustBeInRow = 8 - parseInt(move.substring(0, 1), 10);\n\t\t\t}\n\t\t\tmoveData.moves.push(\n\t\t\t\tthis.findPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token)\n\t\t\t);\n\n\t\t\t// e.g. Rf3\n\t\t} else {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(0, 1));\n\t\t\tmoveData.moves.push(this.findPiece(tarRow, tarCol, -1, -1, token));\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Wrapper function for different piece search algorithms.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Array} An array containing:\n\t *      [0-1]: start tile,\n\t *      [2-3]: target tile.\n\t */\n\tfindPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tlet move = {};\n\n\t\tif (token === 'R') {\n\t\t\tmove = this.findLine(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t} else if (token === 'B') {\n\t\t\tmove = this.findDiag(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t} else if (token === 'Q' || token === 'K') {\n\t\t\tmove = this.findDiag(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t\tif (move.from[0] === -1) {\n\t\t\t\tmove = this.findLine(\n\t\t\t\t\ttarRow,\n\t\t\t\t\ttarCol,\n\t\t\t\t\tmustBeInRow,\n\t\t\t\t\tmustBeInCol,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (token === 'N') {\n\t\t\tmove = this.findKnight(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t}\n\t\tif (move.from[0] === -1) {\n\t\t\tconsole.log(\n\t\t\t\t`Error: no piece for move ${token} to (${tarRow},${tarCol}) found!`\n\t\t\t);\n\t\t\tthis.board.printPosition();\n\t\t}\n\n\t\treturn move;\n\t}\n\n\t/**\n\t * Search algorithm to find a piece that can move diagonally.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Array} An array containing:\n\t *      [0-1]: start tile,\n\t *      [2-3]: target tile.\n\t */\n\tfindDiag(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -1; i <= 1; i += 2) {\n\t\t\tlet obstructed1 = false;\n\t\t\tlet obstructed2 = false;\n\t\t\tfor (let j = 1; j < 8; j += 1) {\n\t\t\t\tconst row1 = to[0] + i * j;\n\t\t\t\tconst col1 = to[1] + j;\n\t\t\t\tconst row2 = to[0] - i * j;\n\t\t\t\tconst col2 = to[1] - j;\n\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\t!obstructed1 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1, to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\t!obstructed2 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2, to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed2 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Search algorithm to find a piece that can move vertically/horizontally.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Array} An array containing:\n\t *      [0-1]: start tile,\n\t *      [2-3]: target tile.\n\t */\n\tfindLine(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -1; i <= 1; i += 2) {\n\t\t\tlet obstructed1 = false;\n\t\t\tlet obstructed2 = false;\n\t\t\tfor (let j = 1; j < 8; j += 1) {\n\t\t\t\tconst row1 = to[0];\n\t\t\t\tconst col1 = to[1] - i * j;\n\t\t\t\tconst row2 = to[0] - i * j;\n\t\t\t\tconst col2 = to[1];\n\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\t!obstructed1 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1, to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\t!obstructed2 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2, to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed2 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Search algorithm to find a matching knight.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Array} An array containing:\n\t *      [0-1]: start tile,\n\t *      [2-3]: target tile.\n\t */\n\tfindKnight(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -2; i <= 2; i += 4) {\n\t\t\tfor (let j = -1; j <= 1; j += 2) {\n\t\t\t\tconst row1 = to[0] + i;\n\t\t\t\tconst col1 = to[1] + j;\n\t\t\t\tconst row2 = to[0] + j;\n\t\t\t\tconst col2 = to[1] + i;\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1, to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2, to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Checks if the input move would be resulting with the king being in check.\n\t * @param {Array} coords Coordinates of the move that shall be checked.\n\t * @returns {boolean} After the move, the king will be in check true/false.\n\t */\n\tcheckCheck(coords) {\n\t\tconst from = coords.slice(0, 2);\n\t\tconst to = coords.slice(2);\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst opColor = this.activePlayer % 2 ? 'white' : 'black';\n\t\tconst king = this.board.pieces[color === 'white' ? 28 : 4].pos;\n\t\tlet isInCheck = false;\n\n\t\t// if king move, no check is possible, exit function\n\t\tif (king[0] === from[0] && king[1] === from[1]) return false;\n\n\t\t// check if moving piece is on same line/diag as king, else exit\n\t\tconst diff = [];\n\t\tdiff[0] = from[0] - king[0];\n\t\tdiff[1] = from[1] - king[1];\n\t\tconst checkFor = [];\n\t\tif (diff[0] === 0 || diff[1] === 0) {\n\t\t\tcheckFor[0] = 'Q';\n\t\t\tcheckFor[1] = 'R';\n\t\t} else if (Math.abs(diff[0]) === Math.abs(diff[1])) {\n\t\t\tcheckFor[0] = 'Q';\n\t\t\tcheckFor[1] = 'B';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tif (diff[0] !== 0) diff[0] /= Math.abs(diff[0]);\n\t\tif (diff[1] !== 0) diff[1] /= Math.abs(diff[1]);\n\n\t\tconst srcTilePiece = this.board.tiles[from[0]][from[1]].piece;\n\t\tconst tarTilePiece = this.board.tiles[to[0]][to[1]].piece;\n\n\t\t// premove and check if check\n\t\tthis.board.tiles[from[0]][from[1]].piece = null;\n\t\tthis.board.tiles[to[0]][to[1]].piece = srcTilePiece;\n\n\t\t// check for check\n\t\tlet obstructed = false;\n\t\tfor (let j = 1; j < 8 && !isInCheck && !obstructed; j += 1) {\n\t\t\tconst row = king[0] + j * diff[0];\n\t\t\tconst col = king[1] + j * diff[1];\n\n\t\t\tif (\n\t\t\t\trow >= 0 &&\n\t\t\t\trow < 8 &&\n\t\t\t\tcol >= 0 &&\n\t\t\t\tcol < 8 &&\n\t\t\t\tthis.board.tiles[row][col].piece !== null\n\t\t\t) {\n\t\t\t\tconst { piece } = this.board.tiles[row][col];\n\t\t\t\tif (\n\t\t\t\t\t(piece.name.includes(checkFor[0]) ||\n\t\t\t\t\t\tpiece.name.includes(checkFor[1])) &&\n\t\t\t\t\tpiece.color === opColor\n\t\t\t\t) {\n\t\t\t\t\tisInCheck = true;\n\t\t\t\t} else {\n\t\t\t\t\tobstructed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.board.tiles[from[0]][from[1]].piece = srcTilePiece;\n\t\tthis.board.tiles[to[0]][to[1]].piece = tarTilePiece;\n\n\t\treturn isInCheck;\n\t}\n\n\t/**\n\t * Returns the board coordinates for castling.\n\t * @param {string} move The move to be parsed, e.g. 'O-O'.\n\t * @returns {Array} An array containing:\n\t *      [0-3]: king move coordinates,\n\t *      [4-7]: rook move coordinates.\n\t */\n\tcastle(move) {\n\t\tconst row = this.activePlayer % 2 ? 0 : 7;\n\t\tconst from1 = [];\n\t\tconst from2 = [];\n\t\tconst to1 = [];\n\t\tconst to2 = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\n\t\t// O-O\n\t\tif (move.length === 3) {\n\t\t\tfrom1[0] = row;\n\t\t\tfrom1[1] = 4;\n\t\t\tto1[0] = row;\n\t\t\tto1[1] = 6;\n\t\t\tfrom2[0] = row;\n\t\t\tfrom2[1] = 7;\n\t\t\tto2[0] = row;\n\t\t\tto2[1] = 5;\n\n\t\t\t// O-O-O\n\t\t} else {\n\t\t\tfrom1[0] = row;\n\t\t\tfrom1[1] = 4;\n\t\t\tto1[0] = row;\n\t\t\tto1[1] = 2;\n\t\t\tfrom2[0] = row;\n\t\t\tfrom2[1] = 0;\n\t\t\tto2[0] = row;\n\t\t\tto2[1] = 3;\n\t\t}\n\t\tmoveData.moves.push({ from: from1, to: to1 });\n\t\tmoveData.moves.push({ from: from2, to: to2 });\n\t\treturn moveData;\n\t}\n\n\tstatic algebraicToCoords(square) {\n\t\tconst coords = [];\n\t\tconst temp = square.split('');\n\t\tcoords.push(8 - temp[1]);\n\t\tcoords.push(files.indexOf(temp[0]));\n\n\t\treturn coords;\n\t}\n\n\tstatic coordsToAlgebraic(coords) {\n\t\tlet name = files[coords[1]];\n\t\tname += 8 - coords[0];\n\n\t\treturn name;\n\t}\n\n\t/**\n\t * Removes special characters like '#', '+', '?' and '!'\n\t * @param {string} move The move to be cleaned up\n\t * @returns {string} The input string with removed special characters\n\t */\n\tstatic preProcess(move) {\n\t\treturn move.replace(/#|\\+|\\?|!/g, '');\n\t}\n}\n\nexport default GameProcessor;\n","import GameProcessor from './GameProcessor';\n\nconst { performance } = require('perf_hooks');\n\nconst fs = require('fs');\n\nconst pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\nconst pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\nclass Chessalyzer {\n\tconstructor() {\n\t\tthis.ds = new Array(2);\n\t\tthis.gp = new GameProcessor();\n\t}\n\n\tstartBatch(path, bank = 0, refreshRate = 250) {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst t0 = performance.now();\n\t\t\tthis.gp.processPGN(path, refreshRate).then((gameCnt) => {\n\t\t\t\tthis.ds[bank] = JSON.parse(JSON.stringify(this.gp.board));\n\t\t\t\tconst t1 = performance.now();\n\t\t\t\tconst tdiff = Math.round(t1 - t0) / 1000;\n\t\t\t\tconst mps = Math.round(this.gp.board.cntMoves / tdiff);\n\t\t\t\tconsole.log(\n\t\t\t\t\t`${\n\t\t\t\t\t\tthis.gp.board.cntMoves\n\t\t\t\t\t} moves processed in ${tdiff}s (${mps} moves/s)`\n\t\t\t\t);\n\t\t\t\tthis.gp.reset();\n\t\t\t\tresolve(gameCnt);\n\t\t\t});\n\t\t});\n\t}\n\n\tsaveAnalysis(path, bank = 0) {\n\t\tfs.writeFile(path, JSON.stringify(this.ds[bank]), (err) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconsole.log('File has been created');\n\t\t});\n\t}\n\n\tloadAnalysis(path, bank) {\n\t\tthis.ds[bank] = JSON.parse(fs.readFileSync(path, 'utf8'));\n\t\tconsole.log(`File '${path}' has been loaded to bank ${bank}.`);\n\t\treturn this.ds[bank].cntGames;\n\t}\n\n\tgenerateHeatmap(bank, square, fun) {\n\t\tconst coords = GameProcessor.algebraicToCoords(square);\n\t\tconst map = [];\n\t\tlet max = 0;\n\t\tlet min = 100000;\n\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tconst dataRow = new Array(8);\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tdataRow[j] = fun(this.ds[bank], coords, [i, j]);\n\t\t\t\tif (dataRow[j] > max) max = dataRow[j];\n\t\t\t\tif (dataRow[j] < min) min = dataRow[j];\n\t\t\t}\n\t\t\tmap.push(dataRow);\n\t\t}\n\n\t\treturn [map, min, max];\n\t}\n\n\tgenerateComparisonHeatmap(bank1, bank2, square, fun) {\n\t\tconst map = [];\n\t\tlet max = 0;\n\t\tlet min = 100000;\n\n\t\t// comparison heatmap\n\t\tconst data0 = this.generateHeatmap(bank1, square, fun);\n\t\tconst data1 = this.generateHeatmap(bank2, square, fun);\n\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tconst dataRow = new Array(8);\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tconst a = data0[0][i][j];\n\t\t\t\tconst b = data1[0][i][j];\n\t\t\t\tif (a === 0 || b === 0) dataRow[j] = 0;\n\t\t\t\telse dataRow[j] = (a >= b ? a / b - 1 : -b / a + 1) * 100;\n\n\t\t\t\tif (dataRow[j] > max) max = dataRow[j];\n\t\t\t\tif (dataRow[j] < min) min = dataRow[j];\n\t\t\t}\n\t\t\tmap.push(dataRow);\n\t\t}\n\n\t\treturn [map, min, max];\n\t}\n\n\tstatic generateList(map) {\n\t\tconst list = [];\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tlet val = map[i][j];\n\t\t\t\tval = val.toFixed(2);\n\t\t\t\tif (Math.abs(val) > 0.001) {\n\t\t\t\t\tif (i === 0) list.push([`b${pieceTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 1) list.push([`b${pawnTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 6) list.push([`w${pawnTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 7) list.push([`w${pieceTemplate[j]}`, val]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlist.sort((a, b) => b[1] - a[1]);\n\t\treturn list;\n\t}\n}\n\nexport default Chessalyzer;\n","/* eslint-disable */\nimport Chessalyzer from './Chessalyzer';\nimport ChessBoard from './ChessBoard';\n\nexport { Chessalyzer, ChessBoard };\n"],"sourceRoot":""}