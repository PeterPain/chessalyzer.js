{"version":3,"sources":["webpack://chessalyzer/webpack/universalModuleDefinition","webpack://chessalyzer/webpack/bootstrap","webpack://chessalyzer/external \"fs\"","webpack://chessalyzer/external \"perf_hooks\"","webpack://chessalyzer/external \"events\"","webpack://chessalyzer/external \"line-by-line\"","webpack://chessalyzer/./src/ChessPiece.js","webpack://chessalyzer/./src/ChessTile.js","webpack://chessalyzer/./src/ChessBoard.js","webpack://chessalyzer/./src/GameProcessor.js","webpack://chessalyzer/./src/Chessalyzer.js","webpack://chessalyzer/./src/index.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","ChessPiece","piece","pos","promoted","arguments","length","undefined","_classCallCheck","this","defaultPos","color","alive","stats","initStats","history","histCol","push","cntMoved","at","movedTo","killedByPiece","cntWasKilled","killedBy","killedPiece","cntHasKilled","killed","Array","row","currRow","col","ChessTile","defaultPiece","cntHasPiece","white","black","wasOnTile","cntTakenPieces","_ChessTile","_interopRequireDefault","_ChessPiece","pawnTemplate","pieceTemplate","ChessBoard","cfg","cntMoves","cntGames","setConfig","pieces","tiles","default","initPiece","moveData","moves","takes","promotes","move","processTakes","processMove","promotePiece","to","logPieceHistory","logTileOccupation","updateTileStats","from","offset","toPiece","fromPiece","killPiece","updateDeadCount","updatePosition","resetPiece","reset","slice","coords","pieceType","rowArray","console","log","config","updateOccupationStats","updateHistory","_ChessBoard","LineByLineReader","EventEmitter","files","GameProcessor","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","board","activePlayer","path","refreshRate","_this2","checkConfig","Promise","resolve","reject","lr","skipEmptyLines","game","on","err","line","pause","startsWith","hasFilter","match","replace","split","filter","processGame","emit","close","end","resume","processLine","parseMove","resetStats","rawMove","token","substring","preProcess","toLowerCase","pawnMove","pieceMove","castle","moveSan","direction","includes","parseInt","indexOf","tarRow","tarCol","mustBeInRow","mustBeInCol","findPiece","findLine","findDiag","findKnight","concat","printPosition","obstructed1","obstructed2","j","row1","col1","row2","col2","checkCheck","opColor","king","isInCheck","diff","checkFor","Math","abs","srcTilePiece","tarTilePiece","obstructed","from1","from2","to1","to2","Infinity","square","temp","_GameProcessor","performance","fs","Chessalyzer","dataStore","gameProcessor","bank","t0","now","processPGN","then","dataset","JSON","parse","stringify","t1","tdiff","round","mps","writeFile","error","readFileSync","fun","optData","algebraicToCoords","map","max","min","dataRow","bank1","bank2","data0","generateHeatmap","data1","a","b","list","val","toFixed","sort"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,iBAAAH,GACA,iBAAAC,QACAA,QAAA,YAAAD,IAEAD,EAAA,YAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAT,YAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,OAAAC,eAAAnB,EAAAuB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,mBClFAtC,EAAAD,QAAAwC,QAAA,qBCAAvC,EAAAD,QAAAwC,QAAA,6BCAAvC,EAAAD,QAAAwC,QAAA,yBCAAvC,EAAAD,QAAAwC,QAAA,uSCUC,SAAAC,EAAYC,EAAOC,GAAuB,IAAlBC,EAAkBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,gGAAAG,CAAAC,KAAAR,GAKzCQ,KAAKlC,KAAO2B,EAMZO,KAAKN,IAAMA,EAMXM,KAAKC,WAAaP,EAMlBM,KAAKE,MAAQ,GAEZF,KAAKE,MADFP,EACUK,KAAKC,WAAW,IAAM,EAAI,QAAU,QAEpCD,KAAKC,WAAW,IAAM,EAAI,QAAU,QAGlDD,KAAKG,OAAQ,EAMbH,KAAKI,SAOLJ,KAAKK,YAILL,KAAKM,WAELN,KAAKO,kGAQDP,KAAKO,QAAQV,OAAS,IACzBG,KAAKM,QAAQE,KAAKR,KAAKO,SACvBP,KAAKO,YAGNP,KAAKN,IAAMM,KAAKC,WAChBD,KAAKG,OAAQ,yCAQCT,GACdM,KAAKI,MAAMK,UAAY,EACvBT,KAAKN,IAAMA,EACXM,KAAKI,MAAMM,GAAGhB,EAAI,IAAIA,EAAI,IAAIiB,SAAW,0CAIzCX,KAAKO,QAAQC,KAAKR,KAAKN,uCAQdkB,GACTZ,KAAKG,OAAQ,EACbH,KAAKI,MAAMS,cAAgB,EAGS,IAA9BD,EAAc9C,KAAK+B,QAAqC,IAArBG,KAAKlC,KAAK+B,SAElDG,KAAKI,MAAMM,GAAGE,EAAcX,WAAW,IACtCW,EAAcX,WAAW,IACxBa,UAAY,uCAIJC,GACXf,KAAKI,MAAMY,cAAgB,EAGO,IAA5BD,EAAYjD,KAAK+B,QAAqC,IAArBG,KAAKlC,KAAK+B,SAEhDG,KAAKI,MAAMM,GAAGK,EAAYd,WAAW,IACpCc,EAAYd,WAAW,IACtBgB,QAAU,uCASbjB,KAAKI,OAAUK,SAAU,EAAGI,aAAc,EAAGG,aAAc,GAC3DhB,KAAKI,MAAMM,GAAK,IAAIQ,MAAM,GAC1B,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,CAEpC,IADA,IAAMC,EAAU,IAAIF,MAAM,GACjBG,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjCD,EAAQC,IAASV,QAAS,EAAGG,SAAU,EAAGG,OAAQ,GAEnDjB,KAAKI,MAAMM,GAAGS,GAAOC,mUClIvB,SAAAE,iGAAcvB,CAAAC,KAAAsB,GAKbtB,KAAKP,MAAQ,KAMbO,KAAKuB,aAAe,KAMpBvB,KAAKI,SAELJ,KAAKK,qGAQIZ,GACTO,KAAKP,MAAQA,EACbO,KAAKuB,aAAe9B,uCAQpBO,KAAKP,MAAQO,KAAKuB,6DASO,UAArBvB,KAAKP,MAAMS,MACdF,KAAKI,MAAMoB,YAAYC,OAAS,EAEhCzB,KAAKI,MAAMoB,YAAYE,OAAS,EAIF,IAA3B1B,KAAKP,MAAM3B,KAAK+B,SACnBG,KAAKI,MAAMM,GAAGV,KAAKP,MAAMQ,WAAW,IACnCD,KAAKP,MAAMQ,WAAW,IACrB0B,WAAa,6CAKhB3B,KAAKI,MAAMwB,gBAAkB,sCAQ7B5B,KAAKI,MAAMoB,aAAgBC,MAAO,EAAGC,MAAO,GAC5C1B,KAAKI,MAAMwB,eAAiB,EAE5B5B,KAAKI,MAAMM,GAAK,IAAIQ,MAAM,GAC1B,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,CAEpC,IADA,IAAMC,EAAU,IAAIF,MAAM,GACjBG,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjCD,EAAQC,IAASM,UAAW,GAE7B3B,KAAKI,MAAMM,GAAGS,GAAOC,4ICjFxB,IAAAS,EAAAC,EAAAzE,EAAA,IACA0E,EAAAD,EAAAzE,EAAA,6NAEA,IAAM2E,GAAgB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC1DC,GAAiB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,mBAKhE,SAAAC,IAAsB,IAAVC,EAAUvC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,mGAAAG,CAAAC,KAAAkC,GAKrBlC,KAAKI,OACJgC,SAAU,EACVC,SAAU,GAGXrC,KAAKmC,OACLnC,KAAKsC,UAAUH,GAMfnC,KAAKuC,UAMLvC,KAAKwC,MAAQ,IAAItB,MAAM,GACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,CAEpC,IADA,IAAMC,EAAU,IAAIF,MAAM,GACjBG,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjCD,EAAQC,GAAO,IAAAQ,EAAAY,QAGH,IAARtB,GAAqB,IAARA,GAChBnB,KAAKuC,OAAO/B,KACX,IAAAuB,EAAAU,QAAeR,EAAcZ,IAAOF,EAAKE,KAE1CD,EAAQC,GAAKqB,UAAU1C,KAAKuC,OAAOvC,KAAKuC,OAAO1C,OAAS,KACtC,IAARsB,GAAqB,IAARA,IACvBnB,KAAKuC,OAAO/B,KACX,IAAAuB,EAAAU,QAAeT,EAAaX,IAAOF,EAAKE,KAEzCD,EAAQC,GAAKqB,UAAU1C,KAAKuC,OAAOvC,KAAKuC,OAAO1C,OAAS,KAG1DG,KAAKwC,MAAMrB,GAAOC,uFAcfuB,GACJ,GAAiB,OAAbA,EAAmB,CACtB3C,KAAKI,MAAMgC,UAAY,EADD,IAGdQ,EAAUD,EAAVC,MACAC,EAAUF,EAAVE,MACAC,EAAaH,EAAbG,SAGR,GAAqB,IAAjBF,EAAM/C,OAAc,CACvB,IAAMkD,EAAOH,EAAM,GAEfC,GACH7C,KAAKgD,aAAaD,GAGnB/C,KAAKiD,YAAYF,GAEA,OAAbD,GACH9C,KAAKkD,aAAaH,EAAKI,GAAIL,QAI5B9C,KAAKiD,YAAYL,EAAM,IACvB5C,KAAKiD,YAAYL,EAAM,KAGpB5C,KAAKmC,IAAIiB,iBAAmBpD,KAAKmC,IAAIkB,oBACxCrD,KAAKsD,wDAaKP,GAAM,IACVQ,EAASR,EAATQ,KACAJ,EAAOJ,EAAPI,GACJK,EAAS,EAG0B,OAAnCxD,KAAKwC,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,QAC5B+D,EAC8C,UAA7CxD,KAAKwC,MAAMe,EAAK,IAAIA,EAAK,IAAI9D,MAAMS,MAAoB,GAAK,GAE9D,IAAMuD,EAAUzD,KAAKwC,MAAMW,EAAG,GAAKK,GAAQL,EAAG,IAAI1D,MAC5CiE,EAAY1D,KAAKwC,MAAMe,EAAK,IAAIA,EAAK,IAAI9D,MAE/CgE,EAAQE,UAAUD,GAClBA,EAAU3C,YAAY0C,GAEtBzD,KAAKwC,MAAMW,EAAG,GAAKK,GAAQL,EAAG,IAAI1D,MAAQ,KAC1CO,KAAKwC,MAAMW,EAAG,GAAKK,GAAQL,EAAG,IAAIS,sDAWvBb,GAAM,IACTQ,EAASR,EAATQ,KACAJ,EAAOJ,EAAPI,GAERnD,KAAKwC,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAAQO,KAAKwC,MAAMe,EAAK,IAAIA,EAAK,IAAI9D,MAC9DO,KAAKwC,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAAMoE,eAAeV,GAC9CnD,KAAKwC,MAAMe,EAAK,IAAIA,EAAK,IAAI9D,MAAQ,qCASrCO,KAAKI,MAAMiC,UAAY,EAEvB,IAAK,IAAI9E,EAAI,EAAGA,EAAIyC,KAAKuC,OAAO1C,OAAQtC,GAAK,EAAG,CAC/C,IAAMkC,EAAQO,KAAKuC,OAAOhF,GAC1ByC,KAAKwC,MAAM/C,EAAMC,IAAI,IAAID,EAAMC,IAAI,IAAIoE,aACvC9D,KAAKwC,MAAM/C,EAAMQ,WAAW,IAAIR,EAAMQ,WAAW,IAAI6D,aACrDrE,EAAMsE,QAIP/D,KAAKuC,OAASvC,KAAKuC,OAAOyB,MAAM,EAAG,yCAMnC,IAAK,IAAI7C,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjC,IAAK,IAAIE,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjCrB,KAAKwC,MAAMrB,GAAKE,GAAKhB,YAKvB,IAAK,IAAI9C,EAAI,EAAGA,EAAIyC,KAAKuC,OAAO1C,OAAQtC,GAAK,EAC5CyC,KAAKuC,OAAOhF,GAAG8C,YAGhBL,KAAKI,MAAMgC,SAAW,EACtBpC,KAAKI,MAAMiC,SAAW,uCASV4B,EAAQC,GAEpBlE,KAAKwC,MAAMyB,EAAO,IAAIA,EAAO,IAAIxE,MAAMU,OAAQ,EAC/CH,KAAKwC,MAAMyB,EAAO,IAAIA,EAAO,IAAIxE,MAAQ,KAEzCO,KAAKuC,OAAO/B,KACX,IAAAuB,EAAAU,QAAeyB,GAAYD,EAAO,GAAIA,EAAO,KAAK,IAEnDjE,KAAKwC,MAAMyB,EAAO,IAAIA,EAAO,IAAIxE,MAAQO,KAAKuC,OAC7CvC,KAAKuC,OAAO1C,OAAS,2CAMtB,IAAK,IAAIsB,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,CAEpC,IADA,IAAMgD,KACG9C,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,KAC5B5B,EAAUO,KAAKwC,MAAMrB,GAAKE,GAA1B5B,MACM,OAAVA,EACH0E,EAAS3D,KAAKf,EAAM3B,MAEpBqG,EAAS3D,KAAK,MAGhB4D,QAAQC,IAAIF,sCAIJG,GACTtE,KAAKmC,IAAIiB,kBAAkBnF,OAAOkB,UAAUC,eAAe1B,KAC1D4G,EACA,oBAEEA,EAAOlB,gBAEVpD,KAAKmC,IAAIkB,mBAAoBpF,OAAOkB,UAAUC,eAAe1B,KAC5D4G,EACA,sBAEEA,EAAOjB,4DASV,IAAK,IAAI9F,EAAI,EAAGA,EAAI,GAAIA,GAAK,EACxByC,KAAKuC,OAAOhF,GAAG4C,QACdH,KAAKmC,IAAIkB,mBACZrD,KAAKwC,MAAMxC,KAAKuC,OAAOhF,GAAGmC,IAAI,IAC7BM,KAAKuC,OAAOhF,GAAGmC,IAAI,IAClB6E,wBAIFvE,KAAKmC,IAAIiB,kBACPpD,KAAKI,MAAMgC,SAAW,GAAM,GACJ,UAAzBpC,KAAKuC,OAAOhF,GAAG2C,OACdF,KAAKI,MAAMgC,SAAW,GAAM,GACH,UAAzBpC,KAAKuC,OAAOhF,GAAG2C,QAEjBF,KAAKuC,OAAOhF,GAAGiH,0JC1PpB,IAAAC,mDAAA3C,CAAAzE,EAAA,0qBAEA,IAAMqH,EAAmBrH,EAAQ,GAC3BsH,EAAetH,EAAQ,GAEvBuH,EAAQ,yBAMb,SAAAC,IAAc,IAAAC,EAAA,mGAAA/E,CAAAC,KAAA6E,IACbC,EAAAC,EAAA/E,MAAA6E,EAAAG,WAAA/G,OAAAgH,eAAAJ,IAAAnH,KAAAsC,QACKkF,MAAQ,IAAAT,EAAAhC,QACbqC,EAAKK,aAAe,EAHPL,8OADaH,sFA4BhBS,EAAMd,EAAQe,GAAa,IAAAC,EAAAtF,KAC/BmC,EAAM0C,EAAcU,YAAYjB,GAItC,OAFAtE,KAAKkF,MAAM5C,UAAUH,EAAI/B,OAElB,IAAIoF,QAAQ,SAACC,EAASC,GAC5B,IAAMC,EAAK,IAAIjB,EAAiBU,GAAQQ,gBAAgB,IACpDC,KAsCJF,EAAGG,GAAG,QAAS,SAACC,GACf3B,QAAQC,IAAI0B,GACZL,MAGDC,EAAGG,GAAG,OAAQ,SAACE,GAEdL,EAAGM,QA1CgB,SAACD,GAEpB,GAAIA,EAAKE,WAAW,MAAQ/D,EAAIgE,UAAW,CAC1C,IAAMrH,EAAMkH,EAAKI,MAAM,aAAa,GAC9B5H,EAAQwH,EAAKI,MAAM,WAAW,GAEpCP,EAAK/G,GAAON,OAGFwH,EAAKE,WAAW,OAC1BL,EAAKjD,MAAQoD,EACXK,QAAQ,eAAgB,IACxBA,QAAQ,YAAa,IACrBA,QAAQ,KAAM,IACdC,MAAM,MAEJnE,EAAIoE,OAAOV,IAAU1D,EAAIgE,WAC5Bb,EAAKkB,YAAYX,GAIdP,EAAKJ,MAAM9E,MAAMiC,SAAWgD,GAAgB,GAC/CC,EAAKmB,KAAK,SAAUnB,EAAKJ,MAAM9E,MAAMiC,UAGtCwD,MAEGP,EAAKJ,MAAM9E,MAAMiC,UAAYF,EAAIE,UACpCsD,EAAGe,QACHf,EAAGgB,OAEHhB,EAAGiB,SAaJC,CAAYb,KAGbL,EAAGG,GAAG,MAAO,WACZ1B,QAAQC,IAAI,qBACZoB,EAAQH,EAAKJ,+CAKJW,GAGX,IAHiB,IACTjD,EAAUiD,EAAVjD,MAECrF,EAAI,EAAGA,EAAIqF,EAAM/C,OAAQtC,GAAK,EAAG,CACzCyC,KAAKmF,aAAe5H,EAAI,EACxB,IAAMoF,EAAW3C,KAAK8G,UAAUlE,EAAMrF,IACtCyC,KAAKkF,MAAMnC,KAAKJ,GAEjB3C,KAAKkF,MAAMnB,wCAIX/D,KAAKkF,MAAMnB,QACX/D,KAAKkF,MAAM6B,aACX/G,KAAKmF,aAAe,oCAgBX6B,GACT,IAAMC,EAAQD,EAAQE,UAAU,EAAG,GAG7BnE,EAAO8B,EAAcsC,WAAWH,GAatC,OAV0B,OAAtBC,EAAMb,MAAM,MACJ,KACDa,EAAMG,gBAAkBH,EACvBjH,KAAKqH,SAAStE,GACL,MAAVkE,EACCjH,KAAKsH,UAAUvE,GAEf/C,KAAKuH,OAAOxE,oCAWhByE,GACR,IAAMjE,KACAJ,KACAR,GACLC,SACAC,OAAO,EACPC,SAAU,MAEL2E,EAAkBzH,KAAKmF,aAAe,GAAzB,EAA8B,EAC7CpC,EAAOyE,EAGX,GAAIzE,EAAK2E,SAAS,KACjB/E,EAASE,OAAQ,EACjBE,EAAOA,EAAKsD,QAAQ,IAAK,IAEzBlD,EAAG,GAAK,EAAIwE,SAAS5E,EAAKmE,UAAU,EAAG,GAAI,IAC3C/D,EAAG,GAAKyB,EAAMgD,QAAQ7E,EAAKmE,UAAU,EAAG,IACxC3D,EAAK,GAAKJ,EAAG,GAAKsE,EAClBlE,EAAK,GAAKqB,EAAMgD,QAAQ7E,EAAKmE,UAAU,EAAG,QAGpC,CACN,IAAMW,EAAS,EAAIF,SAAS5E,EAAKmE,UAAU,EAAG,GAAI,IAC5CY,EAASlD,EAAMgD,QAAQ7E,EAAKmE,UAAU,EAAG,IAE/C3D,EAAK,GAAKuE,EACV3E,EAAG,GAAK0E,EACR1E,EAAG,GAAK2E,EACR,IAAK,IAAIvK,EAAIsK,EAASJ,EAAWlK,EAAI,GAAKA,GAAK,EAAGA,GAAKkK,EACtD,GAA0C,OAAtCzH,KAAKkF,MAAM1C,MAAMjF,GAAGuK,GAAQrI,OAC3BO,KAAKkF,MAAM1C,MAAMjF,GAAGuK,GAAQrI,MAAM3B,KAAK4J,SAAS,KAAM,CACzDnE,EAAK,GAAKhG,EACV,OAYJ,OAPAoF,EAASC,MAAMpC,MAAO+C,OAAMJ,OAGxBJ,EAAK2E,SAAS,OACjB/E,EAASG,SAAWC,EAAKmE,UAAUnE,EAAKlD,OAAS,EAAGkD,EAAKlD,SAGnD8C,oCAQE6E,GACT,IAAMjE,KACAJ,KACAR,GACLC,SACAC,OAAO,EACPC,SAAU,MAEPC,EAAOyE,EACLP,EAAQlE,EAAKmE,UAAU,EAAG,GAYhC,IATAnE,EAAOA,EAAKmE,UAAU,EAAGnE,EAAKlD,SAGrB6H,SAAS,OACjB/E,EAASE,OAAQ,EACjBE,EAAOA,EAAKsD,QAAQ,IAAK,KAIN,IAAhBtD,EAAKlD,OACR0D,EAAK,GAAK,EAAIoE,SAAS5E,EAAKmE,UAAU,EAAG,GAAI,IAC7C3D,EAAK,GAAKqB,EAAMgD,QAAQ7E,EAAKmE,UAAU,EAAG,IAC1C/D,EAAG,GAAK,EAAIwE,SAAS5E,EAAKmE,UAAU,EAAG,GAAI,IAC3C/D,EAAG,GAAKyB,EAAMgD,QAAQ7E,EAAKmE,UAAU,EAAG,IACxCvE,EAASC,MAAMpC,MAAO+C,OAAMJ,YAGtB,GAAoB,IAAhBJ,EAAKlD,OAAc,CAC7B,IAAMgI,EAAS,EAAIF,SAAS5E,EAAKmE,UAAU,EAAG,GAAI,IAC5CY,EAASlD,EAAMgD,QAAQ7E,EAAKmE,UAAU,EAAG,IAC3Ca,GAAe,EACfC,GAAe,EAGfpD,EAAMgD,QAAQ7E,EAAKmE,UAAU,EAAG,KAAO,EAC1Cc,EAAcpD,EAAMgD,QAAQ7E,EAAKmE,UAAU,EAAG,IAI9Ca,EAAc,EAAIJ,SAAS5E,EAAKmE,UAAU,EAAG,GAAI,IAElDvE,EAASC,MAAMpC,KACdR,KAAKiI,UAAUJ,EAAQC,EAAQC,EAAaC,EAAaf,QAIpD,CACN,IAAMY,EAAS,EAAIF,SAAS5E,EAAKmE,UAAU,EAAG,GAAI,IAC5CY,EAASlD,EAAMgD,QAAQ7E,EAAKmE,UAAU,EAAG,IAC/CvE,EAASC,MAAMpC,KAAKR,KAAKiI,UAAUJ,EAAQC,GAAS,GAAI,EAAGb,IAG5D,OAAOtE,oCAYEkF,EAAQC,EAAQC,EAAaC,EAAaf,GACnD,IAAIlE,EAmDJ,MAjDc,MAAVkE,EACHlE,EAAO/C,KAAKkI,SACXL,EACAC,EACAC,EACAC,EACAf,GAEmB,MAAVA,EACVlE,EAAO/C,KAAKmI,SACXN,EACAC,EACAC,EACAC,EACAf,GAEmB,MAAVA,GAA2B,MAAVA,GAQL,KAPtBlE,EAAO/C,KAAKmI,SACXN,EACAC,EACAC,EACAC,EACAf,IAEQ1D,KAAK,KACbR,EAAO/C,KAAKkI,SACXL,EACAC,EACAC,EACAC,EACAf,IAGkB,MAAVA,IACVlE,EAAO/C,KAAKoI,WACXP,EACAC,EACAC,EACAC,EACAf,KAGoB,IAAlBlE,EAAKQ,KAAK,KACba,QAAQC,IAAR,4BAAAgE,OAC6BpB,EAD7B,SAAAoB,OAC0CR,EAD1C,KAAAQ,OACoDP,EADpD,aAGA9H,KAAKkF,MAAMoD,iBAGLvF,mCAYC8E,EAAQC,EAAQC,EAAaC,EAAaf,GAClD,IAAM/G,EAAQF,KAAKmF,aAAe,EAAI,QAAU,QAE1C5B,KACAJ,KACNI,EAAK,IAAM,EACXA,EAAK,IAAM,EACXJ,EAAG,GAAK0E,EACR1E,EAAG,GAAK2E,EAER,IAAK,IAAIvK,GAAK,EAAGA,GAAK,EAAGA,GAAK,EAG7B,IAFA,IAAIgL,GAAc,EACdC,GAAc,EACTC,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC9B,IAAMC,EAAOvF,EAAG,GAAK5F,EAAIkL,EACnBE,EAAOxF,EAAG,GAAKsF,EACfG,EAAOzF,EAAG,GAAK5F,EAAIkL,EACnBI,EAAO1F,EAAG,GAAKsF,EAErB,GACCC,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,IACNJ,GACsC,OAAvCvI,KAAKkF,MAAM1C,MAAMkG,GAAMC,GAAMlJ,MAC5B,KACOA,EAAUO,KAAKkF,MAAM1C,MAAMkG,GAAMC,GAAjClJ,MACR,IACCA,EAAM3B,KAAK4J,SAAST,IACpBxH,EAAMS,QAAUA,IACE,IAAjB6H,GAAsBW,IAASX,IACd,IAAjBC,GAAsBW,IAASX,EAQhCO,GAAc,OANd,IAAKvI,KAAK8I,YAAYJ,EAAMC,IAAQxF,EAAG,GAAIA,EAAG,KAG7C,OAFAI,EAAK,GAAKmF,EACVnF,EAAK,GAAKoF,GACDpF,OAAMJ,MAOlB,GACCyF,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,IACNL,GACsC,OAAvCxI,KAAKkF,MAAM1C,MAAMoG,GAAMC,GAAMpJ,MAC5B,KACOA,EAAUO,KAAKkF,MAAM1C,MAAMoG,GAAMC,GAAjCpJ,MACR,IACCA,EAAM3B,KAAK4J,SAAST,IACpBxH,EAAMS,QAAUA,IACE,IAAjB6H,GAAsBa,IAASb,IACd,IAAjBC,GAAsBa,IAASb,EAQhCQ,GAAc,OANd,IAAKxI,KAAK8I,YAAYF,EAAMC,IAAQ1F,EAAG,GAAIA,EAAG,KAG7C,OAFAI,EAAK,GAAKqF,EACVrF,EAAK,GAAKsF,GACDtF,OAAMJ,OAQpB,OAASI,OAAMJ,uCAYP0E,EAAQC,EAAQC,EAAaC,EAAaf,GAClD,IAAM/G,EAAQF,KAAKmF,aAAe,EAAI,QAAU,QAC1C5B,KACAJ,KACNI,EAAK,IAAM,EACXA,EAAK,IAAM,EACXJ,EAAG,GAAK0E,EACR1E,EAAG,GAAK2E,EAER,IAAK,IAAIvK,GAAK,EAAGA,GAAK,EAAGA,GAAK,EAG7B,IAFA,IAAIgL,GAAc,EACdC,GAAc,EACTC,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC9B,IAAMC,EAAOvF,EAAG,GACVwF,EAAOxF,EAAG,GAAK5F,EAAIkL,EACnBG,EAAOzF,EAAG,GAAK5F,EAAIkL,EACnBI,EAAO1F,EAAG,GAEhB,GACCuF,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,IACNJ,GACsC,OAAvCvI,KAAKkF,MAAM1C,MAAMkG,GAAMC,GAAMlJ,MAC5B,KACOA,EAAUO,KAAKkF,MAAM1C,MAAMkG,GAAMC,GAAjClJ,MACR,IACCA,EAAM3B,KAAK4J,SAAST,IACpBxH,EAAMS,QAAUA,IACE,IAAjB6H,GAAsBW,IAASX,IACd,IAAjBC,GAAsBW,IAASX,EAQhCO,GAAc,OANd,IAAKvI,KAAK8I,YAAYJ,EAAMC,IAAQxF,EAAG,GAAIA,EAAG,KAG7C,OAFAI,EAAK,GAAKmF,EACVnF,EAAK,GAAKoF,GACDpF,OAAMJ,MAMlB,GACCyF,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,IACNL,GACsC,OAAvCxI,KAAKkF,MAAM1C,MAAMoG,GAAMC,GAAMpJ,MAC5B,KACOA,EAAUO,KAAKkF,MAAM1C,MAAMoG,GAAMC,GAAjCpJ,MACR,IACCA,EAAM3B,KAAK4J,SAAST,IACpBxH,EAAMS,QAAUA,IACE,IAAjB6H,GAAsBa,IAASb,IACd,IAAjBC,GAAsBa,IAASb,EAQhCQ,GAAc,OANd,IAAKxI,KAAK8I,YAAYF,EAAMC,IAAQ1F,EAAG,GAAIA,EAAG,KAG7C,OAFAI,EAAK,GAAKqF,EACVrF,EAAK,GAAKsF,GACDtF,OAAMJ,OAQpB,OAASI,OAAMJ,yCAYL0E,EAAQC,EAAQC,EAAaC,EAAaf,GACpD,IAAM/G,EAAQF,KAAKmF,aAAe,EAAI,QAAU,QAC1C5B,KACAJ,KACNI,EAAK,IAAM,EACXA,EAAK,IAAM,EACXJ,EAAG,GAAK0E,EACR1E,EAAG,GAAK2E,EAER,IAAK,IAAIvK,GAAK,EAAGA,GAAK,EAAGA,GAAK,EAC7B,IAAK,IAAIkL,GAAK,EAAGA,GAAK,EAAGA,GAAK,EAAG,CAChC,IAAMC,EAAOvF,EAAG,GAAK5F,EACfoL,EAAOxF,EAAG,GAAKsF,EACfG,EAAOzF,EAAG,GAAKsF,EACfI,EAAO1F,EAAG,GAAK5F,EACrB,GACCmL,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,GACgC,OAAvC3I,KAAKkF,MAAM1C,MAAMkG,GAAMC,GAAMlJ,MAC5B,KACOA,EAAUO,KAAKkF,MAAM1C,MAAMkG,GAAMC,GAAjClJ,MACR,GACCA,EAAM3B,KAAK4J,SAAST,IACpBxH,EAAMS,QAAUA,KACE,IAAjB6H,GAAsBW,IAASX,MACd,IAAjBC,GAAsBW,IAASX,KAE3BhI,KAAK8I,YAAYJ,EAAMC,IAAQxF,EAAG,GAAIA,EAAG,KAG7C,OAFAI,EAAK,GAAKmF,EACVnF,EAAK,GAAKoF,GACDpF,OAAMJ,MAIlB,GACCyF,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,GACgC,OAAvC7I,KAAKkF,MAAM1C,MAAMoG,GAAMC,GAAMpJ,MAC5B,KACOA,EAAUO,KAAKkF,MAAM1C,MAAMoG,GAAMC,GAAjCpJ,MACR,GACCA,EAAM3B,KAAK4J,SAAST,IACpBxH,EAAMS,QAAUA,KACE,IAAjB6H,GAAsBa,IAASb,MACd,IAAjBC,GAAsBa,IAASb,KAE3BhI,KAAK8I,YAAYF,EAAMC,IAAQ1F,EAAG,GAAIA,EAAG,KAG7C,OAFAI,EAAK,GAAKqF,EACVrF,EAAK,GAAKsF,GACDtF,OAAMJ,OAMpB,OAASI,OAAMJ,yCASLI,EAAMJ,GAChB,IAAMjD,EAAQF,KAAKmF,aAAe,EAAI,QAAU,QAC1C4D,EAAU/I,KAAKmF,aAAe,EAAI,QAAU,QAC5C6D,EAAOhJ,KAAKkF,MAAM3C,OAAiB,UAAVrC,EAAoB,GAAK,GAAGR,IACvDuJ,GAAY,EAGhB,GAAID,EAAK,KAAOzF,EAAK,IAAMyF,EAAK,KAAOzF,EAAK,GAAI,OAAO,EAGvD,IAAM2F,KACNA,EAAK,GAAK3F,EAAK,GAAKyF,EAAK,GACzBE,EAAK,GAAK3F,EAAK,GAAKyF,EAAK,GACzB,IAAMG,KACN,GAAgB,IAAZD,EAAK,IAAwB,IAAZA,EAAK,GACzBC,EAAS,GAAK,IACdA,EAAS,GAAK,QACR,IAAIC,KAAKC,IAAIH,EAAK,MAAQE,KAAKC,IAAIH,EAAK,IAI9C,OAAO,EAHPC,EAAS,GAAK,IACdA,EAAS,GAAK,IAIC,IAAZD,EAAK,KAAUA,EAAK,IAAME,KAAKC,IAAIH,EAAK,KAC5B,IAAZA,EAAK,KAAUA,EAAK,IAAME,KAAKC,IAAIH,EAAK,KAE5C,IAAMI,EAAetJ,KAAKkF,MAAM1C,MAAMe,EAAK,IAAIA,EAAK,IAAI9D,MAClD8J,EAAevJ,KAAKkF,MAAM1C,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAGpDO,KAAKkF,MAAM1C,MAAMe,EAAK,IAAIA,EAAK,IAAI9D,MAAQ,KAC3CO,KAAKkF,MAAM1C,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAAQ6J,EAIvC,IADA,IAAIE,GAAa,EACRf,EAAI,EAAGA,EAAI,IAAMQ,IAAcO,EAAYf,GAAK,EAAG,CAC3D,IAAMtH,EAAM6H,EAAK,GAAKP,EAAIS,EAAK,GACzB7H,EAAM2H,EAAK,GAAKP,EAAIS,EAAK,GAE/B,GACC/H,GAAO,GACPA,EAAM,GACNE,GAAO,GACPA,EAAM,GAC+B,OAArCrB,KAAKkF,MAAM1C,MAAMrB,GAAKE,GAAK5B,MAC1B,KACOA,EAAUO,KAAKkF,MAAM1C,MAAMrB,GAAKE,GAAhC5B,OAENA,EAAM3B,KAAK4J,SAASyB,EAAS,KAC7B1J,EAAM3B,KAAK4J,SAASyB,EAAS,MAC9B1J,EAAMS,QAAU6I,EAEhBE,GAAY,EAEZO,GAAa,GAQhB,OAHAxJ,KAAKkF,MAAM1C,MAAMe,EAAK,IAAIA,EAAK,IAAI9D,MAAQ6J,EAC3CtJ,KAAKkF,MAAM1C,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAAQ8J,EAEhCN,iCAQDlG,GACN,IAAM5B,EAAMnB,KAAKmF,aAAe,EAAI,EAAI,EAClCsE,KACAC,KACAC,KACAC,KACAjH,GACLC,SACAC,OAAO,EACPC,SAAU,MA2BX,OAvBoB,IAAhBC,EAAKlD,QACR4J,EAAM,GAAKtI,EACXsI,EAAM,GAAK,EACXE,EAAI,GAAKxI,EACTwI,EAAI,GAAK,EACTD,EAAM,GAAKvI,EACXuI,EAAM,GAAK,EACXE,EAAI,GAAKzI,EACTyI,EAAI,GAAK,IAITH,EAAM,GAAKtI,EACXsI,EAAM,GAAK,EACXE,EAAI,GAAKxI,EACTwI,EAAI,GAAK,EACTD,EAAM,GAAKvI,EACXuI,EAAM,GAAK,EACXE,EAAI,GAAKzI,EACTyI,EAAI,GAAK,GAEVjH,EAASC,MAAMpC,MAAO+C,KAAMkG,EAAOtG,GAAIwG,IACvChH,EAASC,MAAMpC,MAAO+C,KAAMmG,EAAOvG,GAAIyG,IAChCjH,wCAnpBW2B,GAClB,IAAMnC,KAiBN,OAhBAA,EAAIgE,UAAYlI,OAAOkB,UAAUC,eAAe1B,KAAK4G,EAAQ,UAC7DnC,EAAIoE,OAASpE,EAAIgE,UAAY7B,EAAOiC,OAAS,kBAAM,GAEnDpE,EAAIE,SAAWpE,OAAOkB,UAAUC,eAAe1B,KAAK4G,EAAQ,YACzDA,EAAOjC,SACPwH,IAEH1H,EAAI/B,MAAQnC,OAAOkB,UAAUC,eAAe1B,KAAK4G,EAAQ,SACtDA,EAAOlE,SAIV+B,EAAImE,QAAQrI,OAAOkB,UAAUC,eAAe1B,KAAK4G,EAAQ,UACtDA,EAAOgC,MAGHnE,4CAooBiB2H,GACxB,IAAM7F,KACA8F,EAAOD,EAAOxD,MAAM,IAI1B,OAHArC,EAAOzD,KAAK,EAAIuJ,EAAK,IACrB9F,EAAOzD,KAAKoE,EAAMgD,QAAQmC,EAAK,KAExB9F,4CAGiBA,GACxB,IAAInG,EAAO8G,EAAMX,EAAO,IAGxB,OAFAnG,GAAQ,EAAImG,EAAO,sCAUFlB,GACjB,OAAOA,EAAKsD,QAAQ,aAAc,6IC7rBpC,IAAA2D,mDAAAlI,CAAAzE,EAAA,8KAEQ4M,EAAgB5M,EAAQ,GAAxB4M,YAEFC,EAAK7M,EAAQ,GAEb2E,GAAgB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC1DC,GAAiB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,mBAWhE,SAAAkI,iGAAcpK,CAAAC,KAAAmK,GAUbnK,KAAKoK,UAAY,IAAIlJ,MAAM,GAM3BlB,KAAKqK,cAAgB,IAAAL,EAAAvH,kGAsBX2C,GAA6C,IAAAN,EAAA9E,KAAvCmC,EAAuCvC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,MAA7B0K,EAA6B1K,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAtB,EAAGyF,EAAmBzF,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAL,IAClD,OAAO,IAAI4F,QAAQ,SAACC,GACnB,IAAM8E,EAAKN,EAAYO,MACvB1F,EAAKuF,cACHI,WAAWrF,EAAMjD,EAAKkD,GACtBqF,KAAK,SAACxF,GACN,IAAMyF,KACNA,EAAQvK,MAAQ8E,EAAM9E,MACtBuK,EAAQnI,MAAQ0C,EAAM1C,MACtBsC,EAAKsF,UAAUE,GAAQM,KAAKC,MAAMD,KAAKE,UAAUH,IACjD,IAAMI,EAAKd,EAAYO,MACjBQ,EAAQ5B,KAAK6B,MAAMF,EAAKR,GAAM,IAC9BW,EAAM9B,KAAK6B,MAAMN,EAAQvK,MAAMgC,SAAW4I,GAChD5G,QAAQC,IAAR,GAAAgE,OACIsC,EAAQvK,MAAMiC,SADlB,YAAAgG,OAEEsC,EAAQvK,MAAMgC,SAFhB,yBAAAiG,OAGyB2C,EAHzB,OAAA3C,OAGoC6C,EAHpC,cAKApG,EAAKuF,cAActG,QACnB0B,EAAQX,EAAKsF,UAAUE,GAAMlK,MAAMiC,+CAU9B+C,GAAgB,IAAVkF,EAAU1K,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAH,EACrBsK,EAAGiB,UAAU/F,EAAMwF,KAAKE,UAAU9K,KAAKoK,UAAUE,IAAQ,SAACvE,GACrDA,EACH3B,QAAQgH,MAAMrF,GAGf3B,QAAQC,IAAI,4DAULe,EAAMkF,GAGd,OAFAtK,KAAKoK,UAAUE,GAAQM,KAAKC,MAAMX,EAAGmB,aAAajG,EAAM,SACxDhB,QAAQC,IAAR,SAAAgE,OAAqBjD,EAArB,8BAAAiD,OAAsDiC,EAAtD,MACOtK,KAAKoK,UAAUE,GAAMjI,iDA6BbiI,EAAMR,EAAQwB,EAAKC,GAMlC,IALA,IAAMtH,EAAS+F,EAAAvH,QAAc+I,kBAAkB1B,GACzC2B,KACFC,EAAM,EACNC,EAAM,IAEDpO,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAE9B,IADA,IAAMqO,EAAU,IAAI1K,MAAM,GACjBuH,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAC3BmD,EAAQnD,GAAK6C,EAAItL,KAAKoK,UAAUE,GAAOrG,GAAS1G,EAAGkL,GAAI8C,GACnDK,EAAQnD,GAAKiD,IAAKA,EAAME,EAAQnD,IAChCmD,EAAQnD,GAAKkD,IAAKA,EAAMC,EAAQnD,IAErCgD,EAAIjL,KAAKoL,GAGV,OAAQH,EAAKE,EAAKD,qDAsBO5B,EAAQwB,GASjC,IATqE,IAA/BO,EAA+BjM,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAvB,EAAGkM,EAAoBlM,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAZ,EAAG2L,EAAS3L,UAAA,GAC/D6L,KACFC,EAAM,EACNC,EAAM,IAGJI,EAAQ/L,KAAKgM,gBAAgBH,EAAO/B,EAAQwB,EAAKC,GACjDU,EAAQjM,KAAKgM,gBAAgBF,EAAOhC,EAAQwB,EAAKC,GAE9ChO,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAE9B,IADA,IAAMqO,EAAU,IAAI1K,MAAM,GACjBuH,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC9B,IAAMyD,EAAIH,EAAM,GAAGxO,GAAGkL,GAChB0D,EAAIF,EAAM,GAAG1O,GAAGkL,GACEmD,EAAQnD,GAAtB,IAANyD,GAAiB,IAANC,EAAsB,EACiB,KAAnCD,GAAKC,EAAID,EAAIC,EAAI,GAAKA,EAAID,EAAI,GAE7CN,EAAQnD,GAAKiD,IAAKA,EAAME,EAAQnD,IAChCmD,EAAQnD,GAAKkD,IAAKA,EAAMC,EAAQnD,IAErCgD,EAAIjL,KAAKoL,GAGV,OAAQH,EAAKE,EAAKD,0CAGCD,GAEnB,IADA,IAAMW,KACG7O,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAC3B,IAAK,IAAIkL,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC9B,IAAI4D,EAAMZ,EAAIlO,GAAGkL,GACjB4D,EAAMA,EAAIC,QAAQ,GACdlD,KAAKC,IAAIgD,GAAO,OACT,IAAN9O,EAAS6O,EAAK5L,MAAK,IAAA6H,OAAKpG,EAAcwG,IAAM4D,IACjC,IAAN9O,EAAS6O,EAAK5L,MAAK,IAAA6H,OAAKrG,EAAayG,IAAM4D,IACrC,IAAN9O,EAAS6O,EAAK5L,MAAK,IAAA6H,OAAKrG,EAAayG,IAAM4D,IACrC,IAAN9O,GAAS6O,EAAK5L,MAAK,IAAA6H,OAAKpG,EAAcwG,IAAM4D,KAKxD,OADAD,EAAKG,KAAK,SAACL,EAAGC,GAAJ,OAAUA,EAAE,GAAKD,EAAE,KACtBE,kMCnNTtK,CAAAzE,EAAA","file":"chessalyzer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"chessalyzer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"chessalyzer\"] = factory();\n\telse\n\t\troot[\"chessalyzer\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","module.exports = require(\"fs\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"events\");","module.exports = require(\"line-by-line\");","/**\n * Class that represents a chess piece and tracks statistics.\n */\nclass ChessPiece {\n\t/**\n\t * Creates a new ChessPiece.\n\t * @param {String} piece The name of the piece, e.g. 'Pd' for a D pawn.\n\t * @param {Number[]} pos Row and column the piece is on at start.\n\t * @param {Boolean} [promoted=false] Denotes if this piece is created by pawn promotion.\n\t */\n\tconstructor(piece, pos, promoted = false) {\n\t\t/**\n\t\t * Name of the piece, e.g 'Pb' for the b pawn\n\t\t * @member {String}\n\t\t */\n\t\tthis.name = piece; // piece type\n\n\t\t/**\n\t\t * Current position of this piece: [row,col], with [0,0] being the top left square\n\t\t * @member {Number[]}\n\t\t */\n\t\tthis.pos = pos; // current position in [row, col] notation\n\n\t\t/**\n\t\t * Starting position of this piece: [row,col], with [0,0] being the top left square\n\t\t * @member {Number[]}\n\t\t */\n\t\tthis.defaultPos = pos; // starting position of this piece\n\n\t\t/**\n\t\t * Color of this piece: 'black' or 'white'\n\t\t * @member {String}\n\t\t */\n\t\tthis.color = '';\n\t\tif (promoted) {\n\t\t\tthis.color = this.defaultPos[0] <= 1 ? 'white' : 'black'; // color of piece: 0 white, 1 black\n\t\t} else {\n\t\t\tthis.color = this.defaultPos[0] <= 1 ? 'black' : 'white'; // color of piece: 0 white, 1 black\n\t\t}\n\n\t\tthis.alive = true; // piece alive?\n\n\t\t/**\n\t\t * Object that contains the tracked statistics\n\t\t * @member {Object}\n\t\t */\n\t\tthis.stats = {};\n\n\t\t/**\n\t\t * Is this piece alive?\n\t\t * @member {Object}\n\t\t */\n\n\t\tthis.initStats();\n\n\t\t// option to track the move history of each piece\n\t\t// currently unused, costs a lot of performance\n\t\tthis.history = []; // position history\n\n\t\tthis.histCol = [];\n\t}\n\n\t/**\n\t * Resets this piece to its default position and denotes a new game in the move history tracker.\n\t * @private\n\t */\n\treset() {\n\t\tif (this.histCol.length > 0) {\n\t\t\tthis.history.push(this.histCol);\n\t\t\tthis.histCol = [];\n\t\t}\n\n\t\tthis.pos = this.defaultPos;\n\t\tthis.alive = true;\n\t}\n\n\t/**\n\t * Moves this piece to a new position and updates move statistics.\n\t * @private\n\t * @param {Number[]} pos Target row and column of the tile the piece shall move to.\n\t */\n\tupdatePosition(pos) {\n\t\tthis.stats.cntMoved += 1;\n\t\tthis.pos = pos;\n\t\tthis.stats.at[pos[0]][pos[1]].movedTo += 1;\n\t}\n\n\tupdateHistory() {\n\t\tthis.histCol.push(this.pos);\n\t}\n\n\t/**\n\t * Marks this piece as taken and updates the statistics of the piece it was taken by.\n\t * @private\n\t * @param {ChessPiece} killedBy Piece this piece was taken by.\n\t */\n\tkillPiece(killedByPiece) {\n\t\tthis.alive = false;\n\t\tthis.stats.cntWasKilled += 1;\n\n\t\t// if killer is not promoted pawn...\n\t\tif (!(killedByPiece.name.length === 1 || this.name.length === 1)) {\n\t\t\t// update killedBy of this piece\n\t\t\tthis.stats.at[killedByPiece.defaultPos[0]][\n\t\t\t\tkilledByPiece.defaultPos[1]\n\t\t\t].killedBy += 1;\n\t\t}\n\t}\n\n\tkilledPiece(killedPiece) {\n\t\tthis.stats.cntHasKilled += 1;\n\n\t\t// if killer is not promoted pawn...\n\t\tif (!(killedPiece.name.length === 1 || this.name.length === 1)) {\n\t\t\t// update killed stat of killer piece\n\t\t\tthis.stats.at[killedPiece.defaultPos[0]][\n\t\t\t\tkilledPiece.defaultPos[1]\n\t\t\t].killed += 1;\n\t\t}\n\t}\n\n\t/**\n\t * Inits the statistics array of this piece.\n\t * @private\n\t */\n\tinitStats() {\n\t\tthis.stats = { cntMoved: 0, cntWasKilled: 0, cntHasKilled: 0 };\n\t\tthis.stats.at = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = { movedTo: 0, killedBy: 0, killed: 0 };\n\t\t\t}\n\t\t\tthis.stats.at[row] = currRow;\n\t\t}\n\t}\n}\n\nexport default ChessPiece;\n","/** Class that represents a single Tile. Tracks statistics for itself. */\nclass ChessTile {\n\t/** Creates a new Tile. */\n\tconstructor() {\n\t\t/**\n\t\t * Piece that is currently on this tile.\n\t\t * @member {ChessPiece}\n\t\t */\n\t\tthis.piece = null;\n\n\t\t/**\n\t\t * Piece that is on this tile at start of game.\n\t\t * @member {ChessPiece}\n\t\t */\n\t\tthis.defaultPiece = null;\n\n\t\t/**\n\t\t * Object that contains the tracked statistics\n\t\t * @member {Object}\n\t\t */\n\t\tthis.stats = {};\n\n\t\tthis.initStats();\n\t}\n\n\t/**\n\t * Places a piece on this tile. Should only be called at board init.\n\t * @private\n\t * @param {ChessPiece} piece The piece that is on this square by default.\n\t */\n\tinitPiece(piece) {\n\t\tthis.piece = piece;\n\t\tthis.defaultPiece = piece;\n\t}\n\n\t/**\n\t * Sets the currently active piece of this square to the default piece.\n\t * @private\n\t */\n\tresetPiece() {\n\t\tthis.piece = this.defaultPiece;\n\t}\n\n\t/**\n\t * Updates the statistics of this tile.\n\t * @private\n\t */\n\tupdateOccupationStats() {\n\t\t// this.stats.cntHasPiece[this.piece.color] is slow for some reason, so use if\n\t\tif (this.piece.color === 'white') {\n\t\t\tthis.stats.cntHasPiece.white += 1;\n\t\t} else {\n\t\t\tthis.stats.cntHasPiece.black += 1;\n\t\t}\n\n\t\t// only non-promoted pieces are counted\n\t\tif (this.piece.name.length !== 1) {\n\t\t\tthis.stats.at[this.piece.defaultPos[0]][\n\t\t\t\tthis.piece.defaultPos[1]\n\t\t\t].wasOnTile += 1;\n\t\t}\n\t}\n\n\tupdateDeadCount() {\n\t\tthis.stats.cntTakenPieces += 1;\n\t}\n\n\t/**\n\t * Inits the statistics array. Is called by the constructor.\n\t * @private\n\t */\n\tinitStats() {\n\t\tthis.stats.cntHasPiece = { white: 0, black: 0 };\n\t\tthis.stats.cntTakenPieces = 0;\n\n\t\tthis.stats.at = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = { wasOnTile: 0 };\n\t\t\t}\n\t\t\tthis.stats.at[row] = currRow;\n\t\t}\n\t}\n}\n\nexport default ChessTile;\n","import ChessTile from './ChessTile';\nimport ChessPiece from './ChessPiece';\n\nconst pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\nconst pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n/** Class that contains the board status and tracks statistics. */\nclass ChessBoard {\n\t/** Creates a new 8x8 Chessboard out of 64 {@link ChessTile}s and 32 {@link ChessPiece}s */\n\tconstructor(cfg = {}) {\n\t\t/**\n\t\t * Tracks number of moves and games\n\t\t * @member {Object}\n\t\t */\n\t\tthis.stats = {\n\t\t\tcntMoves: 0,\n\t\t\tcntGames: 0\n\t\t};\n\n\t\tthis.cfg = {};\n\t\tthis.setConfig(cfg);\n\n\t\t/**\n\t\t * Contains all pieces on the board\n\t\t * @member {ChessPiece[]}\n\t\t */\n\t\tthis.pieces = [];\n\n\t\t/**\n\t\t * 8x8 array of {@link ChessTile}s\n\t\t * @member {Array[]}\n\t\t */\n\t\tthis.tiles = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = new ChessTile();\n\n\t\t\t\t// init pieces\n\t\t\t\tif (row === 0 || row === 7) {\n\t\t\t\t\tthis.pieces.push(\n\t\t\t\t\t\tnew ChessPiece(pieceTemplate[col], [row, col])\n\t\t\t\t\t);\n\t\t\t\t\tcurrRow[col].initPiece(this.pieces[this.pieces.length - 1]);\n\t\t\t\t} else if (row === 1 || row === 6) {\n\t\t\t\t\tthis.pieces.push(\n\t\t\t\t\t\tnew ChessPiece(pawnTemplate[col], [row, col])\n\t\t\t\t\t);\n\t\t\t\t\tcurrRow[col].initPiece(this.pieces[this.pieces.length - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.tiles[row] = currRow;\n\t\t}\n\t}\n\n\t/**\n\t * Moves a piece from source to target. Automatically handles the events 'move',\n\t *  'take', 'en passant', 'castle' and 'promote'.\n\t * Use this function instead of {@link ChessBoard#processMove} to input a move to the board!\n\t * @param {Object} moveData\n\t * @param {Object[]} moveData.moves - An array containing up to 2 moves in the\n\t *  syntax {from: [], to: []}\n\t * @param {Boolean} moveData.takes - True if the move takes a piece\n\t * @param {String} moveData.promotes - Type of promoted piece in case of pawn promotion, else null\n\t */\n\tmove(moveData) {\n\t\tif (moveData !== null) {\n\t\t\tthis.stats.cntMoves += 1;\n\n\t\t\tconst { moves } = moveData;\n\t\t\tconst { takes } = moveData;\n\t\t\tconst { promotes } = moveData;\n\n\t\t\t// move\n\t\t\tif (moves.length === 1) {\n\t\t\t\tconst move = moves[0];\n\n\t\t\t\tif (takes) {\n\t\t\t\t\tthis.processTakes(move);\n\t\t\t\t}\n\n\t\t\t\tthis.processMove(move);\n\n\t\t\t\tif (promotes !== null) {\n\t\t\t\t\tthis.promotePiece(move.to, promotes);\n\t\t\t\t}\n\t\t\t\t// castle\n\t\t\t} else {\n\t\t\t\tthis.processMove(moves[0]);\n\t\t\t\tthis.processMove(moves[1]);\n\t\t\t}\n\n\t\t\tif (this.cfg.logPieceHistory || this.cfg.logTileOccupation) {\n\t\t\t\tthis.updateTileStats();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles the 'takes' processing commanded by {@link ChessBoard#move}.\n\t * Don't call this function directly, use {@link ChessBoard#move} to input a move!\n\t * @private\n\t * @param {Object} move\n\t * @param {Number[]} move.from - Coordinates of start tile\n\t * @param {Number[]} move.to - Coordinates of target tile\n\t */\n\tprocessTakes(move) {\n\t\tconst { from } = move;\n\t\tconst { to } = move;\n\t\tlet offset = 0;\n\n\t\t// en passant\n\t\tif (this.tiles[to[0]][to[1]].piece === null) {\n\t\t\toffset =\n\t\t\t\tthis.tiles[from[0]][from[1]].piece.color === 'white' ? 1 : -1;\n\t\t}\n\t\tconst toPiece = this.tiles[to[0] + offset][to[1]].piece;\n\t\tconst fromPiece = this.tiles[from[0]][from[1]].piece;\n\n\t\ttoPiece.killPiece(fromPiece);\n\t\tfromPiece.killedPiece(toPiece);\n\n\t\tthis.tiles[to[0] + offset][to[1]].piece = null;\n\t\tthis.tiles[to[0] + offset][to[1]].updateDeadCount();\n\t}\n\n\t/**\n\t * Handles the 'move' processing commanded by {@link ChessBoard#move}.\n\t * Don't call this function directly, use {@link ChessBoard#move} to input a move!\n\t * @private\n\t * @param {Object} move\n\t * @param {Number[]} move.from - Coordinates of start tile\n\t * @param {Number[]} move.to - Coordinates of target tile\n\t */\n\tprocessMove(move) {\n\t\tconst { from } = move;\n\t\tconst { to } = move;\n\n\t\tthis.tiles[to[0]][to[1]].piece = this.tiles[from[0]][from[1]].piece;\n\t\tthis.tiles[to[0]][to[1]].piece.updatePosition(to);\n\t\tthis.tiles[from[0]][from[1]].piece = null;\n\t}\n\n\t/** Resets the board to the default state: removes promoted pieces and puts the standard\n\t *  pieces back to their starting positions.\n\t *\n\t *  Does not reset the stats recorded. If you wish to reset the stats,\n\t *  call {@link ChessBoard#resetStats}. */\n\treset() {\n\t\tthis.stats.cntGames += 1;\n\t\t// reset tiles and pieces to default\n\t\tfor (let i = 0; i < this.pieces.length; i += 1) {\n\t\t\tconst piece = this.pieces[i];\n\t\t\tthis.tiles[piece.pos[0]][piece.pos[1]].resetPiece();\n\t\t\tthis.tiles[piece.defaultPos[0]][piece.defaultPos[1]].resetPiece();\n\t\t\tpiece.reset();\n\t\t}\n\n\t\t// remove promoted pieces\n\t\tthis.pieces = this.pieces.slice(0, 32);\n\t}\n\n\t/** Resets the stats recorded. */\n\tresetStats() {\n\t\t// reset the tiles\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tthis.tiles[row][col].initStats();\n\t\t\t}\n\t\t}\n\n\t\t// reset the pieces to default\n\t\tfor (let i = 0; i < this.pieces.length; i += 1) {\n\t\t\tthis.pieces[i].initStats();\n\t\t}\n\n\t\tthis.stats.cntMoves = 0;\n\t\tthis.stats.cntGames = 0;\n\t}\n\n\t/**\n\t * Promotes a pawn to a piece.\n\t * @private\n\t * @param {Number[]} coords An array containing the row and column of the pawn to be promoted.\n\t * @param {String} pieceType Target piece type in SAN notation ('N', 'B', 'Q', 'R').\n\t */\n\tpromotePiece(coords, pieceType) {\n\t\t// change alive directly instead of killPiece to not update stats\n\t\tthis.tiles[coords[0]][coords[1]].piece.alive = false;\n\t\tthis.tiles[coords[0]][coords[1]].piece = null;\n\n\t\tthis.pieces.push(\n\t\t\tnew ChessPiece(pieceType, [coords[0], coords[1]], true)\n\t\t);\n\t\tthis.tiles[coords[0]][coords[1]].piece = this.pieces[\n\t\t\tthis.pieces.length - 1\n\t\t];\n\t}\n\n\t/** Prints the current board position to the console. */\n\tprintPosition() {\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst rowArray = [];\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tconst { piece } = this.tiles[row][col];\n\t\t\t\tif (piece !== null) {\n\t\t\t\t\trowArray.push(piece.name);\n\t\t\t\t} else {\n\t\t\t\t\trowArray.push('..');\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(rowArray);\n\t\t}\n\t}\n\n\tsetConfig(config) {\n\t\tthis.cfg.logPieceHistory = Object.prototype.hasOwnProperty.call(\n\t\t\tconfig,\n\t\t\t'logPieceHistory'\n\t\t)\n\t\t\t? config.logPieceHistory\n\t\t\t: false;\n\t\tthis.cfg.logTileOccupation = Object.prototype.hasOwnProperty.call(\n\t\t\tconfig,\n\t\t\t'logTileOccupation'\n\t\t)\n\t\t\t? config.logTileOccupation\n\t\t\t: true;\n\t}\n\n\t/** Is called after each {@link ChessBoard#move} to record the stats for the ChessTiles.\n\t * Only every tile, that has a piece on it, is updated.\n\t * @private\n\t */\n\tupdateTileStats() {\n\t\tfor (let i = 0; i < 32; i += 1) {\n\t\t\tif (this.pieces[i].alive) {\n\t\t\t\tif (this.cfg.logTileOccupation) {\n\t\t\t\t\tthis.tiles[this.pieces[i].pos[0]][\n\t\t\t\t\t\tthis.pieces[i].pos[1]\n\t\t\t\t\t].updateOccupationStats();\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tthis.cfg.logPieceHistory &&\n\t\t\t\t\t((this.stats.cntMoves % 2 === 0 &&\n\t\t\t\t\t\tthis.pieces[i].color === 'black') ||\n\t\t\t\t\t\t(this.stats.cntMoves % 2 === 1 &&\n\t\t\t\t\t\t\tthis.pieces[i].color === 'white'))\n\t\t\t\t) {\n\t\t\t\t\tthis.pieces[i].updateHistory();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport default ChessBoard;\n","import ChessBoard from './ChessBoard';\n\nconst LineByLineReader = require('line-by-line');\nconst EventEmitter = require('events');\n\nconst files = 'abcdefgh';\n\n/**\n * Class that processes games.\n */\nclass GameProcessor extends EventEmitter {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.board = new ChessBoard();\n\t\tthis.activePlayer = 0;\n\t}\n\n\tstatic checkConfig(config) {\n\t\tconst cfg = {};\n\t\tcfg.hasFilter = Object.prototype.hasOwnProperty.call(config, 'filter');\n\t\tcfg.filter = cfg.hasFilter ? config.filter : () => true;\n\n\t\tcfg.cntGames = Object.prototype.hasOwnProperty.call(config, 'cntGames')\n\t\t\t? config.cntGames\n\t\t\t: Infinity;\n\n\t\tcfg.stats = Object.prototype.hasOwnProperty.call(config, 'stats')\n\t\t\t? config.stats\n\t\t\t: {};\n\n\t\t// TODO: currently without function\n\t\tcfg.split = Object.prototype.hasOwnProperty.call(config, 'split')\n\t\t\t? config.split\n\t\t\t: false;\n\n\t\treturn cfg;\n\t}\n\n\tprocessPGN(path, config, refreshRate) {\n\t\tconst cfg = GameProcessor.checkConfig(config);\n\n\t\tthis.board.setConfig(cfg.stats);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst lr = new LineByLineReader(path, { skipEmptyLines: true });\n\t\t\tlet game = {};\n\n\t\t\t// process current line\n\t\t\tconst processLine = (line) => {\n\t\t\t\t// data tag\n\t\t\t\tif (line.startsWith('[') && cfg.hasFilter) {\n\t\t\t\t\tconst key = line.match(/\\[(.*?)\\s/)[1];\n\t\t\t\t\tconst value = line.match(/\"(.*?)\"/)[1];\n\n\t\t\t\t\tgame[key] = value;\n\n\t\t\t\t\t// moves\n\t\t\t\t} else if (line.startsWith('1')) {\n\t\t\t\t\tgame.moves = line\n\t\t\t\t\t\t.replace(/\\{(.*?)\\}\\s/g, '')\n\t\t\t\t\t\t.replace(/\\d+\\.+\\s/g, '')\n\t\t\t\t\t\t.replace(' *', '')\n\t\t\t\t\t\t.split(' ');\n\n\t\t\t\t\tif (cfg.filter(game) || !cfg.hasFilter) {\n\t\t\t\t\t\tthis.processGame(game);\n\t\t\t\t\t}\n\n\t\t\t\t\t// emit event\n\t\t\t\t\tif (this.board.stats.cntGames % refreshRate === 0) {\n\t\t\t\t\t\tthis.emit('status', this.board.stats.cntGames);\n\t\t\t\t\t}\n\n\t\t\t\t\tgame = {};\n\t\t\t\t}\n\t\t\t\tif (this.board.stats.cntGames >= cfg.cntGames) {\n\t\t\t\t\tlr.close();\n\t\t\t\t\tlr.end();\n\t\t\t\t} else {\n\t\t\t\t\tlr.resume();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlr.on('error', (err) => {\n\t\t\t\tconsole.log(err);\n\t\t\t\treject();\n\t\t\t});\n\n\t\t\tlr.on('line', (line) => {\n\t\t\t\t// pause emitting of lines...\n\t\t\t\tlr.pause();\n\n\t\t\t\tprocessLine(line);\n\t\t\t});\n\n\t\t\tlr.on('end', () => {\n\t\t\t\tconsole.log('Read entire file.');\n\t\t\t\tresolve(this.board);\n\t\t\t});\n\t\t});\n\t}\n\n\tprocessGame(game) {\n\t\tconst { moves } = game;\n\n\t\tfor (let i = 0; i < moves.length; i += 1) {\n\t\t\tthis.activePlayer = i % 2;\n\t\t\tconst moveData = this.parseMove(moves[i]);\n\t\t\tthis.board.move(moveData);\n\t\t}\n\t\tthis.board.reset();\n\t}\n\n\treset() {\n\t\tthis.board.reset();\n\t\tthis.board.resetStats();\n\t\tthis.activePlayer = 0;\n\t}\n\n\t/**\n\t * @typedef {Object} MoveData\n\t * @property {Object[]} moves - Array of {from: [], to: []} objects\n\t * @property {Boolean} takes - Move takes a piece true/false\n\t * @property {String} promotes - Piece type in case of pawn promotion else null\n\t */\n\n\t/**\n\t * Parses a move in string format to board coordinates. Wrapper function for\n\t *  the different move algorithms.\n\t * @param {string} rawMove The move to be parsed, e.g. 'Ne5+'.\n\t * @returns {MoveData}\n\t */\n\tparseMove(rawMove) {\n\t\tconst token = rawMove.substring(0, 1);\n\t\tlet moveData = {};\n\n\t\tconst move = GameProcessor.preProcess(rawMove);\n\n\t\t// game end on '1-0', '0-1' or '1/2-1/2' (check for digit as first char)\n\t\tif (token.match(/\\d/) !== null) {\n\t\t\tmoveData = null;\n\t\t} else if (token.toLowerCase() === token) {\n\t\t\tmoveData = this.pawnMove(move);\n\t\t} else if (token !== 'O') {\n\t\t\tmoveData = this.pieceMove(move);\n\t\t} else {\n\t\t\tmoveData = this.castle(move);\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Returns the board coordinates for the move if it is a pawn move.\n\t * @param {string} moveSan The move to be parsed, e.g. 'e5'.\n\t * @returns {MoveData}\n\t */\n\tpawnMove(moveSan) {\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\t\tconst direction = -2 * (this.activePlayer % 2) + 1;\n\t\tlet move = moveSan;\n\n\t\t// takes\n\t\tif (move.includes('x')) {\n\t\t\tmoveData.takes = true;\n\t\t\tmove = move.replace('x', '');\n\n\t\t\tto[0] = 8 - parseInt(move.substring(2, 3), 10);\n\t\t\tto[1] = files.indexOf(move.substring(1, 2));\n\t\t\tfrom[0] = to[0] + direction;\n\t\t\tfrom[1] = files.indexOf(move.substring(0, 1));\n\n\t\t\t// moves\n\t\t} else {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(0, 1));\n\n\t\t\tfrom[1] = tarCol;\n\t\t\tto[0] = tarRow;\n\t\t\tto[1] = tarCol;\n\t\t\tfor (let i = tarRow + direction; i < 8 && i >= 0; i += direction) {\n\t\t\t\tif (this.board.tiles[i][tarCol].piece !== null) {\n\t\t\t\t\tif (this.board.tiles[i][tarCol].piece.name.includes('P')) {\n\t\t\t\t\t\tfrom[0] = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmoveData.moves.push({ from, to });\n\n\t\t// promotes\n\t\tif (move.includes('=')) {\n\t\t\tmoveData.promotes = move.substring(move.length - 1, move.length);\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Returns the board coordinates for a piece (!= pawn) move.\n\t * @param {string} moveSan The move to be parsed, e.g. 'Be3'.\n\t * @returns {MoveData}\n\t */\n\tpieceMove(moveSan) {\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\t\tlet move = moveSan;\n\t\tconst token = move.substring(0, 1);\n\n\t\t// remove token\n\t\tmove = move.substring(1, move.length);\n\n\t\t// takes\n\t\tif (move.includes('x')) {\n\t\t\tmoveData.takes = true;\n\t\t\tmove = move.replace('x', '');\n\t\t}\n\n\t\t// e.g. Re3f5\n\t\tif (move.length === 4) {\n\t\t\tfrom[0] = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tfrom[1] = files.indexOf(move.substring(0, 1));\n\t\t\tto[0] = 8 - parseInt(move.substring(3, 4), 10);\n\t\t\tto[1] = files.indexOf(move.substring(2, 3));\n\t\t\tmoveData.moves.push({ from, to });\n\n\t\t\t// e.g. Ref3\n\t\t} else if (move.length === 3) {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(2, 3), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(1, 2));\n\t\t\tlet mustBeInRow = -1;\n\t\t\tlet mustBeInCol = -1;\n\n\t\t\t// file is specified\n\t\t\tif (files.indexOf(move.substring(0, 1)) >= 0) {\n\t\t\t\tmustBeInCol = files.indexOf(move.substring(0, 1));\n\n\t\t\t\t// rank is specified\n\t\t\t} else {\n\t\t\t\tmustBeInRow = 8 - parseInt(move.substring(0, 1), 10);\n\t\t\t}\n\t\t\tmoveData.moves.push(\n\t\t\t\tthis.findPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token)\n\t\t\t);\n\n\t\t\t// e.g. Rf3\n\t\t} else {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(0, 1));\n\t\t\tmoveData.moves.push(this.findPiece(tarRow, tarCol, -1, -1, token));\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Wrapper function for different piece search algorithms.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tlet move;\n\n\t\tif (token === 'R') {\n\t\t\tmove = this.findLine(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t} else if (token === 'B') {\n\t\t\tmove = this.findDiag(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t} else if (token === 'Q' || token === 'K') {\n\t\t\tmove = this.findDiag(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t\tif (move.from[0] === -1) {\n\t\t\t\tmove = this.findLine(\n\t\t\t\t\ttarRow,\n\t\t\t\t\ttarCol,\n\t\t\t\t\tmustBeInRow,\n\t\t\t\t\tmustBeInCol,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (token === 'N') {\n\t\t\tmove = this.findKnight(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t}\n\t\tif (move.from[0] === -1) {\n\t\t\tconsole.log(\n\t\t\t\t`Error: no piece for move ${token} to (${tarRow},${tarCol}) found!`\n\t\t\t);\n\t\t\tthis.board.printPosition();\n\t\t}\n\n\t\treturn move;\n\t}\n\n\t/**\n\t * Search algorithm to find a piece that can move diagonally.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindDiag(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -1; i <= 1; i += 2) {\n\t\t\tlet obstructed1 = false;\n\t\t\tlet obstructed2 = false;\n\t\t\tfor (let j = 1; j < 8; j += 1) {\n\t\t\t\tconst row1 = to[0] + i * j;\n\t\t\t\tconst col1 = to[1] + j;\n\t\t\t\tconst row2 = to[0] - i * j;\n\t\t\t\tconst col2 = to[1] - j;\n\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\t!obstructed1 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\t!obstructed2 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed2 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Search algorithm to find a piece that can move vertically/horizontally.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindLine(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -1; i <= 1; i += 2) {\n\t\t\tlet obstructed1 = false;\n\t\t\tlet obstructed2 = false;\n\t\t\tfor (let j = 1; j < 8; j += 1) {\n\t\t\t\tconst row1 = to[0];\n\t\t\t\tconst col1 = to[1] - i * j;\n\t\t\t\tconst row2 = to[0] - i * j;\n\t\t\t\tconst col2 = to[1];\n\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\t!obstructed1 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\t!obstructed2 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed2 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Search algorithm to find a matching knight.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindKnight(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -2; i <= 2; i += 4) {\n\t\t\tfor (let j = -1; j <= 1; j += 2) {\n\t\t\t\tconst row1 = to[0] + i;\n\t\t\t\tconst col1 = to[1] + j;\n\t\t\t\tconst row2 = to[0] + j;\n\t\t\t\tconst col2 = to[1] + i;\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Checks if the input move would be resulting with the king being in check.\n\t * @param {Number[]} from Coordinates of the source tile of the move that shall be checked.\n\t *  @param {Number[]} to Coordinates of the target tile of the move that shall be checked.\n\t * @returns {boolean} After the move, the king will be in check true/false.\n\t */\n\tcheckCheck(from, to) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst opColor = this.activePlayer % 2 ? 'white' : 'black';\n\t\tconst king = this.board.pieces[color === 'white' ? 28 : 4].pos;\n\t\tlet isInCheck = false;\n\n\t\t// if king move, no check is possible, exit function\n\t\tif (king[0] === from[0] && king[1] === from[1]) return false;\n\n\t\t// check if moving piece is on same line/diag as king, else exit\n\t\tconst diff = [];\n\t\tdiff[0] = from[0] - king[0];\n\t\tdiff[1] = from[1] - king[1];\n\t\tconst checkFor = [];\n\t\tif (diff[0] === 0 || diff[1] === 0) {\n\t\t\tcheckFor[0] = 'Q';\n\t\t\tcheckFor[1] = 'R';\n\t\t} else if (Math.abs(diff[0]) === Math.abs(diff[1])) {\n\t\t\tcheckFor[0] = 'Q';\n\t\t\tcheckFor[1] = 'B';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tif (diff[0] !== 0) diff[0] /= Math.abs(diff[0]);\n\t\tif (diff[1] !== 0) diff[1] /= Math.abs(diff[1]);\n\n\t\tconst srcTilePiece = this.board.tiles[from[0]][from[1]].piece;\n\t\tconst tarTilePiece = this.board.tiles[to[0]][to[1]].piece;\n\n\t\t// premove and check if check\n\t\tthis.board.tiles[from[0]][from[1]].piece = null;\n\t\tthis.board.tiles[to[0]][to[1]].piece = srcTilePiece;\n\n\t\t// check for check\n\t\tlet obstructed = false;\n\t\tfor (let j = 1; j < 8 && !isInCheck && !obstructed; j += 1) {\n\t\t\tconst row = king[0] + j * diff[0];\n\t\t\tconst col = king[1] + j * diff[1];\n\n\t\t\tif (\n\t\t\t\trow >= 0 &&\n\t\t\t\trow < 8 &&\n\t\t\t\tcol >= 0 &&\n\t\t\t\tcol < 8 &&\n\t\t\t\tthis.board.tiles[row][col].piece !== null\n\t\t\t) {\n\t\t\t\tconst { piece } = this.board.tiles[row][col];\n\t\t\t\tif (\n\t\t\t\t\t(piece.name.includes(checkFor[0]) ||\n\t\t\t\t\t\tpiece.name.includes(checkFor[1])) &&\n\t\t\t\t\tpiece.color === opColor\n\t\t\t\t) {\n\t\t\t\t\tisInCheck = true;\n\t\t\t\t} else {\n\t\t\t\t\tobstructed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.board.tiles[from[0]][from[1]].piece = srcTilePiece;\n\t\tthis.board.tiles[to[0]][to[1]].piece = tarTilePiece;\n\n\t\treturn isInCheck;\n\t}\n\n\t/**\n\t * Returns the board coordinates for castling.\n\t * @param {string} move The move to be parsed, e.g. 'O-O'.\n\t * @returns {MoveData.moves}\n\t */\n\tcastle(move) {\n\t\tconst row = this.activePlayer % 2 ? 0 : 7;\n\t\tconst from1 = [];\n\t\tconst from2 = [];\n\t\tconst to1 = [];\n\t\tconst to2 = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\n\t\t// O-O\n\t\tif (move.length === 3) {\n\t\t\tfrom1[0] = row;\n\t\t\tfrom1[1] = 4;\n\t\t\tto1[0] = row;\n\t\t\tto1[1] = 6;\n\t\t\tfrom2[0] = row;\n\t\t\tfrom2[1] = 7;\n\t\t\tto2[0] = row;\n\t\t\tto2[1] = 5;\n\n\t\t\t// O-O-O\n\t\t} else {\n\t\t\tfrom1[0] = row;\n\t\t\tfrom1[1] = 4;\n\t\t\tto1[0] = row;\n\t\t\tto1[1] = 2;\n\t\t\tfrom2[0] = row;\n\t\t\tfrom2[1] = 0;\n\t\t\tto2[0] = row;\n\t\t\tto2[1] = 3;\n\t\t}\n\t\tmoveData.moves.push({ from: from1, to: to1 });\n\t\tmoveData.moves.push({ from: from2, to: to2 });\n\t\treturn moveData;\n\t}\n\n\tstatic algebraicToCoords(square) {\n\t\tconst coords = [];\n\t\tconst temp = square.split('');\n\t\tcoords.push(8 - temp[1]);\n\t\tcoords.push(files.indexOf(temp[0]));\n\n\t\treturn coords;\n\t}\n\n\tstatic coordsToAlgebraic(coords) {\n\t\tlet name = files[coords[1]];\n\t\tname += 8 - coords[0];\n\n\t\treturn name;\n\t}\n\n\t/**\n\t * Removes special characters like '#', '+', '?' and '!'\n\t * @param {string} move The move to be cleaned up\n\t * @returns {string} The input string with removed special characters\n\t */\n\tstatic preProcess(move) {\n\t\treturn move.replace(/#|\\+|\\?|!/g, '');\n\t}\n}\n\nexport default GameProcessor;\n","import GameProcessor from './GameProcessor';\n\nconst { performance } = require('perf_hooks');\n\nconst fs = require('fs');\n\nconst pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\nconst pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n/**\n * @typedef {Object} cfg\n * @property {Function} filter - Descr\n * @property {Number} cntGames - Descr\n * @property {Boolean} split - Descr\n */\n\n/** Main class for batch processing and generating heat maps */\nclass Chessalyzer {\n\tconstructor() {\n\t\t/**\n\t\t * Contains the tracked data of the processed PGN files. Has two different banks for\n\t\t * heat map comparison. Each object contains the following keys:\n\t\t * <ul>\n\t\t * <li>data: {cntMoves, cntGames}. Information about the count of processed moves and games</li>\n\t\t * <li>tiles: 8x8 array of {@link ChessTile}s.</li>\n\t\t * </ul>\n\t\t * @member {Object[]}\n\t\t */\n\t\tthis.dataStore = new Array(2);\n\t\t/**\n\t\t * Does the analysis part\n\t\t * @private\n\t\t * @member {GameProcessor}\n\t\t */\n\t\tthis.gameProcessor = new GameProcessor();\n\t}\n\n\t/**\n\t * Starts the batch processing for the selected file\n\t * @param {String} path - Path to the PGN file that should be analyzed\n\t * @param {Object} [cfg = {}]\n\t * @param {Function} [cfg.filter = ()=>true] - Filter function for selecting games\n\t * @param {Number} [cfg.cntGames = Infinite ] - Max amount of games to process\n\t * @param {Object} cfg.stats - Configuration for data aquisition\n\t * @param {Boolean} [cfg.stats.logPieceHistory = false] - Option for logging the position\n\t * of every piece.\n\t * @param {Boolean} [cfg.stats.logTileOccupation = true] - Option for logging the piece\n\t * on every tile after every move.\n\t * @param {Number} [bank = 0] - The data bank the results shall be saved to\n\t * @param {Number} [refreshRate = 250] - Defines how often the current status of the\n\t *  analysis shall be exposed. Every number of processed games an event is emitted\n\t *  containing the current number of processed games. The event can be handled via\n\t *  \"chessalyzer.gameProcessor.on('status', function(gameCnt) {// do handling here});\",\n\t *  e.g. to update an UI.\n\t * @returns {Promise} Promise that contains the number of processed games when finished\n\t */\n\tstartBatch(path, cfg = {}, bank = 0, refreshRate = 250) {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst t0 = performance.now();\n\t\t\tthis.gameProcessor\n\t\t\t\t.processPGN(path, cfg, refreshRate)\n\t\t\t\t.then((board) => {\n\t\t\t\t\tconst dataset = {};\n\t\t\t\t\tdataset.stats = board.stats;\n\t\t\t\t\tdataset.tiles = board.tiles;\n\t\t\t\t\tthis.dataStore[bank] = JSON.parse(JSON.stringify(dataset));\n\t\t\t\t\tconst t1 = performance.now();\n\t\t\t\t\tconst tdiff = Math.round(t1 - t0) / 1000;\n\t\t\t\t\tconst mps = Math.round(dataset.stats.cntMoves / tdiff);\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`${dataset.stats.cntGames} games (${\n\t\t\t\t\t\t\tdataset.stats.cntMoves\n\t\t\t\t\t\t} moves) processed in ${tdiff}s (${mps} moves/s)`\n\t\t\t\t\t);\n\t\t\t\t\tthis.gameProcessor.reset();\n\t\t\t\t\tresolve(this.dataStore[bank].stats.cntGames);\n\t\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Saves a completed batch run to a JSON file\n\t * @param {String} path - Path the data file shall be saved to\n\t * @param {Number} [bank = 0] - The data bank the data shall be taken from\n\t */\n\tsaveData(path, bank = 0) {\n\t\tfs.writeFile(path, JSON.stringify(this.dataStore[bank]), (err) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconsole.log('File has been created');\n\t\t});\n\t}\n\n\t/**\n\t * Loads the stats of a previous batch run (JSON) to a data bank\n\t * @param {String} path - Path the data file shall be loaded from\n\t * @param {Number} [bank = 0] - The data bank the data shall be loaded to.\n\t * @returns {Number} Count of loaded games\n\t */\n\tloadData(path, bank) {\n\t\tthis.dataStore[bank] = JSON.parse(fs.readFileSync(path, 'utf8'));\n\t\tconsole.log(`File '${path}' has been loaded to bank ${bank}.`);\n\t\treturn this.dataStore[bank].cntGames;\n\t}\n\n\t/**\n\t * Generates a heatmap out of the tracked data.\n\t * @param {Number} bank - The data bank the data shall be taken from\n\t * @param {String} square - The square the data shall be generated for. For example, if you\n\t * wanted to know how often a specific piece was on a specific tile, you would pass the\n\t * identifier of the tile to the function, e.g. \"a2\"\n\t * @param {Function} fun - The evaluation function that generates the heatmap out of the\n\t * saved data. This function gets passed the following arguments:\n\t * <ol>\n\t * <li>The complete data stored in the chosen bank. See the member description of the dataStore\n\t * member to see which data is available.</li>\n\t * <li>The coords of the tile passed as the 'square' argument.</li>\n\t * <li>The current coordinates of the tile the data should be generated for.\n\t * The function must return a Number with the heat map value for the square passed as the\n\t * third argument.</li>\n\t * <li>An optional data field, you passed for 'optData'</li>\n\t * </ol>\n\t * See ./src/exampleHeatmapConfig for examples of such a function.\n\t * @param {} optData - Optional data you may need in your eval function\n\t * @returns {Array} Array with 3 entries:\n\t * <ol>\n\t * <li>8x8 Array containing the heat map values for each tile</li>\n\t * <li>The minimum value in the heatmap.</li>\n\t * <li>The maximum value in the heatmap.</li>\n\t * </ol>\n\t */\n\tgenerateHeatmap(bank, square, fun, optData) {\n\t\tconst coords = GameProcessor.algebraicToCoords(square);\n\t\tconst map = [];\n\t\tlet max = 0;\n\t\tlet min = 1000000;\n\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tconst dataRow = new Array(8);\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tdataRow[j] = fun(this.dataStore[bank], coords, [i, j], optData);\n\t\t\t\tif (dataRow[j] > max) max = dataRow[j];\n\t\t\t\tif (dataRow[j] < min) min = dataRow[j];\n\t\t\t}\n\t\t\tmap.push(dataRow);\n\t\t}\n\n\t\treturn [map, min, max];\n\t}\n\n\t/**\n\t * Generates a comparison heatmap out of the tracked data. There needs to data in both\n\t * banks you pass as bank1 and bank2 params. The heatmap for both banks are calculated\n\t * and then the relative differences between both banks are calculated. For example,\n\t * if the heatmap value for \"a1\" of bank1 is 10 and the value of bank2 is 5, the returned\n\t * value for \"a1\" would be 100% ([[10/5] -1] *100).\n\t * @param {String} square - The square the data shall be generated for.\n\t * @param {Function} fun - The evaluation function that generates the heatmap out of the\n\t * saved data. See {@link Chessalyzer#generateHeatmap} for a more detailed description.\n\t * @param {Number} [bank1 = 0] - Bank number of dataset 1\n\t * @param {Number} [bank2 = 1] - Bank number of dataset 2\n\t * @param {} optData - Optional data you may need in your eval function\n\t * @returns {Array} Array with 3 entries:\n\t * <ol>\n\t * <li>8x8 Array containing the heat map values for each tile</li>\n\t * <li>The minimum value in the heatmap.</li>\n\t * <li>The maximum value in the heatmap.</li>\n\t * </ol>\n\t */\n\tgenerateComparisonHeatmap(square, fun, bank1 = 0, bank2 = 1, optData) {\n\t\tconst map = [];\n\t\tlet max = 0;\n\t\tlet min = 100000;\n\n\t\t// comparison heatmap\n\t\tconst data0 = this.generateHeatmap(bank1, square, fun, optData);\n\t\tconst data1 = this.generateHeatmap(bank2, square, fun, optData);\n\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tconst dataRow = new Array(8);\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tconst a = data0[0][i][j];\n\t\t\t\tconst b = data1[0][i][j];\n\t\t\t\tif (a === 0 || b === 0) dataRow[j] = 0;\n\t\t\t\telse dataRow[j] = (a >= b ? a / b - 1 : -b / a + 1) * 100;\n\n\t\t\t\tif (dataRow[j] > max) max = dataRow[j];\n\t\t\t\tif (dataRow[j] < min) min = dataRow[j];\n\t\t\t}\n\t\t\tmap.push(dataRow);\n\t\t}\n\n\t\treturn [map, min, max];\n\t}\n\n\tstatic generateList(map) {\n\t\tconst list = [];\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tlet val = map[i][j];\n\t\t\t\tval = val.toFixed(2);\n\t\t\t\tif (Math.abs(val) > 0.001) {\n\t\t\t\t\tif (i === 0) list.push([`b${pieceTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 1) list.push([`b${pawnTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 6) list.push([`w${pawnTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 7) list.push([`w${pieceTemplate[j]}`, val]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlist.sort((a, b) => b[1] - a[1]);\n\t\treturn list;\n\t}\n}\n\nexport default Chessalyzer;\n","/* eslint-disable */\nimport Chessalyzer from './Chessalyzer';\n\nexport default Chessalyzer;\n"],"sourceRoot":""}