{"version":3,"sources":["webpack://chessalyzer/webpack/universalModuleDefinition","webpack://chessalyzer/webpack/bootstrap","webpack://chessalyzer/external \"fs\"","webpack://chessalyzer/external \"perf_hooks\"","webpack://chessalyzer/external \"events\"","webpack://chessalyzer/external \"line-by-line\"","webpack://chessalyzer/./src/ChessPiece.js","webpack://chessalyzer/./src/ChessTile.js","webpack://chessalyzer/./src/ChessBoard.js","webpack://chessalyzer/./src/GameProcessor.js","webpack://chessalyzer/./src/Chessalyzer.js","webpack://chessalyzer/./src/index.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","ChessPiece","piece","pos","promoted","arguments","length","undefined","_classCallCheck","this","defaultPos","color","stats","data","cntMoved","cntWasKilled","cntHasKilled","alive","initStats","logHistory","history","push","maxHistory","movedTo","killedByPiece","killedBy","killedPiece","killed","Array","row","currRow","col","ChessTile","defaultPiece","cntHasPiece","white","black","wasOnTile","_ChessTile","_interopRequireDefault","_ChessPiece","pawnTemplate","pieceTemplate","ChessBoard","cntMoves","cntGames","pieces","tiles","default","initPiece","moveData","moves","takes","promotes","move","to","from","processMove","promotePiece","updateTileStats","toPiece","fromPiece","killPiece","updatePosition","reset","slice","resetPiece","coords","pieceType","rowArray","console","log","updateStats","_ChessBoard","LineByLineReader","EventEmitter","files","GameProcessor","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","board","activePlayer","path","config","refreshRate","_this2","cfg","checkConfig","Promise","resolve","reject","lr","skipEmptyLines","game","on","err","line","pause","startsWith","hasFilter","match","filter","replace","processGame","emit","close","end","resume","processLine","split","parseMove","resetStats","rawMove","token","substring","preProcess","toLowerCase","pawnMove","castle","pieceMove","moveSan","direction","includes","parseInt","indexOf","tarRow","tarCol","mustBeInRow","mustBeInCol","findPiece","findLine","findDiag","findKnight","concat","printPosition","obstructed1","obstructed2","j","row1","col1","row2","col2","checkCheck","opColor","king","isInCheck","diff","checkFor","Math","abs","srcTilePiece","tarTilePiece","obstructed","from1","from2","to1","to2","Infinity","square","temp","_GameProcessor","performance","fs","Chessalyzer","dataStore","gameProcessor","bank","t0","now","processPGN","then","dataset","JSON","parse","stringify","t1","tdiff","round","mps","writeFile","error","readFileSync","fun","algebraicToCoords","map","max","min","dataRow","bank1","bank2","data0","generateHeatmap","data1","a","b","list","val","toFixed","sort"],"mappings":"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","file":"chessalyzer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"chessalyzer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"chessalyzer\"] = factory();\n\telse\n\t\troot[\"chessalyzer\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","module.exports = require(\"fs\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"events\");","module.exports = require(\"line-by-line\");","/**\n * Class that represents a chess piece and tracks statistics.\n */\nclass ChessPiece {\n\t/**\n\t * Creates a new ChessPiece.\n\t * @param {String} piece The name of the piece, e.g. 'Pd' for a D pawn.\n\t * @param {Number[]} pos Row and column the piece is on at start.\n\t * @param {Boolean} [promoted=false] Denotes if this piece is created by pawn promotion.\n\t */\n\tconstructor(piece, pos, promoted = false) {\n\t\t/**\n\t\t * Name of the piece, e.g 'Pb' for the b pawn\n\t\t * @member {String}\n\t\t */\n\t\tthis.name = piece; // piece type\n\n\t\t/**\n\t\t * Current position of this piece: [row,col], with [0,0] being the top left square\n\t\t * @member {Number[]}\n\t\t */\n\t\tthis.pos = pos; // current position in [row, col] notation\n\n\t\t/**\n\t\t * Starting position of this piece: [row,col], with [0,0] being the top left square\n\t\t * @member {Number[]}\n\t\t */\n\t\tthis.defaultPos = pos; // starting position of this piece\n\n\t\t/**\n\t\t * Color of this piece: 'black' or 'white'\n\t\t * @member {String}\n\t\t */\n\t\tthis.color = '';\n\t\tif (promoted) {\n\t\t\tthis.color = this.defaultPos[0] <= 1 ? 'white' : 'black'; // color of piece: 0 white, 1 black\n\t\t} else {\n\t\t\tthis.color = this.defaultPos[0] <= 1 ? 'black' : 'white'; // color of piece: 0 white, 1 black\n\t\t}\n\n\t\t/**\n\t\t * 8x8 array that contains data for each tile/piece { movedTo: 0, killedBy: 0, killed: 0 }.\n\t\t * The data for pieces is stored on the tile the piece starts the game. For example, if you\n\t\t * are looking for data on how the piece interacted with the black queen, the data is stored at\n\t\t * [0,3].\n\t\t * @member {Array}\n\t\t */\n\t\tthis.stats = null;\n\n\t\t/**\n\t\t * Other data about this piece: { cntMoved, cntWasKilled, cntHasKilled }\n\t\t * @member {Object}\n\t\t */\n\t\tthis.data = { cntMoved: 0, cntWasKilled: 0, cntHasKilled: 0 };\n\n\t\t/**\n\t\t * Is this piece alive?\n\t\t * @member {Object}\n\t\t */\n\t\tthis.alive = true; // piece alive?\n\n\t\tthis.initStats();\n\n\t\t// option to track the move history of each piece\n\t\t// currently unused, costs a lot of performance\n\t\tthis.logHistory = false;\n\t\tthis.history = []; // position history\n\t\tthis.history.push(pos);\n\t\tthis.maxHistory = 2000; // max length of history array\n\t}\n\n\t/**\n\t * Resets this piece to its default position and denotes a new game in the move history tracker.\n\t */\n\treset() {\n\t\tif (this.logHistory && this.history.length < this.maxHistory) {\n\t\t\tthis.history.push(null);\n\t\t\tthis.history.push(this.defaultPos);\n\t\t}\n\n\t\tthis.pos = this.defaultPos;\n\t\tthis.alive = true;\n\t}\n\n\t/**\n\t * Moves this piece to a new position and updates move statistics.\n\t * @param {Number[]} pos Target row and column of the tile the piece shall move to.\n\t */\n\tupdatePosition(pos) {\n\t\tthis.data.cntMoved += 1;\n\t\tthis.pos = pos;\n\t\tif (this.logHistory && this.history.length < this.maxHistory) {\n\t\t\tthis.history.push(pos);\n\t\t}\n\t\tthis.stats[pos[0]][pos[1]].movedTo += 1;\n\t}\n\n\t/**\n\t * Marks this piece as taken and updates the statistics of the piece it was taken by.\n\t * @param {ChessPiece} killedBy Piece this piece was taken by.\n\t */\n\tkillPiece(killedByPiece) {\n\t\tthis.alive = false;\n\t\tthis.data.cntWasKilled += 1;\n\n\t\t// if killer is not promoted pawn...\n\t\tif (!(killedByPiece.name.length === 1 || this.name.length === 1)) {\n\t\t\t// update killedBy of this piece\n\t\t\tthis.stats[killedByPiece.defaultPos[0]][\n\t\t\t\tkilledByPiece.defaultPos[1]\n\t\t\t].killedBy += 1;\n\t\t}\n\t}\n\n\tkilledPiece(killedPiece) {\n\t\tthis.data.cntHasKilled += 1;\n\n\t\t// if killer is not promoted pawn...\n\t\tif (!(killedPiece.name.length === 1 || this.name.length === 1)) {\n\t\t\t// update killed stat of killer piece\n\t\t\tthis.stats[killedPiece.defaultPos[0]][\n\t\t\t\tkilledPiece.defaultPos[1]\n\t\t\t].killed += 1;\n\t\t}\n\t}\n\n\t/**\n\t * Inits the statistics array of this piece.\n\t */\n\tinitStats() {\n\t\tthis.alive = true;\n\t\tthis.data = { cntMoved: 0, cntWasKilled: 0, cntHasKilled: 0 };\n\t\tthis.stats = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = { movedTo: 0, killedBy: 0, killed: 0 };\n\t\t\t}\n\t\t\tthis.stats[row] = currRow;\n\t\t}\n\t}\n}\n\nexport default ChessPiece;\n","/** Class that represents a single Tile. Tracks statistics for itself. */\nclass ChessTile {\n\t/** Creates a new Tile. */\n\tconstructor() {\n\t\t/**\n\t\t * Piece that is currently on this tile.\n\t\t * @member {ChessPiece}\n\t\t */\n\t\tthis.piece = null;\n\n\t\t/**\n\t\t * Piece that is on this tile at start of game.\n\t\t * @member {ChessPiece}\n\t\t */\n\t\tthis.defaultPiece = null;\n\n\t\t/**\n\t\t * 8x8 array that contains data for this tile. {wasOnTile: Number}\n\t\t * @member {Array}\n\t\t */\n\t\tthis.stats = null;\n\n\t\t/**\n\t\t * Counts how often a piece was on the tile { white, black }\n\t\t * @member {Object}\n\t\t */\n\t\tthis.cntHasPiece = { white: 0, black: 0 };\n\n\t\tthis.initStats();\n\t}\n\n\t/**\n\t * Places a piece on this tile. Should only be called at board init.\n\t * @param {ChessPiece} piece The piece that is on this square by default.\n\t */\n\tinitPiece(piece) {\n\t\tthis.piece = piece;\n\t\tthis.defaultPiece = piece;\n\t}\n\n\t/**\n\t * Sets the currently active piece of this square to the default piece.\n\t */\n\tresetPiece() {\n\t\tthis.piece = this.defaultPiece;\n\t}\n\n\t/**\n\t * Updates the statistics of this tile.\n\t */\n\tupdateStats() {\n\t\t// this.data.cntHasPiece[this.piece.color] is slow for some reason, so use if\n\t\tif (this.piece.color === 'white') {\n\t\t\tthis.cntHasPiece.white += 1;\n\t\t} else {\n\t\t\tthis.cntHasPiece.black += 1;\n\t\t}\n\n\t\t// only non-promoted pieces are counted\n\t\tif (this.piece.name.length !== 1) {\n\t\t\tthis.stats[this.piece.defaultPos[0]][\n\t\t\t\tthis.piece.defaultPos[1]\n\t\t\t].wasOnTile += 1;\n\t\t}\n\t}\n\n\t/**\n\t * Inits the statistics array. Is called by the constructor.\n\t */\n\tinitStats() {\n\t\tthis.cntHasPiece = { white: 0, black: 0 };\n\t\tthis.stats = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = { wasOnTile: 0 };\n\t\t\t}\n\t\t\tthis.stats[row] = currRow;\n\t\t}\n\t}\n}\n\nexport default ChessTile;\n","import ChessTile from './ChessTile';\nimport ChessPiece from './ChessPiece';\n\nconst pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\nconst pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n/** Class that contains the board status and tracks statistics. */\nclass ChessBoard {\n\t/** Creates a new 8x8 Chessboard out of 64 {@link ChessTile}s and 32 {@link ChessPiece}s */\n\tconstructor() {\n\t\t/**\n\t\t * Tracks number of moves and games: { cntMoves, cntGames }\n\t\t * @member {Object}\n\t\t */\n\t\tthis.data = {\n\t\t\tcntMoves: 0,\n\t\t\tcntGames: 0\n\t\t};\n\n\t\t/**\n\t\t * Contains all pieces on the board\n\t\t * @member {ChessPiece[]}\n\t\t */\n\t\tthis.pieces = [];\n\n\t\t/**\n\t\t * 8x8 array of {@link ChessTile}s\n\t\t * @member {Array[]}\n\t\t */\n\t\tthis.tiles = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = new ChessTile();\n\n\t\t\t\t// init pieces\n\t\t\t\tif (row === 0 || row === 7) {\n\t\t\t\t\tthis.pieces.push(\n\t\t\t\t\t\tnew ChessPiece(pieceTemplate[col], [row, col])\n\t\t\t\t\t);\n\t\t\t\t\tcurrRow[col].initPiece(this.pieces[this.pieces.length - 1]);\n\t\t\t\t} else if (row === 1 || row === 6) {\n\t\t\t\t\tthis.pieces.push(\n\t\t\t\t\t\tnew ChessPiece(pawnTemplate[col], [row, col])\n\t\t\t\t\t);\n\t\t\t\t\tcurrRow[col].initPiece(this.pieces[this.pieces.length - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.tiles[row] = currRow;\n\t\t}\n\t}\n\n\t/**\n\t * Moves a piece from source to target. Automatically handles the events 'move',\n\t *  'take', 'en passant', 'castle' and 'promote'.\n\t * Use this function instead of {@link ChessBoard.processMove()} to input a move to the board!\n\t * @param {Object} moveData\n\t * @param {Object[]} moveData.moves - An array containing up to 2 moves in the\n\t *  syntax {from: [], to: []}\n\t * @param {Boolean} moveData.takes - True if the move takes a piece\n\t * @param {String} moveData.promotes - Type of promoted piece in case of pawn promotion, else null\n\t */\n\tmove(moveData) {\n\t\tif (moveData !== null) {\n\t\t\tthis.data.cntMoves += 1;\n\n\t\t\tconst { moves } = moveData;\n\t\t\tconst { takes } = moveData;\n\t\t\tconst { promotes } = moveData;\n\n\t\t\t// move\n\t\t\tif (moves.length === 1) {\n\t\t\t\tconst move = moves[0];\n\n\t\t\t\tswitch (takes) {\n\t\t\t\t\tcase true:\n\t\t\t\t\t\t// en passant\n\t\t\t\t\t\tif (this.tiles[move.to[0]][move.to[1]].piece === null) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tthis.tiles[move.from[0]][move.from[1]].piece\n\t\t\t\t\t\t\t\t\t.color === 'white'\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.tiles[move.to[0] + 1][\n\t\t\t\t\t\t\t\t\tmove.to[1]\n\t\t\t\t\t\t\t\t].piece.alive = false;\n\t\t\t\t\t\t\t\tthis.tiles[move.to[0] + 1][\n\t\t\t\t\t\t\t\t\tmove.to[1]\n\t\t\t\t\t\t\t\t].piece = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.tiles[move.to[0] - 1][\n\t\t\t\t\t\t\t\t\tmove.to[1]\n\t\t\t\t\t\t\t\t].piece.alive = false;\n\t\t\t\t\t\t\t\tthis.tiles[move.to[0] - 1][\n\t\t\t\t\t\t\t\t\tmove.to[1]\n\t\t\t\t\t\t\t\t].piece = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.processMove(move);\n\n\t\t\t\tif (promotes !== null) {\n\t\t\t\t\tthis.promotePiece(move.to, promotes);\n\t\t\t\t}\n\t\t\t\t// castle\n\t\t\t} else {\n\t\t\t\tthis.processMove(moves[0]);\n\t\t\t\tthis.processMove(moves[1]);\n\t\t\t}\n\n\t\t\tthis.updateTileStats();\n\t\t}\n\t}\n\n\t/**\n\t * Handles the move commanded by {@link ChessBoard#move}. Don't call this function directly,\n\t *  use {@link ChessBoard#move} to input a move!\n\t * @private\n\t * @param {Object} move\n\t * @param {Number[]} move.from - Coordinates of start tile\n\t * @param {Number[]} move.to - Coordinates of target tile\n\t */\n\tprocessMove(move) {\n\t\t// takes?\n\t\tconst { from } = move;\n\t\tconst { to } = move;\n\t\tconst toPiece = this.tiles[to[0]][to[1]].piece;\n\t\tconst fromPiece = this.tiles[from[0]][from[1]].piece;\n\n\t\tif (toPiece !== null) {\n\t\t\ttoPiece.killPiece(fromPiece);\n\t\t\tfromPiece.killedPiece(toPiece);\n\t\t}\n\t\tthis.tiles[to[0]][to[1]].piece = fromPiece;\n\t\tthis.tiles[to[0]][to[1]].piece.updatePosition(to);\n\t\tthis.tiles[from[0]][from[1]].piece = null;\n\t}\n\n\t/** Resets the board to the default state: removes promoted pieces and puts the standard\n\t *  pieces back to their starting positions.\n\t *\n\t *  Does not reset the stats recorded. If you wish to reset the stats,\n\t *  call {@link ChessBoard#resetStats}. */\n\treset() {\n\t\tthis.data.cntGames += 1;\n\t\t// reset the pieces to default\n\t\tfor (let i = 0; i < this.pieces.length; i += 1) {\n\t\t\tthis.pieces[i].reset();\n\t\t}\n\n\t\t// remove promoted pieces\n\t\tthis.pieces = this.pieces.slice(0, 32);\n\n\t\t// reset the tiles\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tthis.tiles[row][col].resetPiece();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Resets the stats recorded. */\n\tresetStats() {\n\t\t// reset the tiles\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tthis.tiles[row][col].initStats();\n\t\t\t}\n\t\t}\n\n\t\t// reset the pieces to default\n\t\tfor (let i = 0; i < this.pieces.length; i += 1) {\n\t\t\tthis.pieces[i].initStats();\n\t\t}\n\n\t\tthis.data.cntMoves = 0;\n\t\tthis.data.cntGames = 0;\n\t}\n\n\t/**\n\t * Promotes a pawn to a piece.\n\t * @param {Number[]} coords An array containing the row and column of the pawn to be promoted.\n\t * @param {String} pieceType Target piece type in SAN notation ('N', 'B', 'Q', 'R').\n\t */\n\tpromotePiece(coords, pieceType) {\n\t\t// change alive directly instead of killPiece to not update stats\n\t\tthis.tiles[coords[0]][coords[1]].piece.alive = false;\n\t\tthis.tiles[coords[0]][coords[1]].piece = null;\n\n\t\tthis.pieces.push(\n\t\t\tnew ChessPiece(pieceType, [coords[0], coords[1]], true)\n\t\t);\n\t\tthis.tiles[coords[0]][coords[1]].piece = this.pieces[\n\t\t\tthis.pieces.length - 1\n\t\t];\n\t}\n\n\t/** Prints the current board position to the console. */\n\tprintPosition() {\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst rowArray = [];\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tconst { piece } = this.tiles[row][col];\n\t\t\t\tif (piece !== null) {\n\t\t\t\t\trowArray.push(piece.name);\n\t\t\t\t} else {\n\t\t\t\t\trowArray.push('..');\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(rowArray);\n\t\t}\n\t}\n\n\t/** Is called after each {@link ChessBoard#move} to record the stats for the ChessTiles.\n\t * Only every tile, that has a piece on it, is updated.\n\t */\n\tupdateTileStats() {\n\t\tfor (let i = 0; i < 32; i += 1) {\n\t\t\tif (this.pieces[i].alive) {\n\t\t\t\tthis.tiles[this.pieces[i].pos[0]][\n\t\t\t\t\tthis.pieces[i].pos[1]\n\t\t\t\t].updateStats();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport default ChessBoard;\n","import ChessBoard from './ChessBoard';\n\nconst LineByLineReader = require('line-by-line');\nconst EventEmitter = require('events');\n\nconst files = 'abcdefgh';\n\n/**\n * Class that processes games.\n */\nclass GameProcessor extends EventEmitter {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.board = new ChessBoard();\n\t\tthis.activePlayer = 0;\n\t}\n\n\tstatic checkConfig(config) {\n\t\tconst cfg = {};\n\t\tcfg.hasFilter = Object.prototype.hasOwnProperty.call(config, 'filter');\n\t\tcfg.filter = cfg.hasFilter ? config.filter : () => true;\n\n\t\tcfg.cntGames = Object.prototype.hasOwnProperty.call(config, 'cntGames')\n\t\t\t? config.cntGames\n\t\t\t: Infinity;\n\n\t\t// TODO: currently without function\n\t\tcfg.split = Object.prototype.hasOwnProperty.call(config, 'split')\n\t\t\t? config.split\n\t\t\t: false;\n\n\t\treturn cfg;\n\t}\n\n\tprocessPGN(path, config, refreshRate) {\n\t\tconst cfg = GameProcessor.checkConfig(config);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst lr = new LineByLineReader(path, { skipEmptyLines: true });\n\t\t\tlet game = {};\n\n\t\t\t// process current line\n\t\t\tconst processLine = (line) => {\n\t\t\t\t// data tag\n\t\t\t\tif (line.startsWith('[') && cfg.hasFilter) {\n\t\t\t\t\tconst key = line.match(/\\[(.*?)\\s/)[1];\n\t\t\t\t\tconst value = line.match(/\"(.*?)\"/)[1];\n\n\t\t\t\t\tgame[key] = value;\n\n\t\t\t\t\t// moves\n\t\t\t\t} else if (\n\t\t\t\t\tline.startsWith('1') &&\n\t\t\t\t\t(cfg.filter(game) || !cfg.hasFilter)\n\t\t\t\t) {\n\t\t\t\t\tgame.moves = line\n\t\t\t\t\t\t.replace(/\\{(.*?)\\}\\s/g, '')\n\t\t\t\t\t\t.replace(/\\d+\\.+\\s/g, '')\n\t\t\t\t\t\t.replace(' *', '');\n\n\t\t\t\t\tthis.processGame(game);\n\n\t\t\t\t\t// emit event\n\t\t\t\t\tif (this.board.data.cntGames % refreshRate === 0) {\n\t\t\t\t\t\tthis.emit('status', this.board.data.cntGames);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.board.data.cntGames >= cfg.cntGames) {\n\t\t\t\t\t\tlr.close();\n\t\t\t\t\t\tlr.end();\n\t\t\t\t\t}\n\n\t\t\t\t\tgame = {};\n\t\t\t\t}\n\t\t\t\tif (this.board.data.cntGames >= cfg.cntGames) {\n\t\t\t\t\tlr.close();\n\t\t\t\t} else {\n\t\t\t\t\tlr.resume();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlr.on('error', (err) => {\n\t\t\t\tconsole.log(err);\n\t\t\t\treject();\n\t\t\t});\n\n\t\t\tlr.on('line', (line) => {\n\t\t\t\t// pause emitting of lines...\n\t\t\t\tlr.pause();\n\n\t\t\t\tprocessLine(line);\n\t\t\t});\n\n\t\t\tlr.on('end', () => {\n\t\t\t\tconsole.log('Read entire file.');\n\t\t\t\tresolve(this.board);\n\t\t\t});\n\t\t});\n\t}\n\n\tprocessGame(game) {\n\t\tconst moves = game.moves.split(' ');\n\n\t\tfor (let i = 0; i < moves.length; i += 1) {\n\t\t\tthis.activePlayer = i % 2;\n\t\t\tconst moveData = this.parseMove(moves[i]);\n\t\t\tthis.board.move(moveData);\n\t\t}\n\t\tthis.board.reset();\n\t}\n\n\treset() {\n\t\tthis.board.reset();\n\t\tthis.board.resetStats();\n\t\tthis.activePlayer = 0;\n\t}\n\n\t/**\n\t * @typedef {Object} MoveData\n\t * @property {Object[]} moves - Array of {from: [], to: []} objects\n\t * @property {Boolean} takes - Move takes a piece true/false\n\t * @property {String} promotes - Piece type in case of pawn promotion else null\n\t */\n\n\t/**\n\t * Parses a move in string format to board coordinates. Wrapper function for\n\t *  the different move algorithms.\n\t * @param {string} rawMove The move to be parsed, e.g. 'Ne5+'.\n\t * @returns {MoveData}\n\t */\n\tparseMove(rawMove) {\n\t\tconst token = rawMove.substring(0, 1);\n\t\tlet moveData = {};\n\n\t\tconst move = GameProcessor.preProcess(rawMove);\n\n\t\t// game end on '1-0', '0-1' or '1/2-1/2' (check for digit as first char)\n\t\tif (token.match(/\\d/) !== null) {\n\t\t\tmoveData = null;\n\t\t} else if (token.toLowerCase() === token) {\n\t\t\t// pawn move\n\t\t\tmoveData = this.pawnMove(move);\n\t\t} else if (token === 'O') {\n\t\t\tmoveData = this.castle(move);\n\t\t} else {\n\t\t\tmoveData = this.pieceMove(move);\n\t\t}\n\t\t// if (moveData !== null) {\n\t\t// \tif (Number.isNaN(moveData.moves[0].to[0])) console.log(rawMove);\n\t\t// }\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Returns the board coordinates for the move if it is a pawn move.\n\t * @param {string} moveSan The move to be parsed, e.g. 'e5'.\n\t * @returns {MoveData}\n\t */\n\tpawnMove(moveSan) {\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\t\tconst direction = -2 * (this.activePlayer % 2) + 1;\n\t\tlet move = moveSan;\n\n\t\t// takes\n\t\tif (move.includes('x')) {\n\t\t\tmoveData.takes = true;\n\t\t\tmove = move.replace('x', '');\n\n\t\t\tto[0] = 8 - parseInt(move.substring(2, 3), 10);\n\t\t\tto[1] = files.indexOf(move.substring(1, 2));\n\t\t\tfrom[0] = to[0] + direction;\n\t\t\tfrom[1] = files.indexOf(move.substring(0, 1));\n\n\t\t\t// moves\n\t\t} else {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(0, 1));\n\n\t\t\tfrom[1] = tarCol;\n\t\t\tto[0] = tarRow;\n\t\t\tto[1] = tarCol;\n\t\t\tfor (let i = tarRow + direction; i < 8 && i >= 0; i += direction) {\n\t\t\t\tif (this.board.tiles[i][tarCol].piece !== null) {\n\t\t\t\t\tif (this.board.tiles[i][tarCol].piece.name.includes('P')) {\n\t\t\t\t\t\tfrom[0] = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmoveData.moves.push({ from, to });\n\n\t\t// promotes\n\t\tif (move.includes('=')) {\n\t\t\tmoveData.promotes = move.substring(move.length - 1, move.length);\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Returns the board coordinates for a piece (!= pawn) move.\n\t * @param {string} moveSan The move to be parsed, e.g. 'Be3'.\n\t * @returns {MoveData}\n\t */\n\tpieceMove(moveSan) {\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\t\tlet move = moveSan;\n\t\tconst token = move.substring(0, 1);\n\n\t\t// remove token\n\t\tmove = move.substring(1, move.length);\n\n\t\t// takes\n\t\tif (move.includes('x')) {\n\t\t\tmoveData.takes = true;\n\t\t\tmove = move.replace('x', '');\n\t\t}\n\n\t\t// e.g. Re3f5\n\t\tif (move.length === 4) {\n\t\t\tfrom[0] = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tfrom[1] = files.indexOf(move.substring(0, 1));\n\t\t\tto[0] = 8 - parseInt(move.substring(3, 4), 10);\n\t\t\tto[1] = files.indexOf(move.substring(2, 3));\n\t\t\tmoveData.moves.push({ from, to });\n\n\t\t\t// e.g. Ref3\n\t\t} else if (move.length === 3) {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(2, 3), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(1, 2));\n\t\t\tlet mustBeInRow = -1;\n\t\t\tlet mustBeInCol = -1;\n\n\t\t\t// file is specified\n\t\t\tif (files.indexOf(move.substring(0, 1)) >= 0) {\n\t\t\t\tmustBeInCol = files.indexOf(move.substring(0, 1));\n\n\t\t\t\t// rank is specified\n\t\t\t} else {\n\t\t\t\tmustBeInRow = 8 - parseInt(move.substring(0, 1), 10);\n\t\t\t}\n\t\t\tmoveData.moves.push(\n\t\t\t\tthis.findPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token)\n\t\t\t);\n\n\t\t\t// e.g. Rf3\n\t\t} else {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(0, 1));\n\t\t\tmoveData.moves.push(this.findPiece(tarRow, tarCol, -1, -1, token));\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Wrapper function for different piece search algorithms.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tlet move;\n\n\t\tif (token === 'R') {\n\t\t\tmove = this.findLine(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t} else if (token === 'B') {\n\t\t\tmove = this.findDiag(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t} else if (token === 'Q' || token === 'K') {\n\t\t\tmove = this.findDiag(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t\tif (move.from[0] === -1) {\n\t\t\t\tmove = this.findLine(\n\t\t\t\t\ttarRow,\n\t\t\t\t\ttarCol,\n\t\t\t\t\tmustBeInRow,\n\t\t\t\t\tmustBeInCol,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (token === 'N') {\n\t\t\tmove = this.findKnight(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t}\n\t\tif (move.from[0] === -1) {\n\t\t\tconsole.log(\n\t\t\t\t`Error: no piece for move ${token} to (${tarRow},${tarCol}) found!`\n\t\t\t);\n\t\t\tthis.board.printPosition();\n\t\t}\n\n\t\treturn move;\n\t}\n\n\t/**\n\t * Search algorithm to find a piece that can move diagonally.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindDiag(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -1; i <= 1; i += 2) {\n\t\t\tlet obstructed1 = false;\n\t\t\tlet obstructed2 = false;\n\t\t\tfor (let j = 1; j < 8; j += 1) {\n\t\t\t\tconst row1 = to[0] + i * j;\n\t\t\t\tconst col1 = to[1] + j;\n\t\t\t\tconst row2 = to[0] - i * j;\n\t\t\t\tconst col2 = to[1] - j;\n\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\t!obstructed1 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\t!obstructed2 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed2 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Search algorithm to find a piece that can move vertically/horizontally.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindLine(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -1; i <= 1; i += 2) {\n\t\t\tlet obstructed1 = false;\n\t\t\tlet obstructed2 = false;\n\t\t\tfor (let j = 1; j < 8; j += 1) {\n\t\t\t\tconst row1 = to[0];\n\t\t\t\tconst col1 = to[1] - i * j;\n\t\t\t\tconst row2 = to[0] - i * j;\n\t\t\t\tconst col2 = to[1];\n\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\t!obstructed1 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\t!obstructed2 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed2 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Search algorithm to find a matching knight.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindKnight(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -2; i <= 2; i += 4) {\n\t\t\tfor (let j = -1; j <= 1; j += 2) {\n\t\t\t\tconst row1 = to[0] + i;\n\t\t\t\tconst col1 = to[1] + j;\n\t\t\t\tconst row2 = to[0] + j;\n\t\t\t\tconst col2 = to[1] + i;\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Checks if the input move would be resulting with the king being in check.\n\t * @param {Number[]} from Coordinates of the source tile of the move that shall be checked.\n\t *  @param {Number[]} to Coordinates of the target tile of the move that shall be checked.\n\t * @returns {boolean} After the move, the king will be in check true/false.\n\t */\n\tcheckCheck(from, to) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst opColor = this.activePlayer % 2 ? 'white' : 'black';\n\t\tconst king = this.board.pieces[color === 'white' ? 28 : 4].pos;\n\t\tlet isInCheck = false;\n\n\t\t// if king move, no check is possible, exit function\n\t\tif (king[0] === from[0] && king[1] === from[1]) return false;\n\n\t\t// check if moving piece is on same line/diag as king, else exit\n\t\tconst diff = [];\n\t\tdiff[0] = from[0] - king[0];\n\t\tdiff[1] = from[1] - king[1];\n\t\tconst checkFor = [];\n\t\tif (diff[0] === 0 || diff[1] === 0) {\n\t\t\tcheckFor[0] = 'Q';\n\t\t\tcheckFor[1] = 'R';\n\t\t} else if (Math.abs(diff[0]) === Math.abs(diff[1])) {\n\t\t\tcheckFor[0] = 'Q';\n\t\t\tcheckFor[1] = 'B';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tif (diff[0] !== 0) diff[0] /= Math.abs(diff[0]);\n\t\tif (diff[1] !== 0) diff[1] /= Math.abs(diff[1]);\n\n\t\tconst srcTilePiece = this.board.tiles[from[0]][from[1]].piece;\n\t\tconst tarTilePiece = this.board.tiles[to[0]][to[1]].piece;\n\n\t\t// premove and check if check\n\t\tthis.board.tiles[from[0]][from[1]].piece = null;\n\t\tthis.board.tiles[to[0]][to[1]].piece = srcTilePiece;\n\n\t\t// check for check\n\t\tlet obstructed = false;\n\t\tfor (let j = 1; j < 8 && !isInCheck && !obstructed; j += 1) {\n\t\t\tconst row = king[0] + j * diff[0];\n\t\t\tconst col = king[1] + j * diff[1];\n\n\t\t\tif (\n\t\t\t\trow >= 0 &&\n\t\t\t\trow < 8 &&\n\t\t\t\tcol >= 0 &&\n\t\t\t\tcol < 8 &&\n\t\t\t\tthis.board.tiles[row][col].piece !== null\n\t\t\t) {\n\t\t\t\tconst { piece } = this.board.tiles[row][col];\n\t\t\t\tif (\n\t\t\t\t\t(piece.name.includes(checkFor[0]) ||\n\t\t\t\t\t\tpiece.name.includes(checkFor[1])) &&\n\t\t\t\t\tpiece.color === opColor\n\t\t\t\t) {\n\t\t\t\t\tisInCheck = true;\n\t\t\t\t} else {\n\t\t\t\t\tobstructed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.board.tiles[from[0]][from[1]].piece = srcTilePiece;\n\t\tthis.board.tiles[to[0]][to[1]].piece = tarTilePiece;\n\n\t\treturn isInCheck;\n\t}\n\n\t/**\n\t * Returns the board coordinates for castling.\n\t * @param {string} move The move to be parsed, e.g. 'O-O'.\n\t * @returns {MoveData.moves}\n\t */\n\tcastle(move) {\n\t\tconst row = this.activePlayer % 2 ? 0 : 7;\n\t\tconst from1 = [];\n\t\tconst from2 = [];\n\t\tconst to1 = [];\n\t\tconst to2 = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\n\t\t// O-O\n\t\tif (move.length === 3) {\n\t\t\tfrom1[0] = row;\n\t\t\tfrom1[1] = 4;\n\t\t\tto1[0] = row;\n\t\t\tto1[1] = 6;\n\t\t\tfrom2[0] = row;\n\t\t\tfrom2[1] = 7;\n\t\t\tto2[0] = row;\n\t\t\tto2[1] = 5;\n\n\t\t\t// O-O-O\n\t\t} else {\n\t\t\tfrom1[0] = row;\n\t\t\tfrom1[1] = 4;\n\t\t\tto1[0] = row;\n\t\t\tto1[1] = 2;\n\t\t\tfrom2[0] = row;\n\t\t\tfrom2[1] = 0;\n\t\t\tto2[0] = row;\n\t\t\tto2[1] = 3;\n\t\t}\n\t\tmoveData.moves.push({ from: from1, to: to1 });\n\t\tmoveData.moves.push({ from: from2, to: to2 });\n\t\treturn moveData;\n\t}\n\n\tstatic algebraicToCoords(square) {\n\t\tconst coords = [];\n\t\tconst temp = square.split('');\n\t\tcoords.push(8 - temp[1]);\n\t\tcoords.push(files.indexOf(temp[0]));\n\n\t\treturn coords;\n\t}\n\n\tstatic coordsToAlgebraic(coords) {\n\t\tlet name = files[coords[1]];\n\t\tname += 8 - coords[0];\n\n\t\treturn name;\n\t}\n\n\t/**\n\t * Removes special characters like '#', '+', '?' and '!'\n\t * @param {string} move The move to be cleaned up\n\t * @returns {string} The input string with removed special characters\n\t */\n\tstatic preProcess(move) {\n\t\treturn move.replace(/#|\\+|\\?|!/g, '');\n\t}\n}\n\nexport default GameProcessor;\n","import GameProcessor from './GameProcessor';\n\nconst { performance } = require('perf_hooks');\n\nconst fs = require('fs');\n\nconst pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\nconst pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n/**\n * @typedef {Object} cfg\n * @property {Function} filter - Descr\n * @property {Number} cntGames - Descr\n * @property {Boolean} split - Descr\n */\n\n/** Main class for batch processing and generating heat maps */\nclass Chessalyzer {\n\tconstructor() {\n\t\t/**\n\t\t * Contains the tracked data of the processed PGN files. Has two different banks for\n\t\t * heat map comparison. Each object contains the following keys:\n\t\t * <ul>\n\t\t * <li>data: {cntMoves, cntGames}. Information about the count of processed moves and games</li>\n\t\t * <li>tiles: 8x8 array of {@link ChessTile}s.</li>\n\t\t * </ul>\n\t\t * @member {Object[]}\n\t\t */\n\t\tthis.dataStore = new Array(2);\n\t\t/**\n\t\t * Does the analysis part\n\t\t * @member {GameProcessor}\n\t\t */\n\t\tthis.gameProcessor = new GameProcessor();\n\t}\n\n\t/**\n\t * Starts the batch processing for the selected file\n\t * @param {String} path - Path to the PGN file that should be analyzed\n\t * @param {Number} [bank = 0] - The data bank the results shall be saved to\n\t * @param {Number} [refreshRate = 250] - Defines how often the current status of the\n\t *  analysis shall be exposed. Every number of processed games an event is emitted\n\t * containing the current number of processed games. The event can be handled via\n\t *  \"chessalyzer.gameProcessor.on('status', function(gameCnt) {// do handling here});\",\n\t *  e.g. to update an UI.\n\t * @returns {Promise} Promise that contains the number of processed games when finished\n\t */\n\tstartBatch(path, cfg = {}, bank = 0, refreshRate = 250) {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst t0 = performance.now();\n\t\t\tthis.gameProcessor\n\t\t\t\t.processPGN(path, cfg, refreshRate)\n\t\t\t\t.then((board) => {\n\t\t\t\t\tconst dataset = {};\n\t\t\t\t\tdataset.data = board.data;\n\t\t\t\t\tdataset.tiles = board.tiles;\n\t\t\t\t\tthis.dataStore[bank] = JSON.parse(JSON.stringify(dataset));\n\t\t\t\t\tconst t1 = performance.now();\n\t\t\t\t\tconst tdiff = Math.round(t1 - t0) / 1000;\n\t\t\t\t\tconst mps = Math.round(dataset.data.cntMoves / tdiff);\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`${dataset.data.cntGames} games (${\n\t\t\t\t\t\t\tdataset.data.cntMoves\n\t\t\t\t\t\t} moves) processed in ${tdiff}s (${mps} moves/s)`\n\t\t\t\t\t);\n\t\t\t\t\tthis.gameProcessor.reset();\n\t\t\t\t\tresolve(this.dataStore[bank].data.cntGames);\n\t\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Saves a completed analysis to a JSON file\n\t * @param {String} path - Path the analysis file shall be saved to\n\t * @param {Number} [bank = 0] - The data bank the data shall be taken from\n\t */\n\tsaveAnalysis(path, bank = 0) {\n\t\tfs.writeFile(path, JSON.stringify(this.dataStore[bank]), (err) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconsole.log('File has been created');\n\t\t});\n\t}\n\n\t/**\n\t * Loads a analysis file (JSON) to a data bank\n\t * @param {String} path - Path the analysis file shall be loaded from\n\t * @param {Number} [bank = 0] - The data bank the data shall be loaded to.\n\t * @returns {Number} Count of loaded games\n\t */\n\tloadAnalysis(path, bank) {\n\t\tthis.dataStore[bank] = JSON.parse(fs.readFileSync(path, 'utf8'));\n\t\tconsole.log(`File '${path}' has been loaded to bank ${bank}.`);\n\t\treturn this.dataStore[bank].cntGames;\n\t}\n\n\t/**\n\t * Generates a heatmap out of the tracked data.\n\t * @param {Number} bank - Path the analysis file shall be loaded from\n\t * @param {String} square - The square the data shall be generated for. For example, if you\n\t * wanted to know how often a specific piece was on a specific tile, you would pass the\n\t * identifiert of the tile to the function, e.g. \"a2\"\n\t * @param {Function} fun - The evaluation function that generates the heatmap out of the\n\t * saved data. This function gets passed the following arguments:\n\t * <ol>\n\t * <li>The complete data stored in the chosen bank. See the member description of the dataStore\n\t * member to see which data is available.</li>\n\t * <li>The coords of the tile passed as the square argument.</li>\n\t * <li>The current coordinates of the tile the data should be generated for.\n\t * The function must return a Number with the heat map value for the square passed as the\n\t * third argument.</li>\n\t * </ol>\n\t * See ./src/exampleHeatmapConfig for examples of such a function.\n\t * @returns {Array} Array with 3 entries:\n\t * <ol>\n\t * <li>8x8 Array containing the heat map values for each tile</li>\n\t * <li>The minimum value in the heatmap.</li>\n\t * <li>The maximum value in the heatmap.</li>\n\t * </ol>\n\t */\n\tgenerateHeatmap(bank, square, fun) {\n\t\tconst coords = GameProcessor.algebraicToCoords(square);\n\t\tconst map = [];\n\t\tlet max = 0;\n\t\tlet min = 100000;\n\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tconst dataRow = new Array(8);\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tdataRow[j] = fun(this.dataStore[bank], coords, [i, j]);\n\t\t\t\tif (dataRow[j] > max) max = dataRow[j];\n\t\t\t\tif (dataRow[j] < min) min = dataRow[j];\n\t\t\t}\n\t\t\tmap.push(dataRow);\n\t\t}\n\n\t\treturn [map, min, max];\n\t}\n\n\t/**\n\t * Generates a comparison heatmap out of the tracked data. There needs to data in both\n\t * banks you pass as bank1 and bank2 params. The heatmap for both banks are calculated\n\t * and then the relative differences between both banks are calculated. For example,\n\t * if the heatmap value for \"a1\" of bank1 is 10 and the value of bank2 is 5, the returned\n\t * value for \"a1\" would be 100% ([[10/5] -1] *100).\n\t * @param {String} square - The square the data shall be generated for.\n\t * @param {Function} fun - The evaluation function that generates the heatmap out of the\n\t * saved data. See {@link Chessalyzer#generateHeatmap} for a more detailed description.\n\t * @param {Number} [bank1 = 0] - Bank number of dataset 1\n\t * @param {Number} [bank2 = 1] - Bank number of dataset 2\n\t * @returns {Array} Array with 3 entries:\n\t * <ol>\n\t * <li>8x8 Array containing the heat map values for each tile</li>\n\t * <li>The minimum value in the heatmap.</li>\n\t * <li>The maximum value in the heatmap.</li>\n\t * </ol>\n\t */\n\tgenerateComparisonHeatmap(square, fun, bank1 = 0, bank2 = 1) {\n\t\tconst map = [];\n\t\tlet max = 0;\n\t\tlet min = 100000;\n\n\t\t// comparison heatmap\n\t\tconst data0 = this.generateHeatmap(bank1, square, fun);\n\t\tconst data1 = this.generateHeatmap(bank2, square, fun);\n\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tconst dataRow = new Array(8);\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tconst a = data0[0][i][j];\n\t\t\t\tconst b = data1[0][i][j];\n\t\t\t\tif (a === 0 || b === 0) dataRow[j] = 0;\n\t\t\t\telse dataRow[j] = (a >= b ? a / b - 1 : -b / a + 1) * 100;\n\n\t\t\t\tif (dataRow[j] > max) max = dataRow[j];\n\t\t\t\tif (dataRow[j] < min) min = dataRow[j];\n\t\t\t}\n\t\t\tmap.push(dataRow);\n\t\t}\n\n\t\treturn [map, min, max];\n\t}\n\n\tstatic generateList(map) {\n\t\tconst list = [];\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tlet val = map[i][j];\n\t\t\t\tval = val.toFixed(2);\n\t\t\t\tif (Math.abs(val) > 0.001) {\n\t\t\t\t\tif (i === 0) list.push([`b${pieceTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 1) list.push([`b${pawnTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 6) list.push([`w${pawnTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 7) list.push([`w${pieceTemplate[j]}`, val]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlist.sort((a, b) => b[1] - a[1]);\n\t\treturn list;\n\t}\n}\n\nexport default Chessalyzer;\n","/* eslint-disable */\nimport Chessalyzer from './Chessalyzer';\n\nexport default Chessalyzer;\n"],"sourceRoot":""}