{"version":3,"sources":["webpack://chessalyzer/webpack/universalModuleDefinition","webpack://chessalyzer/webpack/bootstrap","webpack://chessalyzer/external \"fs\"","webpack://chessalyzer/external \"perf_hooks\"","webpack://chessalyzer/external \"events\"","webpack://chessalyzer/external \"line-by-line\"","webpack://chessalyzer/./src/ChessPiece.js","webpack://chessalyzer/./src/ChessTile.js","webpack://chessalyzer/./src/ChessBoard.js","webpack://chessalyzer/./src/GameProcessor.js","webpack://chessalyzer/./src/Chessalyzer.js","webpack://chessalyzer/./src/index.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","ChessPiece","piece","pos","promoted","arguments","length","undefined","_classCallCheck","this","defaultPos","color","alive","stats","initStats","logHistory","history","push","maxHistory","cntMoved","at","movedTo","killedByPiece","cntWasKilled","killedBy","killedPiece","cntHasKilled","killed","Array","row","currRow","col","ChessTile","defaultPiece","cntHasPiece","white","black","wasOnTile","cntTakenPieces","_ChessTile","_interopRequireDefault","_ChessPiece","pawnTemplate","pieceTemplate","ChessBoard","cntMoves","cntGames","pieces","alivePieces","tiles","default","initPiece","moveData","moves","takes","promotes","move","processTakes","processMove","promotePiece","to","updateTileStats","from","offset","toPiece","fromPiece","killPiece","updateDeadCount","updatePosition","reset","slice","resetPiece","coords","pieceType","rowArray","console","log","updateOccupationStats","_ChessBoard","LineByLineReader","EventEmitter","files","GameProcessor","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","board","activePlayer","path","config","refreshRate","_this2","cfg","checkConfig","Promise","resolve","reject","lr","skipEmptyLines","game","on","err","line","pause","startsWith","hasFilter","match","replace","split","filter","processGame","emit","close","end","resume","processLine","parseMove","resetStats","rawMove","token","substring","preProcess","toLowerCase","pawnMove","pieceMove","castle","moveSan","direction","includes","parseInt","indexOf","tarRow","tarCol","mustBeInRow","mustBeInCol","findPiece","findLine","findDiag","findKnight","concat","printPosition","obstructed1","obstructed2","j","row1","col1","row2","col2","checkCheck","opColor","king","isInCheck","diff","checkFor","Math","abs","srcTilePiece","tarTilePiece","obstructed","from1","from2","to1","to2","Infinity","square","temp","_GameProcessor","performance","fs","Chessalyzer","dataStore","gameProcessor","bank","t0","now","processPGN","then","dataset","JSON","parse","stringify","t1","tdiff","round","mps","writeFile","error","readFileSync","fun","algebraicToCoords","map","max","min","dataRow","bank1","bank2","data0","generateHeatmap","data1","a","b","list","val","toFixed","sort"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,iBAAAH,GACA,iBAAAC,QACAA,QAAA,YAAAD,IAEAD,EAAA,YAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAT,YAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,OAAAC,eAAAnB,EAAAuB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,mBClFAtC,EAAAD,QAAAwC,QAAA,qBCAAvC,EAAAD,QAAAwC,QAAA,6BCAAvC,EAAAD,QAAAwC,QAAA,yBCAAvC,EAAAD,QAAAwC,QAAA,uSCUC,SAAAC,EAAYC,EAAOC,GAAuB,IAAlBC,EAAkBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,gGAAAG,CAAAC,KAAAR,GAKzCQ,KAAKlC,KAAO2B,EAMZO,KAAKN,IAAMA,EAMXM,KAAKC,WAAaP,EAMlBM,KAAKE,MAAQ,GAEZF,KAAKE,MADFP,EACUK,KAAKC,WAAW,IAAM,EAAI,QAAU,QAEpCD,KAAKC,WAAW,IAAM,EAAI,QAAU,QAGlDD,KAAKG,OAAQ,EAMbH,KAAKI,SAOLJ,KAAKK,YAILL,KAAKM,YAAa,EAClBN,KAAKO,WACLP,KAAKO,QAAQC,KAAKd,GAClBM,KAAKS,WAAa,2FAQdT,KAAKM,YAAcN,KAAKO,QAAQV,OAASG,KAAKS,aACjDT,KAAKO,QAAQC,KAAK,MAClBR,KAAKO,QAAQC,KAAKR,KAAKC,aAGxBD,KAAKN,IAAMM,KAAKC,WAChBD,KAAKG,OAAQ,yCAQCT,GACdM,KAAKI,MAAMM,UAAY,EACvBV,KAAKN,IAAMA,EACPM,KAAKM,YAAcN,KAAKO,QAAQV,OAASG,KAAKS,YACjDT,KAAKO,QAAQC,KAAKd,GAEnBM,KAAKI,MAAMO,GAAGjB,EAAI,IAAIA,EAAI,IAAIkB,SAAW,oCAQhCC,GACTb,KAAKG,OAAQ,EACbH,KAAKI,MAAMU,cAAgB,EAGS,IAA9BD,EAAc/C,KAAK+B,QAAqC,IAArBG,KAAKlC,KAAK+B,SAElDG,KAAKI,MAAMO,GAAGE,EAAcZ,WAAW,IACtCY,EAAcZ,WAAW,IACxBc,UAAY,uCAIJC,GACXhB,KAAKI,MAAMa,cAAgB,EAGO,IAA5BD,EAAYlD,KAAK+B,QAAqC,IAArBG,KAAKlC,KAAK+B,SAEhDG,KAAKI,MAAMO,GAAGK,EAAYf,WAAW,IACpCe,EAAYf,WAAW,IACtBiB,QAAU,uCASblB,KAAKI,OAAUM,SAAU,EAAGI,aAAc,EAAGG,aAAc,GAC3DjB,KAAKI,MAAMO,GAAK,IAAIQ,MAAM,GAC1B,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,CAEpC,IADA,IAAMC,EAAU,IAAIF,MAAM,GACjBG,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjCD,EAAQC,IAASV,QAAS,EAAGG,SAAU,EAAGG,OAAQ,GAEnDlB,KAAKI,MAAMO,GAAGS,GAAOC,mUClIvB,SAAAE,iGAAcxB,CAAAC,KAAAuB,GAKbvB,KAAKP,MAAQ,KAMbO,KAAKwB,aAAe,KAMpBxB,KAAKI,SAELJ,KAAKK,qGAQIZ,GACTO,KAAKP,MAAQA,EACbO,KAAKwB,aAAe/B,uCAQpBO,KAAKP,MAAQO,KAAKwB,6DASO,UAArBxB,KAAKP,MAAMS,MACdF,KAAKI,MAAMqB,YAAYC,OAAS,EAEhC1B,KAAKI,MAAMqB,YAAYE,OAAS,EAIF,IAA3B3B,KAAKP,MAAM3B,KAAK+B,SACnBG,KAAKI,MAAMO,GAAGX,KAAKP,MAAMQ,WAAW,IACnCD,KAAKP,MAAMQ,WAAW,IACrB2B,WAAa,6CAKhB5B,KAAKI,MAAMyB,gBAAkB,sCAQ7B7B,KAAKI,MAAMqB,aAAgBC,MAAO,EAAGC,MAAO,GAC5C3B,KAAKI,MAAMyB,eAAiB,EAE5B7B,KAAKI,MAAMO,GAAK,IAAIQ,MAAM,GAC1B,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,CAEpC,IADA,IAAMC,EAAU,IAAIF,MAAM,GACjBG,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjCD,EAAQC,IAASM,UAAW,GAE7B5B,KAAKI,MAAMO,GAAGS,GAAOC,4ICjFxB,IAAAS,EAAAC,EAAA1E,EAAA,IACA2E,EAAAD,EAAA1E,EAAA,6NAEA,IAAM4E,GAAgB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC1DC,GAAiB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,mBAKhE,SAAAC,iGAAcpC,CAAAC,KAAAmC,GAKbnC,KAAKI,OACJgC,SAAU,EACVC,SAAU,GAOXrC,KAAKsC,UAELtC,KAAKuC,eAMLvC,KAAKwC,MAAQ,IAAIrB,MAAM,GACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,CAEpC,IADA,IAAMC,EAAU,IAAIF,MAAM,GACjBG,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjCD,EAAQC,GAAO,IAAAQ,EAAAW,QAGH,IAARrB,GAAqB,IAARA,GAChBpB,KAAKsC,OAAO9B,KACX,IAAAwB,EAAAS,QAAeP,EAAcZ,IAAOF,EAAKE,KAE1CD,EAAQC,GAAKoB,UAAU1C,KAAKsC,OAAOtC,KAAKsC,OAAOzC,OAAS,KACtC,IAARuB,GAAqB,IAARA,IACvBpB,KAAKsC,OAAO9B,KACX,IAAAwB,EAAAS,QAAeR,EAAaX,IAAOF,EAAKE,KAEzCD,EAAQC,GAAKoB,UAAU1C,KAAKsC,OAAOtC,KAAKsC,OAAOzC,OAAS,KAG1DG,KAAKwC,MAAMpB,GAAOC,uFAcfsB,GACJ,GAAiB,OAAbA,EAAmB,CACtB3C,KAAKI,MAAMgC,UAAY,EADD,IAGdQ,EAAUD,EAAVC,MACAC,EAAUF,EAAVE,MACAC,EAAaH,EAAbG,SAGR,GAAqB,IAAjBF,EAAM/C,OAAc,CACvB,IAAMkD,EAAOH,EAAM,GAEfC,GACH7C,KAAKgD,aAAaD,GAGnB/C,KAAKiD,YAAYF,GAEA,OAAbD,GACH9C,KAAKkD,aAAaH,EAAKI,GAAIL,QAI5B9C,KAAKiD,YAAYL,EAAM,IACvB5C,KAAKiD,YAAYL,EAAM,IAGxB5C,KAAKoD,wDAYML,GAAM,IACVM,EAASN,EAATM,KACAF,EAAOJ,EAAPI,GACJG,EAAS,EAG0B,OAAnCtD,KAAKwC,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,QAC5B6D,EAC8C,UAA7CtD,KAAKwC,MAAMa,EAAK,IAAIA,EAAK,IAAI5D,MAAMS,MAAoB,GAAK,GAE9D,IAAMqD,EAAUvD,KAAKwC,MAAMW,EAAG,GAAKG,GAAQH,EAAG,IAAI1D,MAC5C+D,EAAYxD,KAAKwC,MAAMa,EAAK,IAAIA,EAAK,IAAI5D,MAE/C8D,EAAQE,UAAUD,GAClBA,EAAUxC,YAAYuC,GAEtBvD,KAAKwC,MAAMW,EAAG,GAAKG,GAAQH,EAAG,IAAI1D,MAAQ,KAC1CO,KAAKwC,MAAMW,EAAG,GAAKG,GAAQH,EAAG,IAAIO,sDAWvBX,GAAM,IACTM,EAASN,EAATM,KACAF,EAAOJ,EAAPI,GAERnD,KAAKwC,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAAQO,KAAKwC,MAAMa,EAAK,IAAIA,EAAK,IAAI5D,MAC9DO,KAAKwC,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAAMkE,eAAeR,GAC9CnD,KAAKwC,MAAMa,EAAK,IAAIA,EAAK,IAAI5D,MAAQ,qCASrCO,KAAKI,MAAMiC,UAAY,EAEvB,IAAK,IAAI9E,EAAI,EAAGA,EAAIyC,KAAKsC,OAAOzC,OAAQtC,GAAK,EAC5CyC,KAAKsC,OAAO/E,GAAGqG,QAIhB5D,KAAKsC,OAAStC,KAAKsC,OAAOuB,MAAM,EAAG,IAGnC,IAAK,IAAIzC,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjC,IAAK,IAAIE,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjCtB,KAAKwC,MAAMpB,GAAKE,GAAKwC,kDAQvB,IAAK,IAAI1C,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjC,IAAK,IAAIE,EAAM,EAAGA,EAAM,EAAGA,GAAO,EACjCtB,KAAKwC,MAAMpB,GAAKE,GAAKjB,YAKvB,IAAK,IAAI9C,EAAI,EAAGA,EAAIyC,KAAKsC,OAAOzC,OAAQtC,GAAK,EAC5CyC,KAAKsC,OAAO/E,GAAG8C,YAGhBL,KAAKI,MAAMgC,SAAW,EACtBpC,KAAKI,MAAMiC,SAAW,uCASV0B,EAAQC,GAEpBhE,KAAKwC,MAAMuB,EAAO,IAAIA,EAAO,IAAItE,MAAMU,OAAQ,EAC/CH,KAAKwC,MAAMuB,EAAO,IAAIA,EAAO,IAAItE,MAAQ,KAEzCO,KAAKsC,OAAO9B,KACX,IAAAwB,EAAAS,QAAeuB,GAAYD,EAAO,GAAIA,EAAO,KAAK,IAEnD/D,KAAKwC,MAAMuB,EAAO,IAAIA,EAAO,IAAItE,MAAQO,KAAKsC,OAC7CtC,KAAKsC,OAAOzC,OAAS,2CAMtB,IAAK,IAAIuB,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,CAEpC,IADA,IAAM6C,KACG3C,EAAM,EAAGA,EAAM,EAAGA,GAAO,EAAG,KAC5B7B,EAAUO,KAAKwC,MAAMpB,GAAKE,GAA1B7B,MACM,OAAVA,EACHwE,EAASzD,KAAKf,EAAM3B,MAEpBmG,EAASzD,KAAK,MAGhB0D,QAAQC,IAAIF,8CASb,IAAK,IAAI1G,EAAI,EAAGA,EAAI,GAAIA,GAAK,EACxByC,KAAKsC,OAAO/E,GAAG4C,OAClBH,KAAKwC,MAAMxC,KAAKsC,OAAO/E,GAAGmC,IAAI,IAC7BM,KAAKsC,OAAO/E,GAAGmC,IAAI,IAClB0E,iKCjON,IAAAC,mDAAAtC,CAAA1E,EAAA,0qBAEA,IAAMiH,EAAmBjH,EAAQ,GAC3BkH,EAAelH,EAAQ,GAEvBmH,EAAQ,yBAMb,SAAAC,IAAc,IAAAC,EAAA,mGAAA3E,CAAAC,KAAAyE,IACbC,EAAAC,EAAA3E,MAAAyE,EAAAG,WAAA3G,OAAA4G,eAAAJ,IAAA/G,KAAAsC,QACK8E,MAAQ,IAAAT,EAAA5B,QACbiC,EAAKK,aAAe,EAHPL,8OADaH,sFAwBhBS,EAAMC,EAAQC,GAAa,IAAAC,EAAAnF,KAC/BoF,EAAMX,EAAcY,YAAYJ,GAEtC,OAAO,IAAIK,QAAQ,SAACC,EAASC,GAC5B,IAAMC,EAAK,IAAInB,EAAiBU,GAAQU,gBAAgB,IACpDC,KAsCJF,EAAGG,GAAG,QAAS,SAACC,GACf3B,QAAQC,IAAI0B,GACZL,MAGDC,EAAGG,GAAG,OAAQ,SAACE,GAEdL,EAAGM,QA1CgB,SAACD,GAEpB,GAAIA,EAAKE,WAAW,MAAQZ,EAAIa,UAAW,CAC1C,IAAMnH,EAAMgH,EAAKI,MAAM,aAAa,GAC9B1H,EAAQsH,EAAKI,MAAM,WAAW,GAEpCP,EAAK7G,GAAON,OAGFsH,EAAKE,WAAW,OAC1BL,EAAK/C,MAAQkD,EACXK,QAAQ,eAAgB,IACxBA,QAAQ,YAAa,IACrBA,QAAQ,KAAM,IACdC,MAAM,MAEJhB,EAAIiB,OAAOV,IAAUP,EAAIa,WAC5Bd,EAAKmB,YAAYX,GAIdR,EAAKL,MAAM1E,MAAMiC,SAAW6C,GAAgB,GAC/CC,EAAKoB,KAAK,SAAUpB,EAAKL,MAAM1E,MAAMiC,UAGtCsD,MAEGR,EAAKL,MAAM1E,MAAMiC,UAAY+C,EAAI/C,UACpCoD,EAAGe,QACHf,EAAGgB,OAEHhB,EAAGiB,SAaJC,CAAYb,KAGbL,EAAGG,GAAG,MAAO,WACZ1B,QAAQC,IAAI,qBACZoB,EAAQJ,EAAKL,+CAKJa,GAGX,IAHiB,IACT/C,EAAU+C,EAAV/C,MAECrF,EAAI,EAAGA,EAAIqF,EAAM/C,OAAQtC,GAAK,EAAG,CACzCyC,KAAK+E,aAAexH,EAAI,EACxB,IAAMoF,EAAW3C,KAAK4G,UAAUhE,EAAMrF,IACtCyC,KAAK8E,MAAM/B,KAAKJ,GAEjB3C,KAAK8E,MAAMlB,wCAIX5D,KAAK8E,MAAMlB,QACX5D,KAAK8E,MAAM+B,aACX7G,KAAK+E,aAAe,oCAgBX+B,GACT,IAAMC,EAAQD,EAAQE,UAAU,EAAG,GAG7BjE,EAAO0B,EAAcwC,WAAWH,GAatC,OAV0B,OAAtBC,EAAMb,MAAM,MACJ,KACDa,EAAMG,gBAAkBH,EACvB/G,KAAKmH,SAASpE,GACL,MAAVgE,EACC/G,KAAKoH,UAAUrE,GAEf/C,KAAKqH,OAAOtE,oCAWhBuE,GACR,IAAMjE,KACAF,KACAR,GACLC,SACAC,OAAO,EACPC,SAAU,MAELyE,EAAkBvH,KAAK+E,aAAe,GAAzB,EAA8B,EAC7ChC,EAAOuE,EAGX,GAAIvE,EAAKyE,SAAS,KACjB7E,EAASE,OAAQ,EACjBE,EAAOA,EAAKoD,QAAQ,IAAK,IAEzBhD,EAAG,GAAK,EAAIsE,SAAS1E,EAAKiE,UAAU,EAAG,GAAI,IAC3C7D,EAAG,GAAKqB,EAAMkD,QAAQ3E,EAAKiE,UAAU,EAAG,IACxC3D,EAAK,GAAKF,EAAG,GAAKoE,EAClBlE,EAAK,GAAKmB,EAAMkD,QAAQ3E,EAAKiE,UAAU,EAAG,QAGpC,CACN,IAAMW,EAAS,EAAIF,SAAS1E,EAAKiE,UAAU,EAAG,GAAI,IAC5CY,EAASpD,EAAMkD,QAAQ3E,EAAKiE,UAAU,EAAG,IAE/C3D,EAAK,GAAKuE,EACVzE,EAAG,GAAKwE,EACRxE,EAAG,GAAKyE,EACR,IAAK,IAAIrK,EAAIoK,EAASJ,EAAWhK,EAAI,GAAKA,GAAK,EAAGA,GAAKgK,EACtD,GAA0C,OAAtCvH,KAAK8E,MAAMtC,MAAMjF,GAAGqK,GAAQnI,OAC3BO,KAAK8E,MAAMtC,MAAMjF,GAAGqK,GAAQnI,MAAM3B,KAAK0J,SAAS,KAAM,CACzDnE,EAAK,GAAK9F,EACV,OAYJ,OAPAoF,EAASC,MAAMpC,MAAO6C,OAAMF,OAGxBJ,EAAKyE,SAAS,OACjB7E,EAASG,SAAWC,EAAKiE,UAAUjE,EAAKlD,OAAS,EAAGkD,EAAKlD,SAGnD8C,oCAQE2E,GACT,IAAMjE,KACAF,KACAR,GACLC,SACAC,OAAO,EACPC,SAAU,MAEPC,EAAOuE,EACLP,EAAQhE,EAAKiE,UAAU,EAAG,GAYhC,IATAjE,EAAOA,EAAKiE,UAAU,EAAGjE,EAAKlD,SAGrB2H,SAAS,OACjB7E,EAASE,OAAQ,EACjBE,EAAOA,EAAKoD,QAAQ,IAAK,KAIN,IAAhBpD,EAAKlD,OACRwD,EAAK,GAAK,EAAIoE,SAAS1E,EAAKiE,UAAU,EAAG,GAAI,IAC7C3D,EAAK,GAAKmB,EAAMkD,QAAQ3E,EAAKiE,UAAU,EAAG,IAC1C7D,EAAG,GAAK,EAAIsE,SAAS1E,EAAKiE,UAAU,EAAG,GAAI,IAC3C7D,EAAG,GAAKqB,EAAMkD,QAAQ3E,EAAKiE,UAAU,EAAG,IACxCrE,EAASC,MAAMpC,MAAO6C,OAAMF,YAGtB,GAAoB,IAAhBJ,EAAKlD,OAAc,CAC7B,IAAM8H,EAAS,EAAIF,SAAS1E,EAAKiE,UAAU,EAAG,GAAI,IAC5CY,EAASpD,EAAMkD,QAAQ3E,EAAKiE,UAAU,EAAG,IAC3Ca,GAAe,EACfC,GAAe,EAGftD,EAAMkD,QAAQ3E,EAAKiE,UAAU,EAAG,KAAO,EAC1Cc,EAActD,EAAMkD,QAAQ3E,EAAKiE,UAAU,EAAG,IAI9Ca,EAAc,EAAIJ,SAAS1E,EAAKiE,UAAU,EAAG,GAAI,IAElDrE,EAASC,MAAMpC,KACdR,KAAK+H,UAAUJ,EAAQC,EAAQC,EAAaC,EAAaf,QAIpD,CACN,IAAMY,EAAS,EAAIF,SAAS1E,EAAKiE,UAAU,EAAG,GAAI,IAC5CY,EAASpD,EAAMkD,QAAQ3E,EAAKiE,UAAU,EAAG,IAC/CrE,EAASC,MAAMpC,KAAKR,KAAK+H,UAAUJ,EAAQC,GAAS,GAAI,EAAGb,IAG5D,OAAOpE,oCAYEgF,EAAQC,EAAQC,EAAaC,EAAaf,GACnD,IAAIhE,EAmDJ,MAjDc,MAAVgE,EACHhE,EAAO/C,KAAKgI,SACXL,EACAC,EACAC,EACAC,EACAf,GAEmB,MAAVA,EACVhE,EAAO/C,KAAKiI,SACXN,EACAC,EACAC,EACAC,EACAf,GAEmB,MAAVA,GAA2B,MAAVA,GAQL,KAPtBhE,EAAO/C,KAAKiI,SACXN,EACAC,EACAC,EACAC,EACAf,IAEQ1D,KAAK,KACbN,EAAO/C,KAAKgI,SACXL,EACAC,EACAC,EACAC,EACAf,IAGkB,MAAVA,IACVhE,EAAO/C,KAAKkI,WACXP,EACAC,EACAC,EACAC,EACAf,KAGoB,IAAlBhE,EAAKM,KAAK,KACba,QAAQC,IAAR,4BAAAgE,OAC6BpB,EAD7B,SAAAoB,OAC0CR,EAD1C,KAAAQ,OACoDP,EADpD,aAGA5H,KAAK8E,MAAMsD,iBAGLrF,mCAYC4E,EAAQC,EAAQC,EAAaC,EAAaf,GAClD,IAAM7G,EAAQF,KAAK+E,aAAe,EAAI,QAAU,QAE1C1B,KACAF,KACNE,EAAK,IAAM,EACXA,EAAK,IAAM,EACXF,EAAG,GAAKwE,EACRxE,EAAG,GAAKyE,EAER,IAAK,IAAIrK,GAAK,EAAGA,GAAK,EAAGA,GAAK,EAG7B,IAFA,IAAI8K,GAAc,EACdC,GAAc,EACTC,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC9B,IAAMC,EAAOrF,EAAG,GAAK5F,EAAIgL,EACnBE,EAAOtF,EAAG,GAAKoF,EACfG,EAAOvF,EAAG,GAAK5F,EAAIgL,EACnBI,EAAOxF,EAAG,GAAKoF,EAErB,GACCC,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,IACNJ,GACsC,OAAvCrI,KAAK8E,MAAMtC,MAAMgG,GAAMC,GAAMhJ,MAC5B,KACOA,EAAUO,KAAK8E,MAAMtC,MAAMgG,GAAMC,GAAjChJ,MACR,IACCA,EAAM3B,KAAK0J,SAAST,IACpBtH,EAAMS,QAAUA,IACE,IAAjB2H,GAAsBW,IAASX,IACd,IAAjBC,GAAsBW,IAASX,EAQhCO,GAAc,OANd,IAAKrI,KAAK4I,YAAYJ,EAAMC,IAAQtF,EAAG,GAAIA,EAAG,KAG7C,OAFAE,EAAK,GAAKmF,EACVnF,EAAK,GAAKoF,GACDpF,OAAMF,MAOlB,GACCuF,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,IACNL,GACsC,OAAvCtI,KAAK8E,MAAMtC,MAAMkG,GAAMC,GAAMlJ,MAC5B,KACOA,EAAUO,KAAK8E,MAAMtC,MAAMkG,GAAMC,GAAjClJ,MACR,IACCA,EAAM3B,KAAK0J,SAAST,IACpBtH,EAAMS,QAAUA,IACE,IAAjB2H,GAAsBa,IAASb,IACd,IAAjBC,GAAsBa,IAASb,EAQhCQ,GAAc,OANd,IAAKtI,KAAK4I,YAAYF,EAAMC,IAAQxF,EAAG,GAAIA,EAAG,KAG7C,OAFAE,EAAK,GAAKqF,EACVrF,EAAK,GAAKsF,GACDtF,OAAMF,OAQpB,OAASE,OAAMF,uCAYPwE,EAAQC,EAAQC,EAAaC,EAAaf,GAClD,IAAM7G,EAAQF,KAAK+E,aAAe,EAAI,QAAU,QAC1C1B,KACAF,KACNE,EAAK,IAAM,EACXA,EAAK,IAAM,EACXF,EAAG,GAAKwE,EACRxE,EAAG,GAAKyE,EAER,IAAK,IAAIrK,GAAK,EAAGA,GAAK,EAAGA,GAAK,EAG7B,IAFA,IAAI8K,GAAc,EACdC,GAAc,EACTC,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC9B,IAAMC,EAAOrF,EAAG,GACVsF,EAAOtF,EAAG,GAAK5F,EAAIgL,EACnBG,EAAOvF,EAAG,GAAK5F,EAAIgL,EACnBI,EAAOxF,EAAG,GAEhB,GACCqF,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,IACNJ,GACsC,OAAvCrI,KAAK8E,MAAMtC,MAAMgG,GAAMC,GAAMhJ,MAC5B,KACOA,EAAUO,KAAK8E,MAAMtC,MAAMgG,GAAMC,GAAjChJ,MACR,IACCA,EAAM3B,KAAK0J,SAAST,IACpBtH,EAAMS,QAAUA,IACE,IAAjB2H,GAAsBW,IAASX,IACd,IAAjBC,GAAsBW,IAASX,EAQhCO,GAAc,OANd,IAAKrI,KAAK4I,YAAYJ,EAAMC,IAAQtF,EAAG,GAAIA,EAAG,KAG7C,OAFAE,EAAK,GAAKmF,EACVnF,EAAK,GAAKoF,GACDpF,OAAMF,MAMlB,GACCuF,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,IACNL,GACsC,OAAvCtI,KAAK8E,MAAMtC,MAAMkG,GAAMC,GAAMlJ,MAC5B,KACOA,EAAUO,KAAK8E,MAAMtC,MAAMkG,GAAMC,GAAjClJ,MACR,IACCA,EAAM3B,KAAK0J,SAAST,IACpBtH,EAAMS,QAAUA,IACE,IAAjB2H,GAAsBa,IAASb,IACd,IAAjBC,GAAsBa,IAASb,EAQhCQ,GAAc,OANd,IAAKtI,KAAK4I,YAAYF,EAAMC,IAAQxF,EAAG,GAAIA,EAAG,KAG7C,OAFAE,EAAK,GAAKqF,EACVrF,EAAK,GAAKsF,GACDtF,OAAMF,OAQpB,OAASE,OAAMF,yCAYLwE,EAAQC,EAAQC,EAAaC,EAAaf,GACpD,IAAM7G,EAAQF,KAAK+E,aAAe,EAAI,QAAU,QAC1C1B,KACAF,KACNE,EAAK,IAAM,EACXA,EAAK,IAAM,EACXF,EAAG,GAAKwE,EACRxE,EAAG,GAAKyE,EAER,IAAK,IAAIrK,GAAK,EAAGA,GAAK,EAAGA,GAAK,EAC7B,IAAK,IAAIgL,GAAK,EAAGA,GAAK,EAAGA,GAAK,EAAG,CAChC,IAAMC,EAAOrF,EAAG,GAAK5F,EACfkL,EAAOtF,EAAG,GAAKoF,EACfG,EAAOvF,EAAG,GAAKoF,EACfI,EAAOxF,EAAG,GAAK5F,EACrB,GACCiL,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,GACgC,OAAvCzI,KAAK8E,MAAMtC,MAAMgG,GAAMC,GAAMhJ,MAC5B,KACOA,EAAUO,KAAK8E,MAAMtC,MAAMgG,GAAMC,GAAjChJ,MACR,GACCA,EAAM3B,KAAK0J,SAAST,IACpBtH,EAAMS,QAAUA,KACE,IAAjB2H,GAAsBW,IAASX,MACd,IAAjBC,GAAsBW,IAASX,KAE3B9H,KAAK4I,YAAYJ,EAAMC,IAAQtF,EAAG,GAAIA,EAAG,KAG7C,OAFAE,EAAK,GAAKmF,EACVnF,EAAK,GAAKoF,GACDpF,OAAMF,MAIlB,GACCuF,GAAQ,GACRA,EAAO,GACPC,GAAQ,GACRA,EAAO,GACgC,OAAvC3I,KAAK8E,MAAMtC,MAAMkG,GAAMC,GAAMlJ,MAC5B,KACOA,EAAUO,KAAK8E,MAAMtC,MAAMkG,GAAMC,GAAjClJ,MACR,GACCA,EAAM3B,KAAK0J,SAAST,IACpBtH,EAAMS,QAAUA,KACE,IAAjB2H,GAAsBa,IAASb,MACd,IAAjBC,GAAsBa,IAASb,KAE3B9H,KAAK4I,YAAYF,EAAMC,IAAQxF,EAAG,GAAIA,EAAG,KAG7C,OAFAE,EAAK,GAAKqF,EACVrF,EAAK,GAAKsF,GACDtF,OAAMF,OAMpB,OAASE,OAAMF,yCASLE,EAAMF,GAChB,IAAMjD,EAAQF,KAAK+E,aAAe,EAAI,QAAU,QAC1C8D,EAAU7I,KAAK+E,aAAe,EAAI,QAAU,QAC5C+D,EAAO9I,KAAK8E,MAAMxC,OAAiB,UAAVpC,EAAoB,GAAK,GAAGR,IACvDqJ,GAAY,EAGhB,GAAID,EAAK,KAAOzF,EAAK,IAAMyF,EAAK,KAAOzF,EAAK,GAAI,OAAO,EAGvD,IAAM2F,KACNA,EAAK,GAAK3F,EAAK,GAAKyF,EAAK,GACzBE,EAAK,GAAK3F,EAAK,GAAKyF,EAAK,GACzB,IAAMG,KACN,GAAgB,IAAZD,EAAK,IAAwB,IAAZA,EAAK,GACzBC,EAAS,GAAK,IACdA,EAAS,GAAK,QACR,IAAIC,KAAKC,IAAIH,EAAK,MAAQE,KAAKC,IAAIH,EAAK,IAI9C,OAAO,EAHPC,EAAS,GAAK,IACdA,EAAS,GAAK,IAIC,IAAZD,EAAK,KAAUA,EAAK,IAAME,KAAKC,IAAIH,EAAK,KAC5B,IAAZA,EAAK,KAAUA,EAAK,IAAME,KAAKC,IAAIH,EAAK,KAE5C,IAAMI,EAAepJ,KAAK8E,MAAMtC,MAAMa,EAAK,IAAIA,EAAK,IAAI5D,MAClD4J,EAAerJ,KAAK8E,MAAMtC,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAGpDO,KAAK8E,MAAMtC,MAAMa,EAAK,IAAIA,EAAK,IAAI5D,MAAQ,KAC3CO,KAAK8E,MAAMtC,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAAQ2J,EAIvC,IADA,IAAIE,GAAa,EACRf,EAAI,EAAGA,EAAI,IAAMQ,IAAcO,EAAYf,GAAK,EAAG,CAC3D,IAAMnH,EAAM0H,EAAK,GAAKP,EAAIS,EAAK,GACzB1H,EAAMwH,EAAK,GAAKP,EAAIS,EAAK,GAE/B,GACC5H,GAAO,GACPA,EAAM,GACNE,GAAO,GACPA,EAAM,GAC+B,OAArCtB,KAAK8E,MAAMtC,MAAMpB,GAAKE,GAAK7B,MAC1B,KACOA,EAAUO,KAAK8E,MAAMtC,MAAMpB,GAAKE,GAAhC7B,OAENA,EAAM3B,KAAK0J,SAASyB,EAAS,KAC7BxJ,EAAM3B,KAAK0J,SAASyB,EAAS,MAC9BxJ,EAAMS,QAAU2I,EAEhBE,GAAY,EAEZO,GAAa,GAQhB,OAHAtJ,KAAK8E,MAAMtC,MAAMa,EAAK,IAAIA,EAAK,IAAI5D,MAAQ2J,EAC3CpJ,KAAK8E,MAAMtC,MAAMW,EAAG,IAAIA,EAAG,IAAI1D,MAAQ4J,EAEhCN,iCAQDhG,GACN,IAAM3B,EAAMpB,KAAK+E,aAAe,EAAI,EAAI,EAClCwE,KACAC,KACAC,KACAC,KACA/G,GACLC,SACAC,OAAO,EACPC,SAAU,MA2BX,OAvBoB,IAAhBC,EAAKlD,QACR0J,EAAM,GAAKnI,EACXmI,EAAM,GAAK,EACXE,EAAI,GAAKrI,EACTqI,EAAI,GAAK,EACTD,EAAM,GAAKpI,EACXoI,EAAM,GAAK,EACXE,EAAI,GAAKtI,EACTsI,EAAI,GAAK,IAITH,EAAM,GAAKnI,EACXmI,EAAM,GAAK,EACXE,EAAI,GAAKrI,EACTqI,EAAI,GAAK,EACTD,EAAM,GAAKpI,EACXoI,EAAM,GAAK,EACXE,EAAI,GAAKtI,EACTsI,EAAI,GAAK,GAEV/G,EAASC,MAAMpC,MAAO6C,KAAMkG,EAAOpG,GAAIsG,IACvC9G,EAASC,MAAMpC,MAAO6C,KAAMmG,EAAOrG,GAAIuG,IAChC/G,wCA7oBWsC,GAClB,IAAMG,KAaN,OAZAA,EAAIa,UAAYhI,OAAOkB,UAAUC,eAAe1B,KAAKuH,EAAQ,UAC7DG,EAAIiB,OAASjB,EAAIa,UAAYhB,EAAOoB,OAAS,kBAAM,GAEnDjB,EAAI/C,SAAWpE,OAAOkB,UAAUC,eAAe1B,KAAKuH,EAAQ,YACzDA,EAAO5C,SACPsH,IAGHvE,EAAIgB,QAAQnI,OAAOkB,UAAUC,eAAe1B,KAAKuH,EAAQ,UACtDA,EAAOmB,MAGHhB,4CAkoBiBwE,GACxB,IAAM7F,KACA8F,EAAOD,EAAOxD,MAAM,IAI1B,OAHArC,EAAOvD,KAAK,EAAIqJ,EAAK,IACrB9F,EAAOvD,KAAKgE,EAAMkD,QAAQmC,EAAK,KAExB9F,4CAGiBA,GACxB,IAAIjG,EAAO0G,EAAMT,EAAO,IAGxB,OAFAjG,GAAQ,EAAIiG,EAAO,sCAUFhB,GACjB,OAAOA,EAAKoD,QAAQ,aAAc,6ICvrBpC,IAAA2D,mDAAA/H,CAAA1E,EAAA,8KAEQ0M,EAAgB1M,EAAQ,GAAxB0M,YAEFC,EAAK3M,EAAQ,GAEb4E,GAAgB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC1DC,GAAiB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,mBAWhE,SAAA+H,iGAAclK,CAAAC,KAAAiK,GAUbjK,KAAKkK,UAAY,IAAI/I,MAAM,GAM3BnB,KAAKmK,cAAgB,IAAAL,EAAArH,kGAiBXuC,GAA6C,IAAAN,EAAA1E,KAAvCoF,EAAuCxF,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,MAA7BwK,EAA6BxK,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAtB,EAAGsF,EAAmBtF,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAL,IAClD,OAAO,IAAI0F,QAAQ,SAACC,GACnB,IAAM8E,EAAKN,EAAYO,MACvB5F,EAAKyF,cACHI,WAAWvF,EAAMI,EAAKF,GACtBsF,KAAK,SAAC1F,GACN,IAAM2F,KACNA,EAAQrK,MAAQ0E,EAAM1E,MACtBqK,EAAQjI,MAAQsC,EAAMtC,MACtBkC,EAAKwF,UAAUE,GAAQM,KAAKC,MAAMD,KAAKE,UAAUH,IACjD,IAAMI,EAAKd,EAAYO,MACjBQ,EAAQ5B,KAAK6B,MAAMF,EAAKR,GAAM,IAC9BW,EAAM9B,KAAK6B,MAAMN,EAAQrK,MAAMgC,SAAW0I,GAChD5G,QAAQC,IAAR,GAAAgE,OACIsC,EAAQrK,MAAMiC,SADlB,YAAA8F,OAEEsC,EAAQrK,MAAMgC,SAFhB,yBAAA+F,OAGyB2C,EAHzB,OAAA3C,OAGoC6C,EAHpC,cAKAtG,EAAKyF,cAAcvG,QACnB2B,EAAQb,EAAKwF,UAAUE,GAAMhK,MAAMiC,+CAU9B2C,GAAgB,IAAVoF,EAAUxK,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAH,EACrBoK,EAAGiB,UAAUjG,EAAM0F,KAAKE,UAAU5K,KAAKkK,UAAUE,IAAQ,SAACvE,GACrDA,EACH3B,QAAQgH,MAAMrF,GAGf3B,QAAQC,IAAI,4DAULa,EAAMoF,GAGd,OAFApK,KAAKkK,UAAUE,GAAQM,KAAKC,MAAMX,EAAGmB,aAAanG,EAAM,SACxDd,QAAQC,IAAR,SAAAgE,OAAqBnD,EAArB,8BAAAmD,OAAsDiC,EAAtD,MACOpK,KAAKkK,UAAUE,GAAM/H,iDA2Bb+H,EAAMR,EAAQwB,GAM7B,IALA,IAAMrH,EAAS+F,EAAArH,QAAc4I,kBAAkBzB,GACzC0B,KACFC,EAAM,EACNC,EAAM,IAEDjO,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAE9B,IADA,IAAMkO,EAAU,IAAItK,MAAM,GACjBoH,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAC3BkD,EAAQlD,GAAK6C,EAAIpL,KAAKkK,UAAUE,GAAOrG,GAASxG,EAAGgL,IAC/CkD,EAAQlD,GAAKgD,IAAKA,EAAME,EAAQlD,IAChCkD,EAAQlD,GAAKiD,IAAKA,EAAMC,EAAQlD,IAErC+C,EAAI9K,KAAKiL,GAGV,OAAQH,EAAKE,EAAKD,qDAqBO3B,EAAQwB,GASjC,IAT4D,IAAtBM,EAAsB9L,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAd,EAAG+L,EAAW/L,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAH,EACnD0L,KACFC,EAAM,EACNC,EAAM,IAGJI,EAAQ5L,KAAK6L,gBAAgBH,EAAO9B,EAAQwB,GAC5CU,EAAQ9L,KAAK6L,gBAAgBF,EAAO/B,EAAQwB,GAEzC7N,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAE9B,IADA,IAAMkO,EAAU,IAAItK,MAAM,GACjBoH,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC9B,IAAMwD,EAAIH,EAAM,GAAGrO,GAAGgL,GAChByD,EAAIF,EAAM,GAAGvO,GAAGgL,GACEkD,EAAQlD,GAAtB,IAANwD,GAAiB,IAANC,EAAsB,EACiB,KAAnCD,GAAKC,EAAID,EAAIC,EAAI,GAAKA,EAAID,EAAI,GAE7CN,EAAQlD,GAAKgD,IAAKA,EAAME,EAAQlD,IAChCkD,EAAQlD,GAAKiD,IAAKA,EAAMC,EAAQlD,IAErC+C,EAAI9K,KAAKiL,GAGV,OAAQH,EAAKE,EAAKD,0CAGCD,GAEnB,IADA,IAAMW,KACG1O,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAC3B,IAAK,IAAIgL,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC9B,IAAI2D,EAAMZ,EAAI/N,GAAGgL,GACjB2D,EAAMA,EAAIC,QAAQ,GACdjD,KAAKC,IAAI+C,GAAO,OACT,IAAN3O,EAAS0O,EAAKzL,MAAK,IAAA2H,OAAKjG,EAAcqG,IAAM2D,IACjC,IAAN3O,EAAS0O,EAAKzL,MAAK,IAAA2H,OAAKlG,EAAasG,IAAM2D,IACrC,IAAN3O,EAAS0O,EAAKzL,MAAK,IAAA2H,OAAKlG,EAAasG,IAAM2D,IACrC,IAAN3O,GAAS0O,EAAKzL,MAAK,IAAA2H,OAAKjG,EAAcqG,IAAM2D,KAKxD,OADAD,EAAKG,KAAK,SAACL,EAAGC,GAAJ,OAAUA,EAAE,GAAKD,EAAE,KACtBE,kMC3MTlK,CAAA1E,EAAA","file":"chessalyzer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"chessalyzer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"chessalyzer\"] = factory();\n\telse\n\t\troot[\"chessalyzer\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","module.exports = require(\"fs\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"events\");","module.exports = require(\"line-by-line\");","/**\n * Class that represents a chess piece and tracks statistics.\n */\nclass ChessPiece {\n\t/**\n\t * Creates a new ChessPiece.\n\t * @param {String} piece The name of the piece, e.g. 'Pd' for a D pawn.\n\t * @param {Number[]} pos Row and column the piece is on at start.\n\t * @param {Boolean} [promoted=false] Denotes if this piece is created by pawn promotion.\n\t */\n\tconstructor(piece, pos, promoted = false) {\n\t\t/**\n\t\t * Name of the piece, e.g 'Pb' for the b pawn\n\t\t * @member {String}\n\t\t */\n\t\tthis.name = piece; // piece type\n\n\t\t/**\n\t\t * Current position of this piece: [row,col], with [0,0] being the top left square\n\t\t * @member {Number[]}\n\t\t */\n\t\tthis.pos = pos; // current position in [row, col] notation\n\n\t\t/**\n\t\t * Starting position of this piece: [row,col], with [0,0] being the top left square\n\t\t * @member {Number[]}\n\t\t */\n\t\tthis.defaultPos = pos; // starting position of this piece\n\n\t\t/**\n\t\t * Color of this piece: 'black' or 'white'\n\t\t * @member {String}\n\t\t */\n\t\tthis.color = '';\n\t\tif (promoted) {\n\t\t\tthis.color = this.defaultPos[0] <= 1 ? 'white' : 'black'; // color of piece: 0 white, 1 black\n\t\t} else {\n\t\t\tthis.color = this.defaultPos[0] <= 1 ? 'black' : 'white'; // color of piece: 0 white, 1 black\n\t\t}\n\n\t\tthis.alive = true; // piece alive?\n\n\t\t/**\n\t\t * Object that contains the tracked statistics\n\t\t * @member {Object}\n\t\t */\n\t\tthis.stats = {};\n\n\t\t/**\n\t\t * Is this piece alive?\n\t\t * @member {Object}\n\t\t */\n\n\t\tthis.initStats();\n\n\t\t// option to track the move history of each piece\n\t\t// currently unused, costs a lot of performance\n\t\tthis.logHistory = false;\n\t\tthis.history = []; // position history\n\t\tthis.history.push(pos);\n\t\tthis.maxHistory = 2000; // max length of history array\n\t}\n\n\t/**\n\t * Resets this piece to its default position and denotes a new game in the move history tracker.\n\t * @private\n\t */\n\treset() {\n\t\tif (this.logHistory && this.history.length < this.maxHistory) {\n\t\t\tthis.history.push(null);\n\t\t\tthis.history.push(this.defaultPos);\n\t\t}\n\n\t\tthis.pos = this.defaultPos;\n\t\tthis.alive = true;\n\t}\n\n\t/**\n\t * Moves this piece to a new position and updates move statistics.\n\t * @private\n\t * @param {Number[]} pos Target row and column of the tile the piece shall move to.\n\t */\n\tupdatePosition(pos) {\n\t\tthis.stats.cntMoved += 1;\n\t\tthis.pos = pos;\n\t\tif (this.logHistory && this.history.length < this.maxHistory) {\n\t\t\tthis.history.push(pos);\n\t\t}\n\t\tthis.stats.at[pos[0]][pos[1]].movedTo += 1;\n\t}\n\n\t/**\n\t * Marks this piece as taken and updates the statistics of the piece it was taken by.\n\t * @private\n\t * @param {ChessPiece} killedBy Piece this piece was taken by.\n\t */\n\tkillPiece(killedByPiece) {\n\t\tthis.alive = false;\n\t\tthis.stats.cntWasKilled += 1;\n\n\t\t// if killer is not promoted pawn...\n\t\tif (!(killedByPiece.name.length === 1 || this.name.length === 1)) {\n\t\t\t// update killedBy of this piece\n\t\t\tthis.stats.at[killedByPiece.defaultPos[0]][\n\t\t\t\tkilledByPiece.defaultPos[1]\n\t\t\t].killedBy += 1;\n\t\t}\n\t}\n\n\tkilledPiece(killedPiece) {\n\t\tthis.stats.cntHasKilled += 1;\n\n\t\t// if killer is not promoted pawn...\n\t\tif (!(killedPiece.name.length === 1 || this.name.length === 1)) {\n\t\t\t// update killed stat of killer piece\n\t\t\tthis.stats.at[killedPiece.defaultPos[0]][\n\t\t\t\tkilledPiece.defaultPos[1]\n\t\t\t].killed += 1;\n\t\t}\n\t}\n\n\t/**\n\t * Inits the statistics array of this piece.\n\t * @private\n\t */\n\tinitStats() {\n\t\tthis.stats = { cntMoved: 0, cntWasKilled: 0, cntHasKilled: 0 };\n\t\tthis.stats.at = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = { movedTo: 0, killedBy: 0, killed: 0 };\n\t\t\t}\n\t\t\tthis.stats.at[row] = currRow;\n\t\t}\n\t}\n}\n\nexport default ChessPiece;\n","/** Class that represents a single Tile. Tracks statistics for itself. */\nclass ChessTile {\n\t/** Creates a new Tile. */\n\tconstructor() {\n\t\t/**\n\t\t * Piece that is currently on this tile.\n\t\t * @member {ChessPiece}\n\t\t */\n\t\tthis.piece = null;\n\n\t\t/**\n\t\t * Piece that is on this tile at start of game.\n\t\t * @member {ChessPiece}\n\t\t */\n\t\tthis.defaultPiece = null;\n\n\t\t/**\n\t\t * Object that contains the tracked statistics\n\t\t * @member {Object}\n\t\t */\n\t\tthis.stats = {};\n\n\t\tthis.initStats();\n\t}\n\n\t/**\n\t * Places a piece on this tile. Should only be called at board init.\n\t * @private\n\t * @param {ChessPiece} piece The piece that is on this square by default.\n\t */\n\tinitPiece(piece) {\n\t\tthis.piece = piece;\n\t\tthis.defaultPiece = piece;\n\t}\n\n\t/**\n\t * Sets the currently active piece of this square to the default piece.\n\t * @private\n\t */\n\tresetPiece() {\n\t\tthis.piece = this.defaultPiece;\n\t}\n\n\t/**\n\t * Updates the statistics of this tile.\n\t * @private\n\t */\n\tupdateOccupationStats() {\n\t\t// this.stats.cntHasPiece[this.piece.color] is slow for some reason, so use if\n\t\tif (this.piece.color === 'white') {\n\t\t\tthis.stats.cntHasPiece.white += 1;\n\t\t} else {\n\t\t\tthis.stats.cntHasPiece.black += 1;\n\t\t}\n\n\t\t// only non-promoted pieces are counted\n\t\tif (this.piece.name.length !== 1) {\n\t\t\tthis.stats.at[this.piece.defaultPos[0]][\n\t\t\t\tthis.piece.defaultPos[1]\n\t\t\t].wasOnTile += 1;\n\t\t}\n\t}\n\n\tupdateDeadCount() {\n\t\tthis.stats.cntTakenPieces += 1;\n\t}\n\n\t/**\n\t * Inits the statistics array. Is called by the constructor.\n\t * @private\n\t */\n\tinitStats() {\n\t\tthis.stats.cntHasPiece = { white: 0, black: 0 };\n\t\tthis.stats.cntTakenPieces = 0;\n\n\t\tthis.stats.at = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = { wasOnTile: 0 };\n\t\t\t}\n\t\t\tthis.stats.at[row] = currRow;\n\t\t}\n\t}\n}\n\nexport default ChessTile;\n","import ChessTile from './ChessTile';\nimport ChessPiece from './ChessPiece';\n\nconst pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\nconst pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n/** Class that contains the board status and tracks statistics. */\nclass ChessBoard {\n\t/** Creates a new 8x8 Chessboard out of 64 {@link ChessTile}s and 32 {@link ChessPiece}s */\n\tconstructor() {\n\t\t/**\n\t\t * Tracks number of moves and games\n\t\t * @member {Object}\n\t\t */\n\t\tthis.stats = {\n\t\t\tcntMoves: 0,\n\t\t\tcntGames: 0\n\t\t};\n\n\t\t/**\n\t\t * Contains all pieces on the board\n\t\t * @member {ChessPiece[]}\n\t\t */\n\t\tthis.pieces = [];\n\n\t\tthis.alivePieces = [];\n\n\t\t/**\n\t\t * 8x8 array of {@link ChessTile}s\n\t\t * @member {Array[]}\n\t\t */\n\t\tthis.tiles = new Array(8);\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst currRow = new Array(8);\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tcurrRow[col] = new ChessTile();\n\n\t\t\t\t// init pieces\n\t\t\t\tif (row === 0 || row === 7) {\n\t\t\t\t\tthis.pieces.push(\n\t\t\t\t\t\tnew ChessPiece(pieceTemplate[col], [row, col])\n\t\t\t\t\t);\n\t\t\t\t\tcurrRow[col].initPiece(this.pieces[this.pieces.length - 1]);\n\t\t\t\t} else if (row === 1 || row === 6) {\n\t\t\t\t\tthis.pieces.push(\n\t\t\t\t\t\tnew ChessPiece(pawnTemplate[col], [row, col])\n\t\t\t\t\t);\n\t\t\t\t\tcurrRow[col].initPiece(this.pieces[this.pieces.length - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.tiles[row] = currRow;\n\t\t}\n\t}\n\n\t/**\n\t * Moves a piece from source to target. Automatically handles the events 'move',\n\t *  'take', 'en passant', 'castle' and 'promote'.\n\t * Use this function instead of {@link ChessBoard#processMove} to input a move to the board!\n\t * @param {Object} moveData\n\t * @param {Object[]} moveData.moves - An array containing up to 2 moves in the\n\t *  syntax {from: [], to: []}\n\t * @param {Boolean} moveData.takes - True if the move takes a piece\n\t * @param {String} moveData.promotes - Type of promoted piece in case of pawn promotion, else null\n\t */\n\tmove(moveData) {\n\t\tif (moveData !== null) {\n\t\t\tthis.stats.cntMoves += 1;\n\n\t\t\tconst { moves } = moveData;\n\t\t\tconst { takes } = moveData;\n\t\t\tconst { promotes } = moveData;\n\n\t\t\t// move\n\t\t\tif (moves.length === 1) {\n\t\t\t\tconst move = moves[0];\n\n\t\t\t\tif (takes) {\n\t\t\t\t\tthis.processTakes(move);\n\t\t\t\t}\n\n\t\t\t\tthis.processMove(move);\n\n\t\t\t\tif (promotes !== null) {\n\t\t\t\t\tthis.promotePiece(move.to, promotes);\n\t\t\t\t}\n\t\t\t\t// castle\n\t\t\t} else {\n\t\t\t\tthis.processMove(moves[0]);\n\t\t\t\tthis.processMove(moves[1]);\n\t\t\t}\n\n\t\t\tthis.updateTileStats();\n\t\t}\n\t}\n\n\t/**\n\t * Handles the 'takes' processing commanded by {@link ChessBoard#move}.\n\t * Don't call this function directly, use {@link ChessBoard#move} to input a move!\n\t * @private\n\t * @param {Object} move\n\t * @param {Number[]} move.from - Coordinates of start tile\n\t * @param {Number[]} move.to - Coordinates of target tile\n\t */\n\tprocessTakes(move) {\n\t\tconst { from } = move;\n\t\tconst { to } = move;\n\t\tlet offset = 0;\n\n\t\t// en passant\n\t\tif (this.tiles[to[0]][to[1]].piece === null) {\n\t\t\toffset =\n\t\t\t\tthis.tiles[from[0]][from[1]].piece.color === 'white' ? 1 : -1;\n\t\t}\n\t\tconst toPiece = this.tiles[to[0] + offset][to[1]].piece;\n\t\tconst fromPiece = this.tiles[from[0]][from[1]].piece;\n\n\t\ttoPiece.killPiece(fromPiece);\n\t\tfromPiece.killedPiece(toPiece);\n\n\t\tthis.tiles[to[0] + offset][to[1]].piece = null;\n\t\tthis.tiles[to[0] + offset][to[1]].updateDeadCount();\n\t}\n\n\t/**\n\t * Handles the 'move' processing commanded by {@link ChessBoard#move}.\n\t * Don't call this function directly, use {@link ChessBoard#move} to input a move!\n\t * @private\n\t * @param {Object} move\n\t * @param {Number[]} move.from - Coordinates of start tile\n\t * @param {Number[]} move.to - Coordinates of target tile\n\t */\n\tprocessMove(move) {\n\t\tconst { from } = move;\n\t\tconst { to } = move;\n\n\t\tthis.tiles[to[0]][to[1]].piece = this.tiles[from[0]][from[1]].piece;\n\t\tthis.tiles[to[0]][to[1]].piece.updatePosition(to);\n\t\tthis.tiles[from[0]][from[1]].piece = null;\n\t}\n\n\t/** Resets the board to the default state: removes promoted pieces and puts the standard\n\t *  pieces back to their starting positions.\n\t *\n\t *  Does not reset the stats recorded. If you wish to reset the stats,\n\t *  call {@link ChessBoard#resetStats}. */\n\treset() {\n\t\tthis.stats.cntGames += 1;\n\t\t// reset the pieces to default\n\t\tfor (let i = 0; i < this.pieces.length; i += 1) {\n\t\t\tthis.pieces[i].reset();\n\t\t}\n\n\t\t// remove promoted pieces\n\t\tthis.pieces = this.pieces.slice(0, 32);\n\n\t\t// reset the tiles\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tthis.tiles[row][col].resetPiece();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Resets the stats recorded. */\n\tresetStats() {\n\t\t// reset the tiles\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tthis.tiles[row][col].initStats();\n\t\t\t}\n\t\t}\n\n\t\t// reset the pieces to default\n\t\tfor (let i = 0; i < this.pieces.length; i += 1) {\n\t\t\tthis.pieces[i].initStats();\n\t\t}\n\n\t\tthis.stats.cntMoves = 0;\n\t\tthis.stats.cntGames = 0;\n\t}\n\n\t/**\n\t * Promotes a pawn to a piece.\n\t * @private\n\t * @param {Number[]} coords An array containing the row and column of the pawn to be promoted.\n\t * @param {String} pieceType Target piece type in SAN notation ('N', 'B', 'Q', 'R').\n\t */\n\tpromotePiece(coords, pieceType) {\n\t\t// change alive directly instead of killPiece to not update stats\n\t\tthis.tiles[coords[0]][coords[1]].piece.alive = false;\n\t\tthis.tiles[coords[0]][coords[1]].piece = null;\n\n\t\tthis.pieces.push(\n\t\t\tnew ChessPiece(pieceType, [coords[0], coords[1]], true)\n\t\t);\n\t\tthis.tiles[coords[0]][coords[1]].piece = this.pieces[\n\t\t\tthis.pieces.length - 1\n\t\t];\n\t}\n\n\t/** Prints the current board position to the console. */\n\tprintPosition() {\n\t\tfor (let row = 0; row < 8; row += 1) {\n\t\t\tconst rowArray = [];\n\t\t\tfor (let col = 0; col < 8; col += 1) {\n\t\t\t\tconst { piece } = this.tiles[row][col];\n\t\t\t\tif (piece !== null) {\n\t\t\t\t\trowArray.push(piece.name);\n\t\t\t\t} else {\n\t\t\t\t\trowArray.push('..');\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(rowArray);\n\t\t}\n\t}\n\n\t/** Is called after each {@link ChessBoard#move} to record the stats for the ChessTiles.\n\t * Only every tile, that has a piece on it, is updated.\n\t * @private\n\t */\n\tupdateTileStats() {\n\t\tfor (let i = 0; i < 32; i += 1) {\n\t\t\tif (this.pieces[i].alive) {\n\t\t\t\tthis.tiles[this.pieces[i].pos[0]][\n\t\t\t\t\tthis.pieces[i].pos[1]\n\t\t\t\t].updateOccupationStats();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport default ChessBoard;\n","import ChessBoard from './ChessBoard';\n\nconst LineByLineReader = require('line-by-line');\nconst EventEmitter = require('events');\n\nconst files = 'abcdefgh';\n\n/**\n * Class that processes games.\n */\nclass GameProcessor extends EventEmitter {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.board = new ChessBoard();\n\t\tthis.activePlayer = 0;\n\t}\n\n\tstatic checkConfig(config) {\n\t\tconst cfg = {};\n\t\tcfg.hasFilter = Object.prototype.hasOwnProperty.call(config, 'filter');\n\t\tcfg.filter = cfg.hasFilter ? config.filter : () => true;\n\n\t\tcfg.cntGames = Object.prototype.hasOwnProperty.call(config, 'cntGames')\n\t\t\t? config.cntGames\n\t\t\t: Infinity;\n\n\t\t// TODO: currently without function\n\t\tcfg.split = Object.prototype.hasOwnProperty.call(config, 'split')\n\t\t\t? config.split\n\t\t\t: false;\n\n\t\treturn cfg;\n\t}\n\n\tprocessPGN(path, config, refreshRate) {\n\t\tconst cfg = GameProcessor.checkConfig(config);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst lr = new LineByLineReader(path, { skipEmptyLines: true });\n\t\t\tlet game = {};\n\n\t\t\t// process current line\n\t\t\tconst processLine = (line) => {\n\t\t\t\t// data tag\n\t\t\t\tif (line.startsWith('[') && cfg.hasFilter) {\n\t\t\t\t\tconst key = line.match(/\\[(.*?)\\s/)[1];\n\t\t\t\t\tconst value = line.match(/\"(.*?)\"/)[1];\n\n\t\t\t\t\tgame[key] = value;\n\n\t\t\t\t\t// moves\n\t\t\t\t} else if (line.startsWith('1')) {\n\t\t\t\t\tgame.moves = line\n\t\t\t\t\t\t.replace(/\\{(.*?)\\}\\s/g, '')\n\t\t\t\t\t\t.replace(/\\d+\\.+\\s/g, '')\n\t\t\t\t\t\t.replace(' *', '')\n\t\t\t\t\t\t.split(' ');\n\n\t\t\t\t\tif (cfg.filter(game) || !cfg.hasFilter) {\n\t\t\t\t\t\tthis.processGame(game);\n\t\t\t\t\t}\n\n\t\t\t\t\t// emit event\n\t\t\t\t\tif (this.board.stats.cntGames % refreshRate === 0) {\n\t\t\t\t\t\tthis.emit('status', this.board.stats.cntGames);\n\t\t\t\t\t}\n\n\t\t\t\t\tgame = {};\n\t\t\t\t}\n\t\t\t\tif (this.board.stats.cntGames >= cfg.cntGames) {\n\t\t\t\t\tlr.close();\n\t\t\t\t\tlr.end();\n\t\t\t\t} else {\n\t\t\t\t\tlr.resume();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlr.on('error', (err) => {\n\t\t\t\tconsole.log(err);\n\t\t\t\treject();\n\t\t\t});\n\n\t\t\tlr.on('line', (line) => {\n\t\t\t\t// pause emitting of lines...\n\t\t\t\tlr.pause();\n\n\t\t\t\tprocessLine(line);\n\t\t\t});\n\n\t\t\tlr.on('end', () => {\n\t\t\t\tconsole.log('Read entire file.');\n\t\t\t\tresolve(this.board);\n\t\t\t});\n\t\t});\n\t}\n\n\tprocessGame(game) {\n\t\tconst { moves } = game;\n\n\t\tfor (let i = 0; i < moves.length; i += 1) {\n\t\t\tthis.activePlayer = i % 2;\n\t\t\tconst moveData = this.parseMove(moves[i]);\n\t\t\tthis.board.move(moveData);\n\t\t}\n\t\tthis.board.reset();\n\t}\n\n\treset() {\n\t\tthis.board.reset();\n\t\tthis.board.resetStats();\n\t\tthis.activePlayer = 0;\n\t}\n\n\t/**\n\t * @typedef {Object} MoveData\n\t * @property {Object[]} moves - Array of {from: [], to: []} objects\n\t * @property {Boolean} takes - Move takes a piece true/false\n\t * @property {String} promotes - Piece type in case of pawn promotion else null\n\t */\n\n\t/**\n\t * Parses a move in string format to board coordinates. Wrapper function for\n\t *  the different move algorithms.\n\t * @param {string} rawMove The move to be parsed, e.g. 'Ne5+'.\n\t * @returns {MoveData}\n\t */\n\tparseMove(rawMove) {\n\t\tconst token = rawMove.substring(0, 1);\n\t\tlet moveData = {};\n\n\t\tconst move = GameProcessor.preProcess(rawMove);\n\n\t\t// game end on '1-0', '0-1' or '1/2-1/2' (check for digit as first char)\n\t\tif (token.match(/\\d/) !== null) {\n\t\t\tmoveData = null;\n\t\t} else if (token.toLowerCase() === token) {\n\t\t\tmoveData = this.pawnMove(move);\n\t\t} else if (token !== 'O') {\n\t\t\tmoveData = this.pieceMove(move);\n\t\t} else {\n\t\t\tmoveData = this.castle(move);\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Returns the board coordinates for the move if it is a pawn move.\n\t * @param {string} moveSan The move to be parsed, e.g. 'e5'.\n\t * @returns {MoveData}\n\t */\n\tpawnMove(moveSan) {\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\t\tconst direction = -2 * (this.activePlayer % 2) + 1;\n\t\tlet move = moveSan;\n\n\t\t// takes\n\t\tif (move.includes('x')) {\n\t\t\tmoveData.takes = true;\n\t\t\tmove = move.replace('x', '');\n\n\t\t\tto[0] = 8 - parseInt(move.substring(2, 3), 10);\n\t\t\tto[1] = files.indexOf(move.substring(1, 2));\n\t\t\tfrom[0] = to[0] + direction;\n\t\t\tfrom[1] = files.indexOf(move.substring(0, 1));\n\n\t\t\t// moves\n\t\t} else {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(0, 1));\n\n\t\t\tfrom[1] = tarCol;\n\t\t\tto[0] = tarRow;\n\t\t\tto[1] = tarCol;\n\t\t\tfor (let i = tarRow + direction; i < 8 && i >= 0; i += direction) {\n\t\t\t\tif (this.board.tiles[i][tarCol].piece !== null) {\n\t\t\t\t\tif (this.board.tiles[i][tarCol].piece.name.includes('P')) {\n\t\t\t\t\t\tfrom[0] = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmoveData.moves.push({ from, to });\n\n\t\t// promotes\n\t\tif (move.includes('=')) {\n\t\t\tmoveData.promotes = move.substring(move.length - 1, move.length);\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Returns the board coordinates for a piece (!= pawn) move.\n\t * @param {string} moveSan The move to be parsed, e.g. 'Be3'.\n\t * @returns {MoveData}\n\t */\n\tpieceMove(moveSan) {\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\t\tlet move = moveSan;\n\t\tconst token = move.substring(0, 1);\n\n\t\t// remove token\n\t\tmove = move.substring(1, move.length);\n\n\t\t// takes\n\t\tif (move.includes('x')) {\n\t\t\tmoveData.takes = true;\n\t\t\tmove = move.replace('x', '');\n\t\t}\n\n\t\t// e.g. Re3f5\n\t\tif (move.length === 4) {\n\t\t\tfrom[0] = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tfrom[1] = files.indexOf(move.substring(0, 1));\n\t\t\tto[0] = 8 - parseInt(move.substring(3, 4), 10);\n\t\t\tto[1] = files.indexOf(move.substring(2, 3));\n\t\t\tmoveData.moves.push({ from, to });\n\n\t\t\t// e.g. Ref3\n\t\t} else if (move.length === 3) {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(2, 3), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(1, 2));\n\t\t\tlet mustBeInRow = -1;\n\t\t\tlet mustBeInCol = -1;\n\n\t\t\t// file is specified\n\t\t\tif (files.indexOf(move.substring(0, 1)) >= 0) {\n\t\t\t\tmustBeInCol = files.indexOf(move.substring(0, 1));\n\n\t\t\t\t// rank is specified\n\t\t\t} else {\n\t\t\t\tmustBeInRow = 8 - parseInt(move.substring(0, 1), 10);\n\t\t\t}\n\t\t\tmoveData.moves.push(\n\t\t\t\tthis.findPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token)\n\t\t\t);\n\n\t\t\t// e.g. Rf3\n\t\t} else {\n\t\t\tconst tarRow = 8 - parseInt(move.substring(1, 2), 10);\n\t\t\tconst tarCol = files.indexOf(move.substring(0, 1));\n\t\t\tmoveData.moves.push(this.findPiece(tarRow, tarCol, -1, -1, token));\n\t\t}\n\n\t\treturn moveData;\n\t}\n\n\t/**\n\t * Wrapper function for different piece search algorithms.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindPiece(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tlet move;\n\n\t\tif (token === 'R') {\n\t\t\tmove = this.findLine(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t} else if (token === 'B') {\n\t\t\tmove = this.findDiag(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t} else if (token === 'Q' || token === 'K') {\n\t\t\tmove = this.findDiag(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t\tif (move.from[0] === -1) {\n\t\t\t\tmove = this.findLine(\n\t\t\t\t\ttarRow,\n\t\t\t\t\ttarCol,\n\t\t\t\t\tmustBeInRow,\n\t\t\t\t\tmustBeInCol,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (token === 'N') {\n\t\t\tmove = this.findKnight(\n\t\t\t\ttarRow,\n\t\t\t\ttarCol,\n\t\t\t\tmustBeInRow,\n\t\t\t\tmustBeInCol,\n\t\t\t\ttoken\n\t\t\t);\n\t\t}\n\t\tif (move.from[0] === -1) {\n\t\t\tconsole.log(\n\t\t\t\t`Error: no piece for move ${token} to (${tarRow},${tarCol}) found!`\n\t\t\t);\n\t\t\tthis.board.printPosition();\n\t\t}\n\n\t\treturn move;\n\t}\n\n\t/**\n\t * Search algorithm to find a piece that can move diagonally.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindDiag(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -1; i <= 1; i += 2) {\n\t\t\tlet obstructed1 = false;\n\t\t\tlet obstructed2 = false;\n\t\t\tfor (let j = 1; j < 8; j += 1) {\n\t\t\t\tconst row1 = to[0] + i * j;\n\t\t\t\tconst col1 = to[1] + j;\n\t\t\t\tconst row2 = to[0] - i * j;\n\t\t\t\tconst col2 = to[1] - j;\n\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\t!obstructed1 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\t!obstructed2 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed2 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Search algorithm to find a piece that can move vertically/horizontally.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindLine(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -1; i <= 1; i += 2) {\n\t\t\tlet obstructed1 = false;\n\t\t\tlet obstructed2 = false;\n\t\t\tfor (let j = 1; j < 8; j += 1) {\n\t\t\t\tconst row1 = to[0];\n\t\t\t\tconst col1 = to[1] - i * j;\n\t\t\t\tconst row2 = to[0] - i * j;\n\t\t\t\tconst col2 = to[1];\n\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\t!obstructed1 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\t!obstructed2 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobstructed2 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Search algorithm to find a matching knight.\n\t * @param {number} tarRow Target row for piece move.\n\t * @param {number} tarCol Target column for piece move.\n\t * @param {number} mustBeInRow Moving piece must be in this row. '-1' if unknown.\n\t * @param {number} mustBeInCol Moving piece must be in this column. '-1' if unknown.\n\t * @param {string} token Moving piece must be of this type, e.g 'R'.\n\t * @returns {Object}\n\t */\n\tfindKnight(tarRow, tarCol, mustBeInRow, mustBeInCol, token) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst from = [];\n\t\tconst to = [];\n\t\tfrom[0] = -1;\n\t\tfrom[1] = -1;\n\t\tto[0] = tarRow;\n\t\tto[1] = tarCol;\n\n\t\tfor (let i = -2; i <= 2; i += 4) {\n\t\t\tfor (let j = -1; j <= 1; j += 2) {\n\t\t\t\tconst row1 = to[0] + i;\n\t\t\t\tconst col1 = to[1] + j;\n\t\t\t\tconst row2 = to[0] + j;\n\t\t\t\tconst col2 = to[1] + i;\n\t\t\t\tif (\n\t\t\t\t\trow1 >= 0 &&\n\t\t\t\t\trow1 < 8 &&\n\t\t\t\t\tcol1 >= 0 &&\n\t\t\t\t\tcol1 < 8 &&\n\t\t\t\t\tthis.board.tiles[row1][col1].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row1][col1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row1 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col1 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row1, col1], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row1;\n\t\t\t\t\t\t\tfrom[1] = col1;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\trow2 >= 0 &&\n\t\t\t\t\trow2 < 8 &&\n\t\t\t\t\tcol2 >= 0 &&\n\t\t\t\t\tcol2 < 8 &&\n\t\t\t\t\tthis.board.tiles[row2][col2].piece !== null\n\t\t\t\t) {\n\t\t\t\t\tconst { piece } = this.board.tiles[row2][col2];\n\t\t\t\t\tif (\n\t\t\t\t\t\tpiece.name.includes(token) &&\n\t\t\t\t\t\tpiece.color === color &&\n\t\t\t\t\t\t(mustBeInRow === -1 || row2 === mustBeInRow) &&\n\t\t\t\t\t\t(mustBeInCol === -1 || col2 === mustBeInCol)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!this.checkCheck([row2, col2], [to[0], to[1]])) {\n\t\t\t\t\t\t\tfrom[0] = row2;\n\t\t\t\t\t\t\tfrom[1] = col2;\n\t\t\t\t\t\t\treturn { from, to };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { from, to };\n\t}\n\n\t/**\n\t * Checks if the input move would be resulting with the king being in check.\n\t * @param {Number[]} from Coordinates of the source tile of the move that shall be checked.\n\t *  @param {Number[]} to Coordinates of the target tile of the move that shall be checked.\n\t * @returns {boolean} After the move, the king will be in check true/false.\n\t */\n\tcheckCheck(from, to) {\n\t\tconst color = this.activePlayer % 2 ? 'black' : 'white';\n\t\tconst opColor = this.activePlayer % 2 ? 'white' : 'black';\n\t\tconst king = this.board.pieces[color === 'white' ? 28 : 4].pos;\n\t\tlet isInCheck = false;\n\n\t\t// if king move, no check is possible, exit function\n\t\tif (king[0] === from[0] && king[1] === from[1]) return false;\n\n\t\t// check if moving piece is on same line/diag as king, else exit\n\t\tconst diff = [];\n\t\tdiff[0] = from[0] - king[0];\n\t\tdiff[1] = from[1] - king[1];\n\t\tconst checkFor = [];\n\t\tif (diff[0] === 0 || diff[1] === 0) {\n\t\t\tcheckFor[0] = 'Q';\n\t\t\tcheckFor[1] = 'R';\n\t\t} else if (Math.abs(diff[0]) === Math.abs(diff[1])) {\n\t\t\tcheckFor[0] = 'Q';\n\t\t\tcheckFor[1] = 'B';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tif (diff[0] !== 0) diff[0] /= Math.abs(diff[0]);\n\t\tif (diff[1] !== 0) diff[1] /= Math.abs(diff[1]);\n\n\t\tconst srcTilePiece = this.board.tiles[from[0]][from[1]].piece;\n\t\tconst tarTilePiece = this.board.tiles[to[0]][to[1]].piece;\n\n\t\t// premove and check if check\n\t\tthis.board.tiles[from[0]][from[1]].piece = null;\n\t\tthis.board.tiles[to[0]][to[1]].piece = srcTilePiece;\n\n\t\t// check for check\n\t\tlet obstructed = false;\n\t\tfor (let j = 1; j < 8 && !isInCheck && !obstructed; j += 1) {\n\t\t\tconst row = king[0] + j * diff[0];\n\t\t\tconst col = king[1] + j * diff[1];\n\n\t\t\tif (\n\t\t\t\trow >= 0 &&\n\t\t\t\trow < 8 &&\n\t\t\t\tcol >= 0 &&\n\t\t\t\tcol < 8 &&\n\t\t\t\tthis.board.tiles[row][col].piece !== null\n\t\t\t) {\n\t\t\t\tconst { piece } = this.board.tiles[row][col];\n\t\t\t\tif (\n\t\t\t\t\t(piece.name.includes(checkFor[0]) ||\n\t\t\t\t\t\tpiece.name.includes(checkFor[1])) &&\n\t\t\t\t\tpiece.color === opColor\n\t\t\t\t) {\n\t\t\t\t\tisInCheck = true;\n\t\t\t\t} else {\n\t\t\t\t\tobstructed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.board.tiles[from[0]][from[1]].piece = srcTilePiece;\n\t\tthis.board.tiles[to[0]][to[1]].piece = tarTilePiece;\n\n\t\treturn isInCheck;\n\t}\n\n\t/**\n\t * Returns the board coordinates for castling.\n\t * @param {string} move The move to be parsed, e.g. 'O-O'.\n\t * @returns {MoveData.moves}\n\t */\n\tcastle(move) {\n\t\tconst row = this.activePlayer % 2 ? 0 : 7;\n\t\tconst from1 = [];\n\t\tconst from2 = [];\n\t\tconst to1 = [];\n\t\tconst to2 = [];\n\t\tconst moveData = {\n\t\t\tmoves: [],\n\t\t\ttakes: false,\n\t\t\tpromotes: null\n\t\t};\n\n\t\t// O-O\n\t\tif (move.length === 3) {\n\t\t\tfrom1[0] = row;\n\t\t\tfrom1[1] = 4;\n\t\t\tto1[0] = row;\n\t\t\tto1[1] = 6;\n\t\t\tfrom2[0] = row;\n\t\t\tfrom2[1] = 7;\n\t\t\tto2[0] = row;\n\t\t\tto2[1] = 5;\n\n\t\t\t// O-O-O\n\t\t} else {\n\t\t\tfrom1[0] = row;\n\t\t\tfrom1[1] = 4;\n\t\t\tto1[0] = row;\n\t\t\tto1[1] = 2;\n\t\t\tfrom2[0] = row;\n\t\t\tfrom2[1] = 0;\n\t\t\tto2[0] = row;\n\t\t\tto2[1] = 3;\n\t\t}\n\t\tmoveData.moves.push({ from: from1, to: to1 });\n\t\tmoveData.moves.push({ from: from2, to: to2 });\n\t\treturn moveData;\n\t}\n\n\tstatic algebraicToCoords(square) {\n\t\tconst coords = [];\n\t\tconst temp = square.split('');\n\t\tcoords.push(8 - temp[1]);\n\t\tcoords.push(files.indexOf(temp[0]));\n\n\t\treturn coords;\n\t}\n\n\tstatic coordsToAlgebraic(coords) {\n\t\tlet name = files[coords[1]];\n\t\tname += 8 - coords[0];\n\n\t\treturn name;\n\t}\n\n\t/**\n\t * Removes special characters like '#', '+', '?' and '!'\n\t * @param {string} move The move to be cleaned up\n\t * @returns {string} The input string with removed special characters\n\t */\n\tstatic preProcess(move) {\n\t\treturn move.replace(/#|\\+|\\?|!/g, '');\n\t}\n}\n\nexport default GameProcessor;\n","import GameProcessor from './GameProcessor';\n\nconst { performance } = require('perf_hooks');\n\nconst fs = require('fs');\n\nconst pawnTemplate = ['Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph'];\nconst pieceTemplate = ['Ra', 'Nb', 'Bc', 'Qd', 'Ke', 'Bf', 'Ng', 'Rh'];\n\n/**\n * @typedef {Object} cfg\n * @property {Function} filter - Descr\n * @property {Number} cntGames - Descr\n * @property {Boolean} split - Descr\n */\n\n/** Main class for batch processing and generating heat maps */\nclass Chessalyzer {\n\tconstructor() {\n\t\t/**\n\t\t * Contains the tracked data of the processed PGN files. Has two different banks for\n\t\t * heat map comparison. Each object contains the following keys:\n\t\t * <ul>\n\t\t * <li>data: {cntMoves, cntGames}. Information about the count of processed moves and games</li>\n\t\t * <li>tiles: 8x8 array of {@link ChessTile}s.</li>\n\t\t * </ul>\n\t\t * @member {Object[]}\n\t\t */\n\t\tthis.dataStore = new Array(2);\n\t\t/**\n\t\t * Does the analysis part\n\t\t * @private\n\t\t * @member {GameProcessor}\n\t\t */\n\t\tthis.gameProcessor = new GameProcessor();\n\t}\n\n\t/**\n\t * Starts the batch processing for the selected file\n\t * @param {String} path - Path to the PGN file that should be analyzed\n\t * @param {Object} cfg\n\t * @param {Function} cfg.filter - Filter function for selecting games\n\t * @param {Function} cfg.cntGames - Max amount of games to process\n\t * @param {Number} [bank = 0] - The data bank the results shall be saved to\n\t * @param {Number} [refreshRate = 250] - Defines how often the current status of the\n\t *  analysis shall be exposed. Every number of processed games an event is emitted\n\t *  containing the current number of processed games. The event can be handled via\n\t *  \"chessalyzer.gameProcessor.on('status', function(gameCnt) {// do handling here});\",\n\t *  e.g. to update an UI.\n\t * @returns {Promise} Promise that contains the number of processed games when finished\n\t */\n\tstartBatch(path, cfg = {}, bank = 0, refreshRate = 250) {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst t0 = performance.now();\n\t\t\tthis.gameProcessor\n\t\t\t\t.processPGN(path, cfg, refreshRate)\n\t\t\t\t.then((board) => {\n\t\t\t\t\tconst dataset = {};\n\t\t\t\t\tdataset.stats = board.stats;\n\t\t\t\t\tdataset.tiles = board.tiles;\n\t\t\t\t\tthis.dataStore[bank] = JSON.parse(JSON.stringify(dataset));\n\t\t\t\t\tconst t1 = performance.now();\n\t\t\t\t\tconst tdiff = Math.round(t1 - t0) / 1000;\n\t\t\t\t\tconst mps = Math.round(dataset.stats.cntMoves / tdiff);\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`${dataset.stats.cntGames} games (${\n\t\t\t\t\t\t\tdataset.stats.cntMoves\n\t\t\t\t\t\t} moves) processed in ${tdiff}s (${mps} moves/s)`\n\t\t\t\t\t);\n\t\t\t\t\tthis.gameProcessor.reset();\n\t\t\t\t\tresolve(this.dataStore[bank].stats.cntGames);\n\t\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Saves a completed batch run to a JSON file\n\t * @param {String} path - Path the data file shall be saved to\n\t * @param {Number} [bank = 0] - The data bank the data shall be taken from\n\t */\n\tsaveData(path, bank = 0) {\n\t\tfs.writeFile(path, JSON.stringify(this.dataStore[bank]), (err) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconsole.log('File has been created');\n\t\t});\n\t}\n\n\t/**\n\t * Loads the stats of a previous batch run (JSON) to a data bank\n\t * @param {String} path - Path the data file shall be loaded from\n\t * @param {Number} [bank = 0] - The data bank the data shall be loaded to.\n\t * @returns {Number} Count of loaded games\n\t */\n\tloadData(path, bank) {\n\t\tthis.dataStore[bank] = JSON.parse(fs.readFileSync(path, 'utf8'));\n\t\tconsole.log(`File '${path}' has been loaded to bank ${bank}.`);\n\t\treturn this.dataStore[bank].cntGames;\n\t}\n\n\t/**\n\t * Generates a heatmap out of the tracked data.\n\t * @param {Number} bank - The data bank the data shall be taken from\n\t * @param {String} square - The square the data shall be generated for. For example, if you\n\t * wanted to know how often a specific piece was on a specific tile, you would pass the\n\t * identifier of the tile to the function, e.g. \"a2\"\n\t * @param {Function} fun - The evaluation function that generates the heatmap out of the\n\t * saved data. This function gets passed the following arguments:\n\t * <ol>\n\t * <li>The complete data stored in the chosen bank. See the member description of the dataStore\n\t * member to see which data is available.</li>\n\t * <li>The coords of the tile passed as the square argument.</li>\n\t * <li>The current coordinates of the tile the data should be generated for.\n\t * The function must return a Number with the heat map value for the square passed as the\n\t * third argument.</li>\n\t * </ol>\n\t * See ./src/exampleHeatmapConfig for examples of such a function.\n\t * @returns {Array} Array with 3 entries:\n\t * <ol>\n\t * <li>8x8 Array containing the heat map values for each tile</li>\n\t * <li>The minimum value in the heatmap.</li>\n\t * <li>The maximum value in the heatmap.</li>\n\t * </ol>\n\t */\n\tgenerateHeatmap(bank, square, fun) {\n\t\tconst coords = GameProcessor.algebraicToCoords(square);\n\t\tconst map = [];\n\t\tlet max = 0;\n\t\tlet min = 100000;\n\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tconst dataRow = new Array(8);\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tdataRow[j] = fun(this.dataStore[bank], coords, [i, j]);\n\t\t\t\tif (dataRow[j] > max) max = dataRow[j];\n\t\t\t\tif (dataRow[j] < min) min = dataRow[j];\n\t\t\t}\n\t\t\tmap.push(dataRow);\n\t\t}\n\n\t\treturn [map, min, max];\n\t}\n\n\t/**\n\t * Generates a comparison heatmap out of the tracked data. There needs to data in both\n\t * banks you pass as bank1 and bank2 params. The heatmap for both banks are calculated\n\t * and then the relative differences between both banks are calculated. For example,\n\t * if the heatmap value for \"a1\" of bank1 is 10 and the value of bank2 is 5, the returned\n\t * value for \"a1\" would be 100% ([[10/5] -1] *100).\n\t * @param {String} square - The square the data shall be generated for.\n\t * @param {Function} fun - The evaluation function that generates the heatmap out of the\n\t * saved data. See {@link Chessalyzer#generateHeatmap} for a more detailed description.\n\t * @param {Number} [bank1 = 0] - Bank number of dataset 1\n\t * @param {Number} [bank2 = 1] - Bank number of dataset 2\n\t * @returns {Array} Array with 3 entries:\n\t * <ol>\n\t * <li>8x8 Array containing the heat map values for each tile</li>\n\t * <li>The minimum value in the heatmap.</li>\n\t * <li>The maximum value in the heatmap.</li>\n\t * </ol>\n\t */\n\tgenerateComparisonHeatmap(square, fun, bank1 = 0, bank2 = 1) {\n\t\tconst map = [];\n\t\tlet max = 0;\n\t\tlet min = 100000;\n\n\t\t// comparison heatmap\n\t\tconst data0 = this.generateHeatmap(bank1, square, fun);\n\t\tconst data1 = this.generateHeatmap(bank2, square, fun);\n\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tconst dataRow = new Array(8);\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tconst a = data0[0][i][j];\n\t\t\t\tconst b = data1[0][i][j];\n\t\t\t\tif (a === 0 || b === 0) dataRow[j] = 0;\n\t\t\t\telse dataRow[j] = (a >= b ? a / b - 1 : -b / a + 1) * 100;\n\n\t\t\t\tif (dataRow[j] > max) max = dataRow[j];\n\t\t\t\tif (dataRow[j] < min) min = dataRow[j];\n\t\t\t}\n\t\t\tmap.push(dataRow);\n\t\t}\n\n\t\treturn [map, min, max];\n\t}\n\n\tstatic generateList(map) {\n\t\tconst list = [];\n\t\tfor (let i = 0; i < 8; i += 1) {\n\t\t\tfor (let j = 0; j < 8; j += 1) {\n\t\t\t\tlet val = map[i][j];\n\t\t\t\tval = val.toFixed(2);\n\t\t\t\tif (Math.abs(val) > 0.001) {\n\t\t\t\t\tif (i === 0) list.push([`b${pieceTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 1) list.push([`b${pawnTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 6) list.push([`w${pawnTemplate[j]}`, val]);\n\t\t\t\t\telse if (i === 7) list.push([`w${pieceTemplate[j]}`, val]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlist.sort((a, b) => b[1] - a[1]);\n\t\treturn list;\n\t}\n}\n\nexport default Chessalyzer;\n","/* eslint-disable */\nimport Chessalyzer from './Chessalyzer';\n\nexport default Chessalyzer;\n"],"sourceRoot":""}